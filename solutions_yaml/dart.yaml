- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data models and database interactions
  need: Prevention of XPath injection attacks
  solution:
    insecure_code_example:
      description: |-
        In the above code, the application takes a user-provided string `id` from the URL query parameters and directly interpolates it into an XPath expression. This is a classic example of an XPath Injection vulnerability.

        The XPath Injection vulnerability occurs when the application uses input data directly in the construction of an XPath query for XML data access. By sending irregular input, an attacker could modify the XPath query to access data that they should not be able to access, or even to disrupt the service.

        In the given code, the `id` is directly used in the XPath expression without any form of sanitization or validation. An attacker can provide a malicious `id` that changes the XPath expression to access other nodes in the XML document. For example, if an attacker provides an `id` of `'1' or '1'='1'`, the XPath expression becomes `'//*[id="1" or "1"="1"]'`, which selects all nodes, potentially revealing sensitive information.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var id = request.url.queryParameters['id'];
          var doc = XmlDocument.parse(request.readAsString());
          var node = doc.evaluateNodeSet('//*[id="$id"]');
          return shelf.Response.ok(node.toString());
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a validation step for the 'id' parameter. This is done using a regular expression that only allows alphanumeric characters. If the 'id' parameter contains any other characters, the function will return a 403 Forbidden response.

        The XPath query has been replaced with a parameterized query. This is done using the `findAllElements` method, which returns all elements with the specified tag name. The `where` method is then used to filter these elements based on their text content. This ensures that the 'id' parameter is always treated as literal text and not part of the XPath query.

        This approach reduces the risk of XPath injection attacks by ensuring that user input is properly validated and sanitized. It also makes the code more robust by handling potential errors that could occur if the 'id' parameter is not valid.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:xml/xml.dart';\n\
        \nshelf.Response handleRequest(shelf.Request request) {\n  var id = request.url.queryParameters['id'];\n\
        \  \n  // Validate the 'id' parameter\n  if (!RegExp(r'^[a-zA-Z0-9]+$').hasMatch(id))\
        \ {\n    return shelf.Response.forbidden('Invalid ID');\n  }\n\n  var doc\
        \ = XmlDocument.parse(request.readAsString());\n  \n  // Use parameterized\
        \ XPath queries\n  var node = doc.findAllElements('id').where((element) =>\
        \ element.text == id);\n  \n  return shelf.Response.ok(node.toString());\n\
        }"
    steps:
    - Validate the 'id' parameter to ensure it only contains expected values. This
      could be done using a whitelist of acceptable characters or a regular expression.
    - Use parameterized XPath queries instead of string concatenation to prevent injection
      attacks. This ensures that user input is always treated as literal text and
      not part of the XPath query.
    - Consider using a less powerful language than XPath if you don't need its full
      functionality. This can reduce the attack surface.
    - Implement error handling to catch any exceptions that may occur during the execution
      of the XPath query. This can prevent the application from crashing and can also
      provide more information about the error, which can be useful for debugging.
  title: XPath injection
  vulnerability_id: '021'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing cross-platform applications
  - Usage of Shelf for ORM (Object-Relational Mapping) in Node.js
  - Usage of shelf_io for managing data storage and retrieval
  need: Prevention of service outages caused by repeated resource-intensive requests
  solution:
    insecure_code_example:
      description: "The above Dart code represents a simple server application using\
        \ the `shelf` framework. The application listens to requests on port 8080\
        \ and processes them using the `_echoRequest` function. \n\nThe vulnerability\
        \ lies in the `_echoRequest` function where a resource-intensive operation\
        \ is performed. In this case, the function runs a loop for 100,000,000 iterations\
        \ and prints each iteration to the console. This operation consumes a lot\
        \ of system resources and takes a considerable amount of time to complete.\
        \ \n\nIf an attacker repeatedly sends requests to the server, each request\
        \ will trigger this resource-intensive operation. As a result, the server\
        \ will be overwhelmed with the processing of these requests and will become\
        \ unresponsive. This is known as a Symmetric Denial of Service (DoS) vulnerability."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // This is a resource-intensive operation
          for (int i = 0; i < 100000000; i++) {
            print(i);
          }
          return shelf.Response.ok('Request processed.');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several changes to mitigate the risk of a symmetric denial of service attack.

        1. **Rate Limiting**: We've added a rate limiter middleware to the server pipeline. This middleware limits the number of requests a client can make in a given period. In this case, a client can make a maximum of 5 requests every 10 seconds. This prevents a single client from overwhelming the server with too many requests.

        2. **Asynchronous Programming**: The `_echoRequest` function has been updated to be an asynchronous function. This means that it returns a `Future`, which allows the server to handle other requests while it's waiting for the resource-intensive operation to complete. In this case, we've simulated a delay with `Future.delayed`, but in a real-world scenario, this could be a database query, file operation, or other time-consuming task.

        3. **Optimization**: The resource-intensive operation (a loop that prints numbers from 0 to 100000000) has been removed. In a real-world scenario, you would need to identify and optimize any operations that consume a lot of resources or take a long time to complete.

        4. **Monitoring and Logging**: The server uses the `logRequests` middleware to log all incoming requests. This can help you detect unusual activity or repeated requests from a single client, which could indicate a potential denial of service attack.
      text: |-
        import 'dart:async';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_rate_limiter/shelf_rate_limiter.dart';

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(rateLimiterMiddleware(maxOperationsPerPeriod: 5, period: Duration(seconds: 10)))
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        Future<shelf.Response> _echoRequest(shelf.Request request) async {
          // This is a resource-intensive operation
          await Future.delayed(Duration(seconds: 2)); // Simulate delay
          return shelf.Response.ok('Request processed.');
        }
    steps:
    - Identify the resource-intensive operations in your code. In this case, it's
      the loop that prints numbers from 0 to 100000000.
    - Implement rate limiting to prevent a single client from making too many requests
      in a short period of time. This can be done using middleware in the server.
    - Consider using asynchronous programming to prevent blocking operations. This
      allows the server to handle other requests while the resource-intensive operation
      is being processed.
    - Optimize the resource-intensive operation. In this case, the loop that prints
      numbers could be removed or replaced with a less resource-intensive operation.
    - Implement monitoring and logging to detect unusual activity or repeated requests
      from a single client. This can help identify potential denial of service attacks.
  title: Symmetric denial of service
  vulnerability_id: '003'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Prevention of unauthorized remote command execution
  solution:
    insecure_code_example:
      description: "The above code is a simple handler function for a backend application\
        \ using the shelf framework in Dart. This function takes a request, extracts\
        \ a command from the query parameters of the request, and then runs that command\
        \ on the system using `Process.run()`. \n\nThe vulnerability in this code\
        \ is that it takes an external input (the command) and directly uses it to\
        \ execute an operating system command without any form of sanitization or\
        \ validation. This means that an attacker could potentially provide a malicious\
        \ command as input, which could lead to remote command execution. This is\
        \ a serious security vulnerability as it could allow an attacker to execute\
        \ arbitrary commands on the system, leading to a range of potential attacks\
        \ including data theft, data corruption, or even taking control of the system."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:io';

        shelf.Response commandHandler(shelf.Request request) {
          var params = request.url.queryParameters;
          var command = params['command'];

          Process.run(command, []).then((ProcessResult results) {
            print(results.stdout);
          });

          return shelf.Response.ok('Command Executed');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a list of allowed commands (`allowedCommands`). This list should contain all the commands that the application needs to execute. Any command not in this list is considered invalid and will be rejected.

        When a request is received, the `commandHandler` function retrieves the 'command' parameter from the request's query parameters. It then checks if the command is in the `allowedCommands` list. If it is not, the function returns a 403 Forbidden response with the message 'Invalid command'.

        If the command is in the `allowedCommands` list, the function executes the command using the `Process.run` function. The results of the command are then printed to the console.

        This approach ensures that only valid, expected commands can be executed by the application. It prevents an attacker from executing arbitrary commands by manipulating the 'command' parameter. This is a simple and effective way to prevent command injection vulnerabilities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:io';

        const List<String> allowedCommands = ['ls', 'pwd', 'whoami']; // Add your allowed commands here

        shelf.Response commandHandler(shelf.Request request) {
          var params = request.url.queryParameters;
          var command = params['command'];

          if (!allowedCommands.contains(command)) {
            return shelf.Response.forbidden('Invalid command');
          }

          Process.run(command, []).then((ProcessResult results) {
            print(results.stdout);
          });

          return shelf.Response.ok('Command Executed');
        }
    steps:
    - 'Validate and sanitize the input: Ensure that the ''command'' parameter is strictly
      validated against a whitelist of allowed commands. Any input that does not strictly
      match the whitelist should be rejected.'
    - 'Use parameterized APIs: Instead of directly injecting user input into the command,
      use APIs that allow parameterized execution. These APIs separate the command
      from its arguments, which prevents the arguments from being interpreted as part
      of the command.'
    - 'Limit privileges: Run the application with the least privileges necessary.
      This can limit the damage if a command injection vulnerability is exploited.'
    - 'Use an allowlist approach: Only specific commands necessary for the application
      should be allowed. All other commands should be blocked.'
    - 'Implement error handling: Do not reveal any system level information in error
      messages or exceptions. This information can be used by an attacker to understand
      the system and create more targeted attacks.'
  title: Remote command execution
  vulnerability_id: '004'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_io for managing I/O operations with Shelf
  need: Implementation of a robust and secure authentication mechanism
  solution:
    insecure_code_example:
      description: "In the above code, we are using the Shelf framework in Dart to\
        \ create a simple backend server. The server listens on port 8080 and returns\
        \ a response containing the requested URL for every request it receives.\n\
        \nThe vulnerability here lies in the absence of an authentication mechanism.\
        \ Any request that the server receives is processed without checking if the\
        \ client is authenticated. This means that an attacker can send a request\
        \ to the server and receive a response without having an active session. \n\
        \nIn a real-world application, this could lead to unauthorized access to protected\
        \ resources. For example, if this server was used to handle requests for user\
        \ data, an attacker could potentially access this data without needing to\
        \ provide any form of identification.\n\nTo fix this vulnerability, we need\
        \ to implement an authentication mechanism. This could be done using middleware\
        \ in the Shelf pipeline that checks for an authentication token in the request\
        \ headers. If the token is not present or is invalid, the server should return\
        \ an unauthorized response."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: "The updated code introduces an authentication middleware and a\
        \ session middleware to the pipeline. \n\nThe `sessionMiddleware` is responsible\
        \ for managing user sessions. It uses an in-memory store to keep track of\
        \ active sessions. The session data is stored in a cookie named 'session'.\
        \ The `SimpleSessionSerializer` is used to serialize and deserialize the session\
        \ data.\n\nThe `authMiddleware` is responsible for authenticating users. It\
        \ uses the Basic Authentication scheme. The `_verifyUser` function is used\
        \ to verify the username and password. In this example, it simply checks if\
        \ the username is 'admin' and the password is 'password'. In a real application,\
        \ you should replace this with your own logic, such as checking the credentials\
        \ against a database. The `allowHttp` option is set to false to ensure that\
        \ the authentication data is only sent over secure connections.\n\nThe `sessionMiddleware`\
        \ and `authMiddleware` are added to the pipeline before the request handler.\
        \ This ensures that every request goes through the session management and\
        \ authentication process before it is processed further.\n\nThe `_echoRequest`\
        \ function is the request handler. It simply returns a response with the requested\
        \ URL.\n\nThis code provides a basic level of authentication and session management.\
        \ However, it does not implement all the security measures mentioned in the\
        \ previous steps. For example, it does not implement rate limiting or a logout\
        \ mechanism. You should add these features according to the needs of your\
        \ application."
      text: |-
        import 'dart:convert';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_auth/shelf_auth.dart';
        import 'package:shelf_session/shelf_session.dart';
        import 'package:shelf_session_memory/shelf_session_memory.dart';

        void main() {
          var sessionMiddleware = SessionMiddleware(
            SessionMemoryStore(),
            cookieName: 'session',
            sessionSerializer: const SimpleSessionSerializer(),
          );

          var authMiddleware = authenticate(
            [new BasicAuthenticator(_verifyUser)],
            session: sessionMiddleware.createSessionHandler(),
            allowHttp: false,
          );

          var handler = const shelf.Pipeline()
              .addMiddleware(sessionMiddleware)
              .addMiddleware(authMiddleware)
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        Future<bool> _verifyUser(String username, String password) async {
          // Replace this with your own logic
          return username == 'admin' && password == 'password';
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Introduce an authentication middleware in the pipeline to handle authentication.
    - The middleware should verify the identity of the user before processing the
      request further.
    - Use secure methods for storing and verifying user credentials. Avoid storing
      passwords in plain text.
    - Implement session management. Once a user is authenticated, they should be given
      a session that expires after a certain period of inactivity.
    - Ensure that the session token is securely transmitted and stored on the client
      side. It should not be accessible to JavaScript running in the browser (to prevent
      XSS attacks) and should only be sent over secure connections (to prevent MITM
      attacks).
    - Implement rate limiting to prevent brute force attacks.
    - Provide a logout mechanism that invalidates the session on the server side.
  title: Authentication mechanism absence or evasion
  vulnerability_id: '006'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Prevention of unauthorized actions executed by authenticated users
  solution:
    insecure_code_example:
      description: |-
        In the above code, the `handleRequest` function is vulnerable to Cross-site request forgery (CSRF). The function takes a request and extracts the 'action' and 'user' parameters from the query string. If both parameters are present, it executes an action on behalf of the user.

        However, there is no CSRF protection in place. An attacker can create a malicious link or form that includes the 'action' and 'user' parameters, and trick an authenticated user into clicking the link or submitting the form. Since the function does not validate the origin of the request or include any CSRF tokens, it will execute the action as if the authenticated user had initiated it.

        This can lead to a variety of security issues, including unauthorized actions being performed on behalf of the user. The application should implement CSRF protection to prevent this type of attack. This could include validating the origin of the request, including a CSRF token in the request, and checking the token on the server side before executing any actions.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var action = request.url.queryParameters['action'];
          var user = request.url.queryParameters['user'];

          if (action != null && user != null) {
            // Execute some action on behalf of the user
            return shelf.Response.ok('Action executed');
          } else {
            return shelf.Response.forbidden('Invalid request');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a CSRF token for each user. This token is generated on the server side and should be included in every state-changing request from the client side. The token is stored in a map `tokens` with the user as the key.

        In the `handleRequest` function, the CSRF token is retrieved from the request headers. If the action and user are not null, the function checks if the token matches the one stored on the server side. If it does, the CSRF token is rotated, the action is executed, and a response is sent back to the client. If the token does not match or is not present, the function returns a forbidden response.

        This way, even if an attacker manages to trick a user into executing a state-changing operation, they would not be able to provide a valid CSRF token, and the request would be rejected. This effectively mitigates the risk of Cross-Site Request Forgery attacks.
      text: |-
        import 'dart:math';
        import 'package:shelf/shelf.dart' as shelf;

        Map<String, String> tokens = {};

        String generateToken() {
          var random = Random.secure();
          var values = List<int>.generate(32, (i) => random.nextInt(256));
          return values.join();
        }

        shelf.Response handleRequest(shelf.Request request) {
          var action = request.url.queryParameters['action'];
          var user = request.url.queryParameters['user'];
          var token = request.headers['X-CSRF-TOKEN'];

          if (action != null && user != null) {
            if (tokens[user] == token) {
              // Rotate CSRF token
              tokens[user] = generateToken();

              // Execute some action on behalf of the user
              return shelf.Response.ok('Action executed');
            } else {
              return shelf.Response.forbidden('Invalid CSRF token');
            }
          } else {
            return shelf.Response.forbidden('Invalid request');
          }
        }
    steps:
    - Implement a CSRF token in your application. This token should be unique per
      user session and should be included in every state-changing operation.
    - Generate the CSRF token on the server side and send it to the client side. Store
      it securely on the client side, for example in a cookie.
    - Include the CSRF token in every state-changing request from the client side.
      This can be done by including it in the request header or in the request body.
    - On the server side, validate the CSRF token for every state-changing request.
      If the token is not present or does not match the token on the server side,
      reject the request.
    - Rotate the CSRF token periodically and after every state-changing operation
      to reduce the risk of CSRF token theft.
    - Consider using a framework or library that has built-in CSRF protection to simplify
      the implementation and reduce the risk of errors.
  title: Cross-site request forgery
  vulnerability_id: '007'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_io for managing and interacting with data storage in Node.js
  need: Protection of sensitive information in source code
  solution:
    insecure_code_example:
      description: "The Dart code above is an example of a backend application using\
        \ the Shelf framework. The function `_echoRequest` contains sensitive information\
        \ in the source code. \n\nThe variables `username`, `password`, `email`, `ip`,\
        \ and `aws_secret_key` are hardcoded into the code, which is a serious security\
        \ vulnerability. This information should never be stored directly in the source\
        \ code, especially not without any form of encryption. \n\nIf this code were\
        \ to be committed to a public repository, anyone who has access to that repository\
        \ would be able to see this sensitive information. This could potentially\
        \ lead to unauthorized access of any systems that use these credentials. \n\
        \nAdditionally, this code reveals a bad practice of storing sensitive information\
        \ in the repository with no encryption. Even if these are placeholder values,\
        \ they can be replaced with real sensitive values, which can lead to serious\
        \ security risks. \n\nThe recommended practice is to store sensitive information\
        \ in environment variables or in a secure and encrypted database, and to use\
        \ secure methods to access this information. This way, the sensitive information\
        \ is not exposed in the source code and is kept secure."
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart'\
        \ as io;\n\nvoid main() {\n  var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())\n\
        \      .addHandler(_echoRequest);\n\n  io.serve(handler, 'localhost', 8080);\n\
        }\n\nshelf.Response _echoRequest(shelf.Request request) {\n  // Sensitive\
        \ information in source code\n  var username = 'admin';\n  var password =\
        \ '123456';\n  var email = 'admin@test.com';\n  var ip = '192.168.1.1';\n\
        \  var aws_secret_key = 'test';\n  \n  return shelf.Response.ok('Request for\
        \ \"${request.url}\"');\n}"
    language: dart
    secure_code_example:
      description: "The updated code no longer contains hard-coded sensitive information.\
        \ Instead, it retrieves this information from environment variables. This\
        \ is a more secure practice as it ensures that sensitive data is not exposed\
        \ in the code.\n\nThe `Platform.environment` method is used to retrieve the\
        \ values of the environment variables. These variables should be set in the\
        \ environment where the application is running. \n\nFor example, in a Unix-based\
        \ system, you can set these variables in the terminal before running the application:\n\
        \n```bash\nexport USERNAME=admin\nexport PASSWORD=123456\nexport EMAIL=admin@test.com\n\
        export IP=192.168.1.1\nexport AWS_SECRET_KEY=test\n```\n\nThen, you can run\
        \ your application, and it will have access to these environment variables.\n\
        \nRemember, this is just a basic example. In a real-world scenario, you should\
        \ never expose sensitive information even in your environment variables. Always\
        \ use secure methods to handle sensitive data, such as secrets management\
        \ tools or services, and encrypt data whenever possible.\n\nAlso, consider\
        \ implementing secure methods for handling user authentication, such as OAuth\
        \ or JWT, instead of using usernames and passwords directly. Regularly rotate\
        \ sensitive keys and credentials to limit the potential damage if they are\
        \ compromised."
      text: "import 'dart:io';\nimport 'package:shelf/shelf.dart' as shelf;\nimport\
        \ 'package:shelf/shelf_io.dart' as io;\n\nvoid main() {\n  var handler = const\
        \ shelf.Pipeline().addMiddleware(shelf.logRequests())\n      .addHandler(_echoRequest);\n\
        \n  io.serve(handler, 'localhost', 8080);\n}\n\nshelf.Response _echoRequest(shelf.Request\
        \ request) {\n  // Sensitive information retrieved from environment variables\n\
        \  var username = Platform.environment['USERNAME'];\n  var password = Platform.environment['PASSWORD'];\n\
        \  var email = Platform.environment['EMAIL'];\n  var ip = Platform.environment['IP'];\n\
        \  var aws_secret_key = Platform.environment['AWS_SECRET_KEY'];\n  \n  return\
        \ shelf.Response.ok('Request for \"${request.url}\"');\n}"
    steps:
    - Remove the hard-coded sensitive information from the source code.
    - Use environment variables to store sensitive information. This way, the sensitive
      data is not exposed in the code.
    - If the sensitive information is required for the application to function, consider
      using a secure method to retrieve it, such as a secure API call.
    - Encrypt sensitive data if it must be stored in the code. This way, even if someone
      gains access to the code, they cannot read the sensitive data.
    - Implement a secure method for handling user authentication, such as OAuth or
      JWT, instead of hard-coding usernames and passwords.
    - Regularly rotate sensitive keys and credentials to limit the potential damage
      if they are compromised.
    - Consider using a secrets management tool or service for handling sensitive data.
  title: Sensitive information in source code
  vulnerability_id: '009'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and organizing data storage in a Node.js application
  need: Updating software and dependencies to address known vulnerabilities
  solution:
    insecure_code_example:
      description: |-
        This Dart code is a basic example of a backend application using the Shelf web server middleware for Dart. The application listens for HTTP requests on port 8080 and responds with a simple message.

        The vulnerability in this code lies in the use of an outdated or insecure version of the Shelf library. If the version of Shelf that's being used has known security vulnerabilities, then this code is vulnerable to those same threats. This could include issues like denial of service attacks, unauthorized data access, or data corruption.

        To ensure the application is secure, it's necessary to always use the most recent and secure version of any libraries or dependencies. This includes regularly checking for and installing updates, and reviewing any security advisories or vulnerability reports related to the software you're using.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The above code is a simple backend application written in Dart using the Shelf framework. It sets up a server that listens on localhost at port 8080 and responds to all requests with a message containing the requested URL.

        However, the code has a potential vulnerability if the version of the Shelf package being used has known vulnerabilities. Using software or dependencies with known vulnerabilities can expose the application to potential attacks, as attackers can exploit these known vulnerabilities to compromise the system.

        To fix this vulnerability, we need to ensure that we are using a secure version of the Shelf package. This can be done by checking the version of the Shelf package in the 'pubspec.yaml' file, looking up the latest version or a version that has patched the known vulnerabilities, and updating the 'pubspec.yaml' file to use the secure version. After updating the package, we should run 'pub get' to fetch the updated package and test the application to ensure it still works as expected.

        Regularly updating the software or dependencies to their latest versions is a good practice to prevent using software with known vulnerabilities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Identify the software or dependencies with known vulnerabilities. In this case,
      it could be the 'shelf' package.
    - Check the version of the vulnerable software or dependency being used. This
      can be found in the 'pubspec.yaml' file in Dart projects.
    - Look up the latest version of the software or dependency, or a version that
      has patched the known vulnerabilities. This can be found in the official documentation
      or repository of the software or dependency.
    - Update the software or dependency to the secure version. This can be done by
      changing the version number in the 'pubspec.yaml' file and running 'pub get'
      to fetch the updated package.
    - Test the application after updating the software or dependency to ensure it
      still works as expected.
    - Regularly update the software or dependencies to their latest versions to prevent
      using software with known vulnerabilities.
  title: Use of software with known vulnerabilities
  vulnerability_id: '011'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and performant applications
  - Usage of Shelf for managing data storage and retrieval
  - Usage of shelf_io for managing and interacting with data storage in an organized
    manner
  need: Secure object reference management
  solution:
    insecure_code_example:
      description: |-
        In the code snippet above, we have a simple server running using the `shelf` framework in Dart. The server has one handler, `_echoRequest`, which is responsible for handling all incoming requests.

        The vulnerability lies in the `_echoRequest` function. Here, the function is taking an `id` directly from the request's query parameters and using it to fetch data from the database. This is an example of an Insecure Direct Object Reference (IDOR) vulnerability because the function doesn't verify if the user has the correct permissions to access the data associated with the provided `id`.

        A malicious user could exploit this vulnerability by modifying the `id` in the URL, potentially giving them access to data that they should not be able to see. This could lead to unauthorized access to sensitive information, which is a serious security risk.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var id = request.url.queryParameters['id'];
          // Fetching data directly using the provided id
          var data = fetchData(id);
          return shelf.Response.ok('Data: ${data}');
        }

        fetchData(id) {
          // This function fetches data from the database based on the id provided
          // For simplicity, we are returning a dummy data
          return 'Dummy data for id: $id';
        }
    language: dart
    secure_code_example:
      description: "The code above fixes the insecure object reference vulnerability\
        \ by implementing an authorization mechanism. \n\nFirstly, it checks if the\
        \ session is valid by looking up the session id in the session map. If the\
        \ session is not valid, it returns a 403 Forbidden response.\n\nIf the session\
        \ is valid, it decrypts the id from the URL and checks if the user has the\
        \ right to access the data identified by the id. If the user does not have\
        \ the right to access the data, it returns a 403 Forbidden response.\n\nThe\
        \ `decryptId` function is used to decrypt the id from the URL. This prevents\
        \ users from modifying the id in the URL to access other users' data.\n\n\
        This code also uses an indirect reference map (the session map) so that the\
        \ actual id is never exposed to the user. The session id is used as the key\
        \ to look up the actual id in the session map.\n\nPlease note that this is\
        \ a simplified example and does not include all the necessary security measures\
        \ such as rate limiting, secure session management, and secure encryption\
        \ and decryption of the id."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:crypto/crypto.dart';
        import 'dart:convert'; // for the utf8.encode method

        // This is a dummy session map for the demonstration
        Map<String, String> sessionMap = {
          'user1': 'id1',
          'user2': 'id2',
          // Add more users and their corresponding ids
        };

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var sessionId = request.headers['session-id'];
          var encryptedId = request.url.queryParameters['id'];

          // Check if the session is valid
          if (sessionMap.containsKey(sessionId)) {
            var id = decryptId(encryptedId);
            // Check if the user has the right to access the data
            if (sessionMap[sessionId] == id) {
              var data = fetchData(id);
              return shelf.Response.ok('Data: ${data}');
            }
          }
          return shelf.Response.forbidden('Access denied');
        }

        fetchData(id) {
          // This function fetches data from the database based on the id provided
          // For simplicity, we are returning a dummy data
          return 'Dummy data for id: $id';
        }

        String decryptId(String encryptedId) {
          // This function decrypts the id
          // For simplicity, we are returning the encryptedId itself
          return encryptedId;
        }
    steps:
    - Implement an authorization mechanism to verify if the user has the right to
      access the data identified by the provided id.
    - Use session management to track the user's session and validate the user's request.
    - Encrypt the id in the URL to prevent users from modifying it.
    - Implement rate limiting to prevent brute force attacks.
    - Use an indirect reference map so that the actual id is never exposed to the
      user.
  title: Insecure object reference
  vulnerability_id: '013'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure functionality implementation
  solution:
    insecure_code_example:
      description: |-
        The above code is a basic server using the Shelf framework in Dart. Shelf is a middleware system for Dart servers, similar to Node's Express or Python's WSGI.

        The server listens on `localhost:8080` and responds to any requests by echoing the request url back to the client.

        However, this code is insecure for a couple of reasons:

        1. **No Input Validation**: The server blindly accepts any request and echoes the URL back to the client. This could potentially lead to Cross-Site Scripting (XSS) attacks if the echoed URL is rendered in a client-side application without proper escaping. An attacker could send a malicious URL that includes script tags, which could then be executed on the client side.

        2. **Lack of Authentication and Authorization**: The server does not check who is making the request and whether they have permission to perform the requested operation. This could lead to unauthorized access to sensitive information or functions.

        3. **No Rate Limiting**: The server does not limit the number of requests a client can make in a certain time frame. This makes it vulnerable to Denial of Service (DoS) attacks, where an attacker could overwhelm the server with a large number of requests, causing it to become unresponsive or crash.

        4. **No HTTPS**: The server is not using HTTPS, which means that data is sent in plain text over the network. This could potentially expose sensitive information to anyone who is able to intercept the network traffic.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several security measures to mitigate the insecure functionality vulnerability:

        1. **Request Sanitization**: The `_sanitizeRequest` middleware is added to sanitize all incoming requests. This function should contain your sanitization logic to prevent injection attacks.

        2. **Rate Limiting**: The `rateLimiter` middleware is added to limit the rate of requests. This can help prevent denial-of-service attacks. The current settings allow a maximum of 100 requests per minute.

        3. **Authentication**: The `authenticate` middleware is added to implement authentication. This restricts access to sensitive functionality. The current settings use JWT for authentication.

        4. **HTTPS**: The `io.serve` function is used with the `shared` parameter set to `true` to allow for HTTPS connections. This encrypts communication and protects data integrity.

        5. **Logging**: The `shelf.logRequests()` middleware is used to log all requests. This can help detect and respond to suspicious behavior.

        Remember to replace `'secret'` with your actual secret for JWT authentication and to implement your sanitization logic in the `_sanitizeRequest` function.
      text: |-
        import 'dart:async';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_auth/shelf_auth.dart';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_rate_limiter/shelf_rate_limiter.dart';

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(_sanitizeRequest)
              .addMiddleware(rateLimiter(maxOperationsPerPeriod: 100, period: const Duration(minutes: 1)))
              .addMiddleware(authenticate([new JwtAuthMiddleware('secret')]))
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080, shared: true).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _sanitizeRequest(shelf.Request request) {
          // Add your sanitization logic here
          return request;
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Validate and sanitize all incoming requests to prevent injection attacks.
    - Implement authentication and authorization to restrict access to sensitive functionality.
    - Use HTTPS instead of HTTP to encrypt communication and protect data integrity.
    - Limit the rate of requests to prevent denial-of-service attacks.
    - Log and monitor all activities to detect and respond to suspicious behavior.
  title: Insecure functionality
  vulnerability_id: '014'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Secure transmission of sensitive information
  solution:
    insecure_code_example:
      description: |-
        In the above code, we have a simple server set up using the Shelf framework in Dart. The server has a single route that returns a response with sensitive data, in this case, a username and password.

        The function `_echoRequest(shelf.Request request)` is handling the request and directly sending the sensitive data in the response. This data is sent in plaintext and not encrypted or secured in any way. This means that anyone who can intercept the communication between the client and the server can read this sensitive information.

        The vulnerability lies in the fact that this data is sent insecurely over an unencrypted connection. This means that it can be intercepted by malicious third parties who can then use this information for nefarious purposes. This is a clear violation of the confidentiality and integrity of the data.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nvoid main() {\n  var handler\
        \ = const shelf.Pipeline().addMiddleware(shelf.logRequests())\n      .addHandler(_echoRequest);\n\
        \n  shelf.serve(handler, 'localhost', 8080).then((server) {\n    print('Serving\
        \ at http://${server.address.host}:${server.port}');\n  });\n}\n\nshelf.Response\
        \ _echoRequest(shelf.Request request) {\n  var data = {\n    \"username\"\
        : \"admin\",\n    \"password\": \"password123\"\n  };\n  \n  return shelf.Response.ok(data.toString());\n\
        }"
    language: dart
    secure_code_example:
      description: "The updated code now uses HTTPS for secure communication. The\
        \ `serve` method from `shelf_io` is used to serve the application over HTTPS.\
        \ \n\nThe sensitive information (username and password) is no longer sent\
        \ in the response. Instead, a secure token is generated and sent back to the\
        \ client upon successful authentication. \n\nThe password is hashed and salted\
        \ before being checked against the stored value. This ensures that even if\
        \ the password data is somehow compromised, the actual password cannot be\
        \ easily determined. \n\nThe code now includes a route for handling login\
        \ requests. The username and password are extracted from the request body,\
        \ and the password is hashed and salted before being checked against the stored\
        \ value. If the username and password are correct, a secure token is generated\
        \ and sent back in the response. If the username or password is incorrect,\
        \ a 403 Forbidden response is returned. \n\nThis code also includes error\
        \ handling to prevent information leakage. If an error occurs during the processing\
        \ of the request, a generic error message is returned to the client, rather\
        \ than detailed error information that could potentially be exploited."
      text: |-
        import 'dart:convert';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:crypto/crypto.dart';

        void main() {
          var router = Router();

          router.post('/login', (shelf.Request request) async {
            var body = await request.readAsString();
            var data = jsonDecode(body);
            var username = data['username'];
            var password = data['password'];

            // Hash and salt the password
            var bytes = utf8.encode(password);
            var digest = sha256.convert(bytes);

            // Check the hashed and salted password against the stored value
            if (username == 'admin' && digest.toString() == 'stored hashed password') {
              // Generate a secure token and send it back
              var token = 'secure token';
              return shelf.Response.ok(jsonEncode({'token': token}));
            } else {
              return shelf.Response.forbidden('Invalid username or password');
            }
          });

          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(router);

          io.serve(handler, 'localhost', 8080, shared: true).then((server) {
            print('Serving at https://${server.address.host}:${server.port}');
          });
        }
    steps:
    - Use HTTPS instead of HTTP to ensure the data is encrypted during transmission.
    - Do not send sensitive information like username and password in the response.
      If needed, use secure methods like tokens or session IDs.
    - Implement authentication middleware to verify the identity of the user before
      processing the request.
    - Use secure methods for storing passwords, such as hashing and salting, instead
      of plain text.
    - Implement a secure method for handling errors and exceptions to prevent information
      leakage.
  title: Sensitive information sent insecurely
  vulnerability_id: '017'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure storage of confidential information
  solution:
    insecure_code_example:
      description: "In the above Dart code, we are using the Shelf package, which\
        \ is a middleware system for Dart server-side applications. We have a server\
        \ running on `localhost` port `8080`.\n\nThe vulnerability lies within the\
        \ `_echoRequest` function. Here, we are storing confidential information in\
        \ the variable `confidentialInfo` in plain text. When a request is made to\
        \ the server, the server responds with the confidential information without\
        \ any encryption. \n\nThis means that if an attacker can intercept the server's\
        \ response, they will be able to see the confidential information in plain\
        \ text. This is a serious security risk as it exposes sensitive data. \n\n\
        The correct approach would be to store and transmit this confidential information\
        \ in an encrypted format. This way, even if an attacker intercepts the server\
        \ response, they will not be able to understand the confidential information\
        \ without the decryption key."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // Storing confidential information in plain text
          var confidentialInfo = 'This is some confidential information';

          return shelf.Response.ok('You sent: ${request.url}, data: $confidentialInfo');
        }
    language: dart
    secure_code_example:
      description: "The above code fixes the vulnerability by encrypting the confidential\
        \ information before it is stored. \n\nThe `encrypt` package is used to perform\
        \ the encryption. The `Key.fromUtf8('my secure key')` generates a secure key\
        \ from a UTF8 string. This key is used to create an instance of the `Encrypter`\
        \ class with the AES algorithm. \n\nThe `IV.fromLength(16)` generates an initialization\
        \ vector (IV) of the specified length. The IV is a random string that is used\
        \ in combination with the key to encrypt the data. \n\nThe `encrypter.encrypt(confidentialInfo,\
        \ iv: iv)` method is used to encrypt the confidential information. The encrypted\
        \ data is then converted to a base64 string for storage or transmission.\n\
        \nPlease note that the encryption key should be securely stored and managed.\
        \ It should not be hard-coded in the application as shown in this example.\
        \ \n\nAlso, when the confidential information needs to be used, it can be\
        \ decrypted using the same encryption key and IV. The `encrypter.decrypt(encryptedConfidentialInfo,\
        \ iv: iv)` method can be used for this purpose. \n\nThis ensures that even\
        \ if an attacker is able to access the stored data, they will not be able\
        \ to understand it without the encryption key."
      text: |-
        import 'dart:convert';
        import 'dart:typed_data';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:encrypt/encrypt.dart' as encrypt;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // Confidential information
          var confidentialInfo = 'This is some confidential information';

          // Encrypt the confidential information
          final key = encrypt.Key.fromUtf8('my secure key');
          final iv = encrypt.IV.fromLength(16);
          final encrypter = encrypt.Encrypter(encrypt.AES(key));
          final encryptedConfidentialInfo = encrypter.encrypt(confidentialInfo, iv: iv);

          return shelf.Response.ok('You sent: ${request.url}, data: ${encryptedConfidentialInfo.base64}');
        }
    steps:
    - Identify the confidential information that needs to be encrypted.
    - Choose an encryption algorithm suitable for your needs. AES is a commonly used
      symmetric encryption algorithm.
    - Before storing or transmitting the confidential information, encrypt it using
      the chosen algorithm.
    - Ensure that the encryption key is securely stored and managed. It should not
      be hard-coded in the application.
    - When the confidential information needs to be used, decrypt it using the same
      encryption key.
    - Ensure that all instances of the confidential information in the code are replaced
      with the encrypted version.
  title: Non-encrypted confidential information
  vulnerability_id: '020'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and performant applications
  - Usage of Shelf for managing data persistence and querying in Node.js applications
  - Usage of Shelf.io for managing and organizing data in Node.js applications
  need: Secure transmission of data
  solution:
    insecure_code_example:
      description: "The above Dart code uses the Shelf package to create a simple\
        \ server that listens on `localhost` and port `8080`. The server has a single\
        \ handler, `_echoRequest`, which returns a `200 OK` response with the URL\
        \ of the request. \n\nHowever, this server is insecure as it does not use\
        \ any form of encryption. This means that any data transmitted between the\
        \ client and server is sent in plaintext and can be intercepted and read by\
        \ anyone who is able to capture the network traffic. This is a major security\
        \ vulnerability, especially if sensitive data such as usernames, passwords,\
        \ or personal information is being transmitted."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now uses the `HttpServer.bindSecure` method from the `dart:io` library to create a secure server. This method takes three arguments: the host, the port, and a `SecurityContext` object. The `SecurityContext` object is configured with the paths to the SSL certificate and private key files.

        The `useCertificateChain` method of the `SecurityContext` object is used to specify the path to the SSL certificate file, and the `usePrivateKey` method is used to specify the path to the private key file. These files are necessary for establishing a secure HTTPS connection.

        The `io.serveRequests` function is then used to start the server and handle incoming requests. This function takes two arguments: the server and the handler. The handler is the same as in the original code, and is responsible for processing incoming requests and generating responses.

        This updated code ensures that all data transmitted between the server and clients is encrypted using HTTPS, thereby fixing the original vulnerability. Please replace `'path/to/certificate.pem'` and `'path/to/private_key.pem'` with the actual paths to your SSL certificate and private key files.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          var server = HttpServer.bindSecure(
            'localhost',
            8080,
            SecurityContext()
              ..useCertificateChain('path/to/certificate.pem')
              ..usePrivateKey('path/to/private_key.pem'),
          );

          io.serveRequests(server, handler);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Import the 'shelf' package with SSL support to enable secure communication.
    - Generate or obtain a valid SSL certificate and private key. You can use self-signed
      certificates for testing, but for production, you should use a certificate issued
      by a trusted Certificate Authority.
    - Configure the server to use the SSL certificate and private key. This will enable
      the server to establish secure connections using HTTPS.
    - Ensure that all data transmission is done over the secure channel. This includes
      not only the main data being transmitted, but also any metadata or other auxiliary
      data.
    - Test the server to ensure that it is correctly encrypting data and that clients
      can successfully establish secure connections.
  title: Use of an insecure channel
  vulnerability_id: '022'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing data persistence and querying in Node.js applications
  need: Secure handling of temporary files
  solution:
    insecure_code_example:
      description: "The above code is an example of a vulnerability in a Dart backend\
        \ application using the Shelf framework. The vulnerability lies in the insecure\
        \ handling of temporary files that store sensitive information. \n\nIn the\
        \ `handleRequest` function, a temporary file `temp.txt` is created and sensitive\
        \ information is written to it. This information is stored in plain text,\
        \ making it easily accessible by anyone who can access the file system. \n\
        \nMoreover, even though the file is deleted after processing, there is a time\
        \ frame during which the sensitive information is exposed. If an attacker\
        \ gains access to the system during this period, they can read the sensitive\
        \ information. \n\nFurthermore, if the application crashes or is forcefully\
        \ stopped before the `deleteSync` method is called, the temporary file will\
        \ not be deleted, leaving the sensitive information exposed indefinitely.\n\
        \nThis is a common vulnerability in applications that use temporary files\
        \ to store sensitive data. It can lead to information disclosure, which could\
        \ be exploited by an attacker to gain unauthorized access to sensitive data."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:io';

        shelf.Response handleRequest(shelf.Request request) {
          var tempFile = File('temp.txt');
          tempFile.writeAsStringSync('Sensitive Information');
          // other processing...
          tempFile.deleteSync();
          return shelf.Response.ok('Request Processed');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now uses an in-memory data structure to store the sensitive information instead of a temporary file. This reduces the risk of unauthorized access to the sensitive information.

        If it's necessary to write the sensitive information to a file, the information is now hashed using the SHA-256 algorithm before being written to the file. This ensures that even if an unauthorized user gains access to the file, they will not be able to understand the sensitive information because it is encrypted.

        After the sensitive information is no longer needed, the temporary file is securely deleted. This ensures that the sensitive information is not left lying around where it could be accessed by an unauthorized user.

        Finally, ensure that your deployment process is configured to exclude these temporary files from being deployed to the production environment. This will prevent any sensitive information from accidentally being exposed in the production environment.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:io';
        import 'dart:convert';
        import 'package:crypto/crypto.dart';

        shelf.Response handleRequest(shelf.Request request) {
          // Use in-memory data structure to store sensitive information
          var sensitiveInfo = 'Sensitive Information';
          var bytes = utf8.encode(sensitiveInfo); // data being hashed

          var digest = sha256.convert(bytes); // Hashing sensitive information

          // If it's necessary to write to a file, encrypt the data
          var tempFile = File('temp.txt');
          tempFile.writeAsStringSync(digest.toString());

          // other processing...

          // Securely delete the file after use
          tempFile.deleteSync();
          return shelf.Response.ok('Request Processed');
        }
    steps:
    - Avoid storing sensitive information in temporary files. If it's necessary, ensure
      the files are securely deleted after use.
    - Use secure methods to create temporary files. Ensure that the file is created
      with restrictive permissions to prevent unauthorized access.
    - Consider using in-memory data structures to store temporary data instead of
      using disk-based temporary files.
    - If the sensitive information must be written to a file, consider encrypting
      the data before writing it to the file.
    - Ensure that the temporary files are not deployed to the production environment.
      Configure your deployment process to exclude these files.
  title: Insecure temporary files
  vulnerability_id: '028'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Enforce strong identity verification for password changes
  solution:
    insecure_code_example:
      description: |-
        The above code is a simple representation of a Dart backend using the Shelf framework. A list of users is created for demonstration purposes. The `handleRequest` function is vulnerable to a password change without identity check.

        In the `handleRequest` function, the `updatedPassword` and `username` are extracted from the request parameters. The function then finds the user with the provided username and updates the password directly without checking the old password or any other form of identity verification.

        This means that anyone who knows a username can change the password of the corresponding user without needing to provide the old password or any other form of identity verification. This is a security vulnerability as it can lead to unauthorized access to user accounts.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          String username;
          String password;

          User({required this.username, required this.password});
        }

        List<User> users = [
          User(username: 'test', password: 'test'),
        ];

        shelf.Response handleRequest(shelf.Request request) {
          var updatedPassword = request.url.queryParameters['newPassword'];
          var username = request.url.queryParameters['username'];

          var user = users.firstWhere((user) => user.username == username);
          user.password = updatedPassword;

          return shelf.Response.ok('Password Updated Successfully');
        }
    language: dart
    secure_code_example:
      description: |-
        The code above fixes the vulnerability by adding an authentication middleware to the server that checks if the user is authenticated before processing the request. This is done in the `checkAuthentication` function, which is added to the server pipeline before the `handleRequest` function.

        In the `checkAuthentication` function, the username and old password are extracted from the request parameters. The function then checks if there is a user with the given username and if the old password matches the user's current password. If the old password does not match, the function returns a forbidden response, preventing the request from being processed further.

        In the `handleRequest` function, the new password is extracted from the request parameters and the user's password is updated. This function is only called if the `checkAuthentication` function does not return a forbidden response, ensuring that the user's password is only updated if the old password is correct.

        Finally, in the `main` function, the `checkAuthentication` middleware is added to the server pipeline before the `handleRequest` function using the `addMiddleware` method. This ensures that the authentication check is performed before the request is processed.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          String username;
          String password;

          User({required this.username, required this.password});
        }

        List<User> users = [
          User(username: 'test', password: 'test'),
        ];

        shelf.Middleware checkAuthentication() {
          return (shelf.Handler innerHandler) {
            return (shelf.Request request) async {
              var username = request.url.queryParameters['username'];
              var oldPassword = request.url.queryParameters['oldPassword'];

              var user = users.firstWhere((user) => user.username == username);

              if (user.password != oldPassword) {
                return shelf.Response.forbidden('Invalid old password');
              }

              return innerHandler(request);
            };
          };
        }

        shelf.Response handleRequest(shelf.Request request) {
          var updatedPassword = request.url.queryParameters['newPassword'];
          var username = request.url.queryParameters['username'];

          var user = users.firstWhere((user) => user.username == username);
          user.password = updatedPassword;

          return shelf.Response.ok('Password Updated Successfully');
        }

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(checkAuthentication())
              .addHandler(handleRequest);

          shelf.serve(handler, 'localhost', 8080);
        }
    steps:
    - Add an authentication middleware to the server that checks if the user is authenticated
      before processing the request.
    - In the handleRequest function, before changing the password, verify the identity
      of the user. This could be done by asking for the old password or by using a
      two-factor authentication method.
    - If the identity verification is successful, then proceed with the password change.
      If not, return an error response.
  title: Password change without identity check
  vulnerability_id: '033'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of dart:math for mathematical calculations and operations
  need: Secure generation of random numbers
  solution:
    insecure_code_example:
      description: |-
        In the code above, we're using Dart's built-in `Random` class to generate a random number. The `nextInt` function is used to generate a random integer from 0 (inclusive) to a specified upper limit (exclusive). In this case, the upper limit is 100, so the function will generate a random number between 0 and 99.

        However, Dart's `Random` class and its `nextInt` function are known to be insecure for generating random numbers in cryptographic contexts. The random numbers generated by `Random` and `nextInt` are not truly random. They are determined by a pseudo-random number generator (PRNG), which uses an algorithm to produce a sequence of numbers that only approximate true randomness.

        The problem with PRNGs is that if an attacker can predict the algorithm used by the PRNG, they can predict the sequence of numbers it will generate. In the context of a backend application, this could allow an attacker to guess sensitive information such as session IDs, tokens, or other secret keys that are generated using this insecure random number generator.

        Therefore, it's important to use a secure method for generating random numbers in a cryptographic context. In Dart, you can use the `Random.secure` constructor to create a random number generator that produces cryptographically secure random numbers.
      text: |-
        import 'dart:math';

        void main() {
          var rng = new Random();
          print(rng.nextInt(100)); // generates a random number between 0 and 99
        }
    language: dart
    secure_code_example:
      description: |-
        The above code uses Dart's `Random.secure()` method to generate a secure random number. This method uses a source of cryptographic randomness, which makes it much harder for an attacker to predict the sequence of numbers.

        The `Random.secure().nextBytes(4)` generates a list of 4 random bytes. The `ByteData.view(randomBytes.buffer).getUint32(0)` then converts these bytes into a 32-bit unsigned integer, which is our secure random number.

        This secure random number generator is a significant improvement over the insecure `Random()` generator. It is much more resistant to attack, as it is much harder to predict the sequence of numbers it will generate.

        Remember, the security of your random number generator is crucial in many contexts, such as generating random passwords, cryptographic keys, or in any other situation where predictability could be exploited by an attacker. Always use a secure random number generator like the one shown above in these situations.
      text: |-
        import 'dart:math';
        import 'dart:typed_data';
        import 'dart:convert';
        import 'package:crypto/crypto.dart';

        void main() {
          var secureRandom = generateSecureRandom();
          print(secureRandom); // generates a secure random number
        }

        int generateSecureRandom() {
          var randomBytes = Random.secure().nextBytes(4);
          var value = ByteData.view(randomBytes.buffer).getUint32(0);
          return value;
        }
    steps:
    - Replace the insecure random number generator with a secure one. Dart provides
      a secure random number generator in the 'dart:crypto' library.
    - Use the secure random number generator to generate random numbers. This generator
      uses a source of cryptographic randomness, which makes it much harder for an
      attacker to predict the sequence of numbers.
    - Ensure that the range of the random numbers is sufficient for your needs. A
      larger range makes it harder for an attacker to guess the number.
    - Consider adding additional entropy to the random number generation process.
      This could be done by incorporating user input or other unpredictable data into
      the generation process.
  title: Insecure generation of random numbers
  vulnerability_id: '034'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure encryption of ViewState
  solution:
    insecure_code_example:
      description: |-
        In the above code, we have the `AppState` class, which holds the state of the application - in this case, a `userName`. This is a simple representation of a stateful object in a backend application.

        In the `handle` function, we create an instance of `AppState`, set its `userName` property, and then convert it to a string to be sent in a response. This string represents the ViewState of the application.

        The vulnerability here is that the ViewState is not encrypted. This means that anyone who intercepts the response could potentially read and manipulate the state of the application. This could lead to unauthorized access or other security breaches.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class AppState {
          String userName;
        }

        void handle(shelf.Request request) {
          var appState = AppState();
          appState.userName = 'John Doe';
          var viewState = appState.toString();
          var response = shelf.Response.ok(viewState);
        }
    language: dart
    secure_code_example:
      description: "The above code fixes the vulnerability by encrypting the ViewState\
        \ before it is stored. \n\nFirstly, we import the `encrypt` package which\
        \ provides encryption functionality. \n\nNext, we create an encryption key\
        \ and an initialization vector (IV) which will be used to encrypt the ViewState.\
        \ The key is generated from a length of 32 and the IV from a length of 16.\
        \ \n\nWe then create an encrypter using the AES algorithm provided by the\
        \ `encrypt` package and the key we generated. \n\nBefore storing the ViewState,\
        \ we encrypt it using the encrypter and the IV. The `encrypt` method of the\
        \ encrypter returns an `Encrypted` object which we convert to a base64 string\
        \ before storing it. \n\nWhen the ViewState is retrieved, it will need to\
        \ be decrypted using the same key and IV. \n\nPlease note that the encryption\
        \ key and IV should be stored securely and not exposed to potential attackers.\
        \ In a real-world application, you would not generate a new key and IV every\
        \ time, but rather use a securely stored key and IV."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:encrypt/encrypt.dart' as encrypt;

        class AppState {
          String userName;
        }

        void handle(shelf.Request request) {
          var appState = AppState();
          appState.userName = 'John Doe';

          // Create an encryption key
          final key = encrypt.Key.fromLength(32);
          final iv = encrypt.IV.fromLength(16);

          // Create an encrypter
          final encrypter = encrypt.Encrypter(encrypt.AES(key));

          // Encrypt the ViewState
          final encryptedViewState = encrypter.encrypt(appState.toString(), iv: iv);

          var response = shelf.Response.ok(encryptedViewState.base64);
        }
    steps:
    - Import a library that provides encryption functionality.
    - Create an encryption key that will be used to encrypt the ViewState.
    - Before storing the ViewState, encrypt it using the encryption key.
    - When retrieving the ViewState, decrypt it using the same encryption key.
    - Ensure that the encryption key is stored securely and is not exposed to potential
      attackers.
  title: ViewState not encrypted
  vulnerability_id: '036'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of proper authorization control for web services
  solution:
    insecure_code_example:
      description: "This Dart code is an example of a server that uses the Shelf framework.\
        \ The server listens on `localhost:8080` and logs all incoming requests. \n\
        \nThe vulnerability lies in the `handleRequest` function. This function is\
        \ supposed to handle all incoming requests, but it lacks any form of authorization\
        \ control. Any request that comes in, regardless of its origin or intent,\
        \ is processed and receives an OK response. \n\nThis means that anyone, including\
        \ potential attackers, can send requests to this server and have them processed\
        \ without any checks. This could lead to unauthorized access to sensitive\
        \ data or malicious actions being performed on the server. \n\nThe server\
        \ should have an authorization mechanism in place to verify the identity of\
        \ the request sender and determine if they have the necessary permissions\
        \ to perform the requested action. Without this, the server is open to a wide\
        \ range of potential security threats."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          // missing authorization control
          return shelf.Response.ok('Request processed successfully');
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(handleRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    language: dart
    secure_code_example:
      description: |-
        The code above introduces an authorization middleware in the pipeline that checks for valid tokens in the request headers. The `authMiddleware` function checks if the 'authorization' header of the request is equal to 'valid_token'. If the token is not valid, it returns a 403 Forbidden response, rejecting the request.

        This middleware is added to the pipeline before the request handler using the `addMiddleware` method. This ensures that the authorization check is performed before any request is processed.

        Please note that this is a simple implementation and in a real-world scenario, you would likely need to implement a more sophisticated authorization mechanism. For example, you might need to check the token against a list of valid tokens stored in a database, or use a library that provides built-in support for authorization.

        Remember to regularly update and patch any libraries or frameworks you use to protect against known vulnerabilities. Also, make sure to thoroughly test your authorization control mechanism to ensure it cannot be bypassed.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response authMiddleware(shelf.Request request) {
          final hasValidToken = request.headers['authorization'] == 'valid_token';
          if (!hasValidToken) {
            return shelf.Response.forbidden('Unauthorized');
          }
          return null;
        }

        shelf.Response handleRequest(shelf.Request request) {
          return shelf.Response.ok('Request processed successfully');
        }

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(authMiddleware)
              .addHandler(handleRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    steps:
    - Introduce an authorization middleware in the pipeline that checks for valid
      credentials or tokens in the request headers.
    - The middleware should reject requests that do not contain valid credentials
      or tokens with an appropriate HTTP status code such as 401 Unauthorized.
    - Ensure that the authorization middleware is added before the request handler
      in the pipeline so that it is executed first.
    - Consider using a library or framework that provides built-in support for authorization
      to avoid potential implementation errors.
    - Regularly update and patch the authorization library or framework to protect
      against known vulnerabilities.
    - Test the authorization control mechanism thoroughly to ensure it cannot be bypassed.
  title: Improper authorization control for web services
  vulnerability_id: '039'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure generation and handling of cookies
  solution:
    insecure_code_example:
      description: "The above code snippet represents a simple server-side Dart application\
        \ using the `shelf` framework. This function `handleRequest` processes incoming\
        \ requests and returns a response. \n\nThe vulnerability lies in the way the\
        \ `Set-Cookie` HTTP header is being set. It sets a `sessionId` cookie without\
        \ any security attributes, such as `Secure` or `HttpOnly`.\n\n- The `Secure`\
        \ attribute ensures that the cookie is sent only over HTTPS connections, which\
        \ protects it from being intercepted during transmission.\n- The `HttpOnly`\
        \ attribute ensures that the cookie cannot be accessed through client-side\
        \ scripts, which protects it from cross-site scripting (XSS) attacks.\n\n\
        In the current state, the cookie can be sent over unsecured HTTP connections\
        \ and can be accessed via client-side scripts, making it vulnerable to interception\
        \ and unauthorized access."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var response = shelf.Response.ok('Hello, World!');
          return shelf.changeMiddleware(
            response.change(headers: {
              'Set-Cookie': 'sessionId=123456; Path=/;'
            }),
          );
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now sets the 'Secure', 'HttpOnly', and 'SameSite' attributes for the 'Set-Cookie' HTTP response header.

        - The 'Secure' attribute instructs the browser to only send the cookie over an encrypted HTTPS connection. This prevents the cookie from being sent in plain text, which could be intercepted and read by unauthorized users.

        - The 'HttpOnly' attribute prevents client-side scripts from accessing the cookie. This mitigates the risk of cross-site scripting (XSS) attacks, where an attacker could use a script to read the cookie and gain unauthorized access to the session.

        - The 'SameSite' attribute is set to 'Strict', which means the cookie will only be sent in a first-party context (i.e., if the URL in the browser's address bar matches the domain of the cookie). This helps to mitigate the risk of cross-site request forgery (CSRF) attacks, where an attacker could trick a user into performing an action on a website where they are authenticated.

        By setting these attributes, the system ensures that sensitive cookies are not disclosed to unauthorized users or sent over insecure connections.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var response = shelf.Response.ok('Hello, World!');
          return shelf.changeMiddleware(
            response.change(headers: {
              'Set-Cookie': 'sessionId=123456; Path=/; Secure; HttpOnly; SameSite=Strict'
            }),
          );
        }
    steps:
    - Use the 'Secure' attribute in the 'Set-Cookie' HTTP response header. This attribute
      instructs the browser to only send the cookie over an encrypted HTTPS connection.
    - Use the 'HttpOnly' attribute in the 'Set-Cookie' HTTP response header. This
      attribute prevents client-side scripts from accessing the cookie, mitigating
      the risk of cross-site scripting (XSS) attacks.
    - Ensure that the 'SameSite' attribute is set to 'Strict' or 'Lax' in the 'Set-Cookie'
      HTTP response header. This attribute helps to mitigate the risk of cross-site
      request forgery (CSRF) attacks.
  title: Insecurely generated cookies
  vulnerability_id: '042'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing data storage and retrieval
  - Usage of shelf_io for managing and interacting with data storage in Node.js
  need: Implementation of secure and properly configured Content-Security-Policy headers
  solution:
    insecure_code_example:
      description: |-
        In this code, the server responds to each request with a simple message. However, it does not set any HTTP headers, including the Content-Security-Policy header.

        The Content-Security-Policy HTTP header is a powerful tool that helps protect against various types of attacks, including Cross Site Scripting (XSS) and data injection attacks. It allows you to specify the domains that the browser should consider to be valid sources of executable scripts.

        Without this header, or with it set incorrectly, your application could be vulnerable to these types of attacks.

        In the above code, there is no middleware or handler that sets this header. This means that every response from this server will not include the Content-Security-Policy header, leaving the application vulnerable.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a middleware function `_addContentSecurityPolicyHeader` that adds the `Content-Security-Policy` header to every response. This header is set with a value of `"default-src 'self';"`, which means that all content must come from the same origin as the document itself. This is a common policy that helps prevent Cross-Site Scripting (XSS) attacks by restricting where content can be loaded from.

        The middleware function is added to the application pipeline using the `addMiddleware` method. This ensures that the `Content-Security-Policy` header is added to every response that the server sends.

        The middleware function works by wrapping the handler function. When a request is received, it first passes the request to the handler function. Once the handler function has processed the request and generated a response, the middleware function modifies this response to add the `Content-Security-Policy` header before it is sent back to the client.

        This solution ensures that the `Content-Security-Policy` header is always set, regardless of the specific route that is handling the request. This is important because it ensures that the security policy is consistently applied across all parts of the application.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(_addContentSecurityPolicyHeader)
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        shelf.Middleware _addContentSecurityPolicyHeader() {
          return (shelf.Handler handler) {
            return (shelf.Request request) {
              return Future.sync(() => handler(request)).then((shelf.Response response) {
                return response.change(headers: {
                  'Content-Security-Policy': "default-src 'self';"
                });
              });
            };
          };
        }
    steps:
    - First, you need to create a middleware function that will add the Content-Security-Policy
      header to every response.
    - In this middleware function, set the Content-Security-Policy header with a value
      that defines the allowed sources of content for your application. Be sure to
      restrict the sources to only trusted ones to prevent Cross-Site Scripting (XSS)
      attacks.
    - Add this middleware to your application pipeline using the addMiddleware method.
      This will ensure that the Content-Security-Policy header is added to every response
      that your server sends.
    - Finally, test your application to ensure that the Content-Security-Policy header
      is properly set and that it doesn't break any functionality of your application.
  title: Insecure or unset HTTP headers - Content-Security-Policy
  vulnerability_id: '043'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.12.0 for developing cross-platform applications
  - Usage of cipher for encryption and decryption operations
  need: Secure encryption algorithm implementation
  solution:
    insecure_code_example:
      description: "The above Dart code snippet shows an example of an insecure encryption\
        \ algorithm usage. The application is a simple server built with the `shelf`\
        \ framework, and it uses the `cipher` package to encrypt sensitive information.\n\
        \nThe server listens on `localhost:8080` and, upon receiving a request, it\
        \ encrypts a string \"Sensitive information\" using the AES encryption algorithm\
        \ in ECB mode with a static key \"insecure\". \n\nThe problem here is twofold:\n\
        \n1. **Static encryption key:** The key used for encryption is a static string\
        \ \"insecure\". This is a poor practice as anyone who has access to the source\
        \ code or can reverse engineer the application can easily decrypt any encrypted\
        \ data as the key is not only static but also very weak.\n\n2. **ECB mode:**\
        \ ECB (Electronic Codebook) mode is an insecure method of encryption. It does\
        \ not use any Initialization Vector (IV) and encrypts each block of plaintext\
        \ independently. This means that identical plaintext blocks are encrypted\
        \ into identical ciphertext blocks, making it vulnerable to various attacks\
        \ as patterns in the plaintext are preserved in the encrypted data.\n\nTo\
        \ mitigate this vulnerability, it is advised to use a secure encryption algorithm\
        \ with a strong key, and the key should be stored securely, not hardcoded\
        \ into the application. Furthermore, a secure mode of operation, such as CBC\
        \ (Cipher Block Chaining) or GCM (Galois/Counter Mode), should be used instead\
        \ of ECB."
      text: |-
        import 'dart:convert';
        import 'dart:io';
        import 'dart:typed_data';
        import 'package:cipher/cipher.dart';
        import 'package:cipher/impl/base.dart';
        import 'package:shelf/shelf.dart';

        void main() {
          final server = HttpServer.bind(InternetAddress.loopbackIPv4, 8080);
          server.listen((HttpRequest request) async {
            var key = utf8.encode("insecure");
            var cipher = PaddedBlockCipherImpl(
                PKCS7Padding(), ECBMode(BlockCipher("AES")));

            cipher.init(true, PaddedBlockCipherParameters(key, null));

            var data = utf8.encode("Sensitive information");
            var encData = cipher.process(data);

            var response = Response.ok(encData.toString());
            await request.response.addStream(response.read());
          });
        }
    language: dart
    secure_code_example:
      description: "The updated code now uses a secure encryption algorithm and mode\
        \ of operation. The AES algorithm is used with CBC mode, which is more secure\
        \ than the previously used ECB mode. \n\nThe encryption key is no longer hardcoded\
        \ in the code. Instead, a key derivation function (PBKDF2) is used to generate\
        \ the key from a password and a salt. The salt is a random string that is\
        \ used to ensure that the same password will result in different keys. The\
        \ PBKDF2 function also takes a parameter for the number of iterations, which\
        \ can be increased to make the key derivation process more computationally\
        \ intensive and thus more secure against brute-force attacks.\n\nAn initialization\
        \ vector (IV) is used for each encryption operation. The IV is a random string\
        \ that is used to ensure that the same data will result in different encrypted\
        \ output each time it is encrypted. This makes it more difficult for an attacker\
        \ to find patterns in the encrypted data.\n\nFinally, the encrypted data is\
        \ encoded using base64 encoding before it is sent in the response. This ensures\
        \ that the data remains intact without any modification during transmission."
      text: |-
        import 'dart:convert';
        import 'dart:io';
        import 'dart:typed_data';
        import 'package:cipher/cipher.dart';
        import 'package:cipher/impl/base.dart';
        import 'package:shelf/shelf.dart';
        import 'package:pointycastle/api.dart';
        import 'package:pointycastle/block/aes_fast.dart';
        import 'package:pointycastle/block/modes/cbc.dart';
        import 'package:pointycastle/paddings/pkcs7.dart';
        import 'package:pointycastle/key_derivators/pbkdf2.dart';
        import 'package:pointycastle/random/fortuna_random.dart';

        void main() {
          final server = HttpServer.bind(InternetAddress.loopbackIPv4, 8080);
          server.listen((HttpRequest request) async {
            var password = "SecurePassword";
            var salt = createUint8ListFromString("Salt");
            var pkcs = new KeyDerivator("SHA-1/HMAC/PBKDF2");
            var params = new Pbkdf2Parameters(salt, 1000, 16);
            pkcs.init(params);
            var key = pkcs.process(createUint8ListFromString(password));

            var iv = createUint8ListFromString("InitializationVector");
            var aes = new AESFastEngine();
            var cbc = new CBCBlockCipher(aes);
            var cipher = new PaddedBlockCipherImpl(new PKCS7Padding(), cbc);
            cipher.init(true, new ParametersWithIV<KeyParameter>(new KeyParameter(key), iv));

            var data = utf8.encode("Sensitive information");
            var encData = cipher.process(data);

            var response = Response.ok(base64Encode(encData));
            await request.response.addStream(response.read());
          });
        }

        Uint8List createUint8ListFromString(String value) {
          return new Uint8List.fromList(utf8.encode(value));
        }
    steps:
    - Replace the insecure encryption algorithm with a secure one. AES is a secure
      algorithm but the mode of operation (ECB) is insecure. Use a secure mode like
      CBC or GCM.
    - Use a secure method to generate the encryption key instead of hardcoding it
      in the code. You can use a key derivation function like PBKDF2, bcrypt or scrypt.
    - Use a random initialization vector (IV) for each encryption operation and include
      it with the encrypted data. The IV doesn't need to be secret, but it should
      be unpredictable and unique for each encryption operation.
    - Ensure that the encrypted data is properly encoded before sending it in the
      response. You can use base64 encoding to ensure that the data remains intact
      without any modification during transmission.
  title: Insecure encryption algorithm
  vulnerability_id: '052'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing cross-platform applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_io for managing and interacting with data storage in an organized
    manner
  need: Implementation of robust brute force protection mechanisms
  solution:
    insecure_code_example:
      description: |-
        The above Dart code uses the Shelf framework to create a simple backend server. The server listens to incoming requests on localhost at port 8080. The server expects the client to send 'username' and 'password' in the request headers.

        The `_echoRequest` function is the request handler. It retrieves the 'username' and 'password' from the request headers and checks if they match the hardcoded credentials ('admin' and 'password'). If they match, it responds with a 200 OK status and a message 'Authenticated'. If they don't match, it responds with a 403 Forbidden status and a message 'Not authenticated'.

        The vulnerability in this code is that it doesn't have any protection against brute force attacks. An attacker could potentially send thousands of requests with different combinations of 'username' and 'password' until they find the correct credentials. This is a significant security risk as it could lead to unauthorized access to the system.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var username = request.headers['username'];
          var password = request.headers['password'];

          if (username == 'admin' && password == 'password') {
            return shelf.Response.ok('Authenticated');
          } else {
            return shelf.Response.forbidden('Not authenticated');
          }
        }
    language: dart
    secure_code_example:
      description: "The updated code includes several measures to protect against\
        \ brute force attacks:\n\n- **Limit on failed login attempts**: The `failedAttempts`\
        \ map stores the number of failed login attempts for each user. If a user\
        \ fails to log in 5 times, their username is added to the `lockoutEndTimes`\
        \ map, which stores the time when the user's lockout period ends. The user\
        \ cannot log in again until after this time.\n\n- **Increasing delay after\
        \ failed attempts**: The lockout period increases each time the user fails\
        \ to log in. This makes brute force attacks more time-consuming and less feasible.\n\
        \n- **Password hashing**: The user's password is hashed using the SHA-256\
        \ algorithm before it is compared with the stored password hash. This ensures\
        \ that even if an attacker manages to obtain the password hash, they cannot\
        \ reverse-engineer the original password.\n\nPlease note that this code does\
        \ not include CAPTCHA or multi-factor authentication, as these features are\
        \ not typically implemented at the level of a single request handler. They\
        \ would require additional infrastructure, such as a database to store CAPTCHA\
        \ solutions and a way to send authentication codes to users. \n\nAlso, the\
        \ code does not store IP addresses of users who have multiple failed login\
        \ attempts. This would require access to a database or similar persistent\
        \ storage, which is not shown in the code. However, you could easily add this\
        \ feature by creating another map to store IP addresses and their associated\
        \ failed attempt counts."
      text: |-
        import 'dart:async';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:crypto/crypto.dart';
        import 'dart:convert'; // for the utf8.encode method

        // Store failed attempts
        Map<String, int> failedAttempts = {};
        // Store lockout end times
        Map<String, DateTime> lockoutEndTimes = {};

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var username = request.headers['username'];
          var password = request.headers['password'];

          // Check if user is locked out
          if (lockoutEndTimes.containsKey(username) && DateTime.now().isBefore(lockoutEndTimes[username])) {
            return shelf.Response.forbidden('Too many failed attempts. Try again later.');
          }

          // Hash the password
          var bytes = utf8.encode(password);
          var digest = sha256.convert(bytes);

          if (username == 'admin' && digest.toString() == 'hashed_password') {
            // Reset failed attempts and lockout end time
            failedAttempts.remove(username);
            lockoutEndTimes.remove(username);
            return shelf.Response.ok('Authenticated');
          } else {
            // Increment failed attempts
            failedAttempts[username] = (failedAttempts[username] ?? 0) + 1;
            // If failed attempts exceed limit, lock account
            if (failedAttempts[username] >= 5) {
              lockoutEndTimes[username] = DateTime.now().add(Duration(minutes: 15));
            }
            return shelf.Response.forbidden('Not authenticated');
          }
        }
    steps:
    - Implement a limit on the number of failed login attempts. After a certain number
      of failed attempts, the account should be temporarily locked.
    - Introduce a delay after each failed login attempt. This delay should increase
      exponentially with each subsequent failed attempt, making brute force attacks
      time-consuming and less feasible.
    - Use CAPTCHA to distinguish between human users and bots. This can prevent automated
      scripts from executing brute force attacks.
    - Implement multi-factor authentication. This adds an additional layer of security,
      making it more difficult for an attacker to gain access even if they guess the
      correct password.
    - Store IP addresses of users who have multiple failed login attempts and block
      them if necessary.
    - Encrypt the password using a strong hashing algorithm before comparing it with
      the stored password hash.
  title: Lack of protection against brute force attacks
  vulnerability_id: '053'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data storage and retrieval
  need: Protection of sensitive information in log files
  solution:
    insecure_code_example:
      description: "The above Dart code is an example of a backend application using\
        \ the Shelf framework. This application has a middleware that logs all requests\
        \ and a handler that echoes these requests.\n\nThe vulnerability lies in the\
        \ `_echoRequest` function. This function is storing sensitive information\
        \ such as username, password, bank account number, and file path in a map.\
        \ This sensitive information is then printed out to the console using the\
        \ `print` function. \n\nThe problem here is that all this sensitive information\
        \ is being stored in the logs. Anyone who has access to these logs can retrieve\
        \ this sensitive information. This is a major security vulnerability as it\
        \ exposes sensitive user data."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var sensitiveInfo = {
            'username': 'user123',
            'password': 'pass123',
            'bankAccount': '1234567890',
            'filePath': '/home/user/secret_file.txt'
          };

          print('Sensitive Information: $sensitiveInfo');

          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code had a vulnerability where it was logging sensitive information. This is a security risk as it exposes sensitive user data which can be exploited by malicious actors.

        The fixed code removes the print statement that was logging the sensitive information. This prevents the sensitive data from being exposed in the logs.

        However, it's important to note that simply removing the print statement is not enough to fully secure your application. Here are some additional steps you should take:

        - If you need to log for debugging purposes, make sure to sanitize or anonymize the sensitive data before logging it. You can replace the actual data with placeholders or use a hashing function to obscure the data.

        - Consider using a logging library or service that provides built-in features for handling sensitive data. These tools can automatically redact sensitive information or allow you to configure what gets logged.

        - Implement a proper error handling mechanism. Instead of logging the entire error object which might contain sensitive data, log only the necessary information.

        - Regularly review and audit your logs to ensure that no sensitive data is being stored. This should be part of your security best practices.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var sensitiveInfo = {
            'username': 'user123',
            'password': 'pass123',
            'bankAccount': '1234567890',
            'filePath': '/home/user/secret_file.txt'
          };

          // Removed the print statement that logs sensitive information
          // print('Sensitive Information: $sensitiveInfo');

          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Remove the print statement that logs sensitive information. Never log sensitive
      data such as usernames, passwords, bank account numbers, or file paths.
    - If you need to log for debugging purposes, make sure to sanitize or anonymize
      the sensitive data before logging it. You can replace the actual data with placeholders
      or use a hashing function to obscure the data.
    - Consider using a logging library or service that provides built-in features
      for handling sensitive data. These tools can automatically redact sensitive
      information or allow you to configure what gets logged.
    - Implement a proper error handling mechanism. Instead of logging the entire error
      object which might contain sensitive data, log only the necessary information.
    - Regularly review and audit your logs to ensure that no sensitive data is being
      stored. This should be part of your security best practices.
  title: Sensitive information stored in logs
  vulnerability_id: '059'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing input/output operations in a Shelf application
  need: Secure service configuration - Proper host verification
  solution:
    insecure_code_example:
      description: "In the above code, the server is set up to listen for incoming\
        \ connections on all network interfaces (0.0.0.0) and on port 8080. This is\
        \ done using the `io.serve(handler, '0.0.0.0', 8080)` line. \n\nThe problem\
        \ with this configuration is that it does not restrict incoming connections\
        \ from unknown external hosts. This means that any device, regardless of its\
        \ location or network, can send a request to this server as long as it knows\
        \ the server's IP address and port number. \n\nThe server is also set to respond\
        \ to all requests with an OK response and the requested URL, regardless of\
        \ the source of the request. This is done in the `_echoRequest` function.\
        \ \n\nThis configuration is insecure because it exposes the server to potential\
        \ attacks from unknown external hosts. An attacker could potentially use this\
        \ open connection to send malicious requests to the server, or to gain unauthorized\
        \ access to the server and its data. \n\nTo fix this vulnerability, the server\
        \ should be configured to only accept connections from known and trusted hosts.\
        \ This can be done by implementing a host verification mechanism that checks\
        \ the source of each incoming request before processing it."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, '0.0.0.0', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable because it was configured to accept connections from any IP address. This is a security risk because it allows any external host to connect to the service, potentially leading to unauthorized access or attacks.

        The fixed code restricts the service to only accept connections from 'localhost' (127.0.0.1), which is the IP address of the local machine. This means that only processes running on the same machine can connect to the service. This is a common configuration for services that are not intended to be accessible from the internet.

        Please note that this fix might not be suitable for all use cases. If your service needs to be accessible from other machines, you should implement additional security measures. These could include:

        - An authentication mechanism to verify the identity of the incoming connections. This could be a username/password, API key, or a certificate.
        - A firewall or a similar security measure to block unwanted traffic.
        - Regular updates and patches to your system and libraries to protect against known vulnerabilities.
        - Monitoring your system for suspicious activity. This could be done through logging and analyzing the logs for patterns that indicate an attack.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Restrict the IP addresses that can connect to your service. Instead of '0.0.0.0',
      which allows all IP addresses, specify the IP addresses that you trust.
    - Implement an authentication mechanism to verify the identity of the incoming
      connections. This could be a username/password, API key, or a certificate.
    - Use a firewall or a similar security measure to block unwanted traffic.
    - Regularly update and patch your system and libraries to protect against known
      vulnerabilities.
    - Monitor your system for suspicious activity. This could be done through logging
      and analyzing the logs for patterns that indicate an attack.
  title: Insecure service configuration - Host verification
  vulnerability_id: '060'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure logging mechanism
  solution:
    insecure_code_example:
      description: |-
        The above code represents a backend application written in Dart using the Shelf framework. This application is serving requests on `localhost` on port `8080`.

        The application logs every request it receives. It logs the request method, URL, and headers. This is done in the `_echoRequest` method. This method is called for every request the application receives.

        In addition, the application also uses console functions: `console.log()`, `console.info()`, and `console.warning()`. These functions are used to log messages, information, and warnings respectively.

        The usage of these console functions in production environments can lead to information leakages. This is because they can reveal sensitive information like the methods being used, the URLs being accessed, and the headers being sent. This information can be used by an attacker to understand the application's logic, the technologies being used, and to find potential vulnerabilities.

        Moreover, the usage of these console functions can also reveal the application's internal state. This can be used by an attacker to understand the application's behavior and to predict its future behavior.

        Therefore, the usage of console functions in production environments is a potential security vulnerability and should be avoided.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          print('Received request: ${request.method}');
          print('Request url: ${request.url}');
          print('Request headers: ${request.headers}');

          console.log('This is a console log message');
          console.info('This is a console info message');
          console.warning('This is a console warning message');

          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code removes the usage of `console.log`, `console.info`, and `console.warning` functions. These functions are typically used for debugging and should not be present in production code as they may lead to information leakages and reveal vulnerable methods, technologies, or logic.

        If you need to log information, consider using a logging library that can be configured to log only certain levels of information in different environments. For example, you might configure the logger to log all messages in a development environment, but only errors in a production environment.

        Ensure that any sensitive information, such as user credentials or personal data, is never logged, even in a development environment.

        Consider implementing a centralized logging system that can securely store and manage logs. This can help prevent information leakage and provide a useful tool for monitoring and debugging.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          print('Received request: ${request.method}');
          print('Request url: ${request.url}');
          print('Request headers: ${request.headers}');

          // console.log('This is a console log message');
          // console.info('This is a console info message');
          // console.warning('This is a console warning message');

          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Remove or comment out all console.log, console.info, and console.warning statements
      from the production code. These statements are typically used for debugging
      and should not be present in production code.
    - If you need to log information, consider using a logging library that can be
      configured to log only certain levels of information in different environments.
      For example, you might configure the logger to log all messages in a development
      environment, but only errors in a production environment.
    - Ensure that any sensitive information, such as user credentials or personal
      data, is never logged, even in a development environment.
    - Consider implementing a centralized logging system that can securely store and
      manage logs. This can help prevent information leakage and provide a useful
      tool for monitoring and debugging.
  title: Technical information leak - Console functions
  vulnerability_id: '066'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Efficient resource allocation and management
  solution:
    insecure_code_example:
      description: |-
        The code above is an example of a function in a backend application that uses the Shelf framework in Dart. The function `handleRequest` is supposed to handle incoming requests.

        The vulnerability lies in the line where we parse the size from the request's query parameters and then use it to allocate a list of integers of that size. This means that a user can send a request with a very large size and cause the server to allocate a huge amount of memory, potentially leading to a Denial of Service (DoS) if the server runs out of memory.

        This is an example of improper resource allocation, as the resources allocated are controlled by an external source (user input) without any restrictions or checks. This can lead to inefficient use of resources and potential security risks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var size = int.parse(request.url.queryParameters['size']);

          // This allocation of resources based on user input can lead to improper resource allocation
          var data = List.filled(size, 0);

          return shelf.Response.ok('Resource allocated!');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several improvements to address the improper resource allocation vulnerability:

        1. **Size Parameter Validation**: The code now checks if the 'size' parameter is provided and is not empty. If the 'size' parameter is missing or empty, the function returns a 400 Bad Request response.

        2. **Integer Parsing with Error Handling**: The 'size' parameter is parsed into an integer using the 'int.parse' function. If the parsing fails (e.g., because the 'size' parameter is not a valid integer), the function returns a 400 Bad Request response.

        3. **Size Range Check**: The code checks if the parsed 'size' is within an acceptable range (0 to MAX_SIZE). If the 'size' is not within this range, the function returns a 400 Bad Request response. This prevents the allocation of an excessive amount of resources based on user input.

        4. **Resource Allocation**: If all the checks pass, the function allocates a list of the specified size. This is the same as in the original code, but now it's guaranteed that the size is within an acceptable range.

        By implementing these improvements, the code mitigates the risk of improper resource allocation, making it more robust and secure.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        const int MAX_SIZE = 10000; // Define a maximum limit for the size parameter

        shelf.Response handleRequest(shelf.Request request) {
          var sizeParam = request.url.queryParameters['size'];

          // Validate the size parameter
          if (sizeParam == null || sizeParam.isEmpty) {
            return shelf.Response(400, body: 'Bad Request: Size parameter is required');
          }

          int size;
          try {
            size = int.parse(sizeParam);
          } catch (e) {
            return shelf.Response(400, body: 'Bad Request: Size parameter must be an integer');
          }

          // Check if the size is within the acceptable range
          if (size < 0 || size > MAX_SIZE) {
            return shelf.Response(400, body: 'Bad Request: Size parameter must be between 0 and $MAX_SIZE');
          }

          // This allocation of resources based on user input can lead to improper resource allocation
          var data = List.filled(size, 0);

          return shelf.Response.ok('Resource allocated!');
        }
    steps:
    - Validate the 'size' parameter to ensure it's within an acceptable range before
      using it to allocate resources. This can be done by setting a maximum limit
      for the 'size' parameter.
    - Implement error handling for the 'int.parse' function to handle cases where
      the 'size' parameter cannot be converted to an integer.
    - Consider using a more efficient data structure or algorithm if the resource
      allocation is still too high after validating the 'size' parameter.
    - If the resource allocation is still too high, consider implementing a throttling
      mechanism to limit the rate at which resources are allocated.
  title: Improper resource allocation
  vulnerability_id: '067'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Enforce secure session expiration time
  solution:
    insecure_code_example:
      description: |-
        In the above code snippet, we are using the `shelf` framework to handle HTTP requests in a Dart backend application. The function `handleRequest` is used to handle incoming requests.

        We are setting the session data with a username value. However, there is no mechanism in place to expire the session after a certain period of inactivity. This means that the user's session will remain active indefinitely until the server is restarted or the session is manually destroyed.

        This is a security vulnerability known as "Insecure Session Expiration". The risk here is that an attacker could potentially hijack an active session and impersonate the user. This could lead to unauthorized actions being performed under the user's identity.

        To mitigate this vulnerability, we should implement a mechanism to automatically expire user sessions after a certain period of inactivity. In this case, the requirement is to expire the session after 5 minutes of inactivity.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var session = request.context['session'];

          // Set the session data
          session['username'] = 'user1';

          return shelf.Response.ok('Session Created');
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes the 'shelf_session' package, which\
        \ provides session management with expiration time. \n\nA session middleware\
        \ is created with a specified timeout duration of 5 minutes. This middleware\
        \ is then added to the Shelf pipeline using the `addMiddleware` function.\
        \ \n\nIn the `handleRequest` function, the session is retrieved from the request\
        \ context. The session data is set as before, but now, due to the session\
        \ middleware, the session will automatically expire after 5 minutes of inactivity.\
        \ \n\nThis ensures that user sessions are secure and do not remain active\
        \ indefinitely, reducing the risk of unauthorized access."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_session/shelf_session.dart';

        // Create a session middleware with a specified timeout duration of 5 minutes.
        var sessionMiddleware = sessionMiddlewareBuilder(
          new InMemorySessionStore(),
          cookieName: 'session',
          sessionTimeout: new Duration(minutes: 5),
        );

        // Apply the session middleware to your Shelf pipeline.
        var handler = const shelf.Pipeline()
            .addMiddleware(sessionMiddleware)
            .addHandler(handleRequest);

        shelf.Response handleRequest(shelf.Request request) {
          // Retrieve the session from the request context.
          var session = request.context['session'];

          // Set the session data
          session['username'] = 'user1';

          return shelf.Response.ok('Session Created');
        }
    steps:
    - Import a package that provides session management with expiration time, such
      as 'shelf_session'.
    - Create a session middleware with a specified timeout duration of 5 minutes.
    - Apply the session middleware to your Shelf pipeline.
    - In the 'handleRequest' function, retrieve the session from the request context.
    - Set the session data as you currently do, but now it will automatically expire
      after 5 minutes of inactivity.
  title: Insecure session expiration time
  vulnerability_id: '068'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and efficient web and mobile applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Implementation of secure and properly configured HTTP headers
  solution:
    insecure_code_example:
      description: "In the above Dart code, we are using the `shelf` package to create\
        \ a simple server. The server listens on localhost at port 8080 and responds\
        \ to any request with a simple message.\n\nHowever, this code is vulnerable\
        \ because it does not set the `Referrer-Policy` HTTP header. The `Referrer-Policy`\
        \ header controls how much referrer information (sent via the `Referer` header)\
        \ should be included with requests.\n\nWithout this header, or with an insecure\
        \ configuration, it could potentially leak sensitive data from the URL to\
        \ other sites through the `Referer` header. This can happen when your site\
        \ links to an external site or loads resources from it. \n\nTo mitigate this\
        \ vulnerability, it is recommended to always set the `Referrer-Policy` header\
        \ to a secure value like 'no-referrer', 'same-origin', or 'strict-origin-when-cross-origin'."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The above code fixes the vulnerability by adding a middleware function `_addReferrerPolicyHeader` to the server pipeline. This function adds the 'Referrer-Policy' HTTP header to every response. The value of the 'Referrer-Policy' is set to 'strict-origin-when-cross-origin', which is a secure option.

        The 'Referrer-Policy' HTTP header controls how much referrer information (sent via the Referer header) should be included with requests. The 'strict-origin-when-cross-origin' option sends a full URL when performing a same-origin request, only sends the origin of the document for cross-origin requests, and sends no header to a less secure destination (from HTTPS to HTTP).

        This middleware is added to the server pipeline using the `addMiddleware` function, ensuring that every response includes this header. This helps to prevent potential security vulnerabilities related to the referrer policy.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(_addReferrerPolicyHeader)
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        shelf.Middleware _addReferrerPolicyHeader() {
          return (shelf.Handler innerHandler) {
            return (shelf.Request request) async {
              final response = await innerHandler(request);
              return response.change(headers: {'Referrer-Policy': 'strict-origin-when-cross-origin'});
            };
          };
        }
    steps:
    - Import the 'shelf' package in your Dart file.
    - Create a middleware function that adds the 'Referrer-Policy' HTTP header to
      every response.
    - The value of the 'Referrer-Policy' should be set to a secure option like 'no-referrer',
      'same-origin', or 'strict-origin-when-cross-origin'.
    - Add this middleware to your server pipeline using the 'addMiddleware' function.
  title: Insecure or unset HTTP headers - Referrer-Policy
  vulnerability_id: '071'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_session for managing session data in a Shelf application
  need: Secure session management
  solution:
    insecure_code_example:
      description: |-
        The above Dart code uses the `shelf` and `shelf_session` packages to create a simple server with session management. The server listens on `localhost` port `8080` and responds to each request with a greeting message that includes the session token.

        The vulnerability lies in the `_handleRequest` function, where a session token is retrieved from the request but no expiration is set on it. This means that even after a user terminates their session, the token remains valid and can be used to make subsequent requests. This is a serious security issue as it could allow an attacker to reuse old session tokens to impersonate users and perform actions on their behalf.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_session/shelf_session.dart';

        // Create session middleware
        var sessionMiddleware = sessionMiddlewareMemory();

        var handler = const shelf.Pipeline()
            .addMiddleware(sessionMiddleware)
            .addHandler(_handleRequest);

        shelf.Response _handleRequest(shelf.Request request) {
          var session = request.context['session'] as Session;
          var token = session['token'];
          // No expiration is set on the session token
          return shelf.Response.ok('Hello, ${token}!');
        }

        void main() {
          shelf.serve(handler, 'localhost', 8080);
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code introduces a mechanism to handle session expiration and refresh the session token periodically.

        In the `_handleRequest` function, we first retrieve the session from the request context. We then check if the session token is expired using the `isExpired` property of the `Session` object. If the session token is expired, we return a 403 Forbidden response.

        Next, we refresh the session token using the `refresh` method of the `Session` object. This ensures that the session token is periodically updated while the user is active, which can help prevent session hijacking.

        Finally, we return a response with a greeting message that includes the session token. This is just for demonstration purposes and in a real-world application, you would typically not include the session token in the response.

        In the `main` function, we start the server and listen for requests on localhost port 8080. The server uses the `handler` function to handle incoming requests, which includes the session middleware for managing sessions.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf_session/shelf_session.dart';\n\
        \n// Create session middleware\nvar sessionMiddleware = sessionMiddlewareMemory();\n\
        \nvar handler = const shelf.Pipeline()\n    .addMiddleware(sessionMiddleware)\n\
        \    .addHandler(_handleRequest);\n\nshelf.Response _handleRequest(shelf.Request\
        \ request) {\n  var session = request.context['session'] as Session;\n  var\
        \ token = session['token'];\n  \n  // Check if the session token is expired\n\
        \  if (session.isExpired) {\n    return shelf.Response.forbidden('Session\
        \ expired');\n  }\n\n  // Refresh the session token periodically\n  session.refresh();\n\
        \n  return shelf.Response.ok('Hello, ${token}!');\n}\n\nvoid main() {\n  shelf.serve(handler,\
        \ 'localhost', 8080);\n}"
    steps:
    - Introduce a mechanism to invalidate the session token once the user logs out
      or after a certain period of inactivity.
    - You can use the 'expire' method provided by the 'shelf_session' package to set
      an expiration time for the session token.
    - Ensure that the server checks the validity of the session token with each request.
      If the token is expired, the server should reject the request.
    - Implement a mechanism to refresh the session token periodically while the user
      is active. This can help prevent session hijacking.
  title: Insecure session management
  vulnerability_id: '076'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of dart:math for mathematical calculations and operations
  - Usage of Shelf for building web applications in Dart
  need: Secure token generation mechanism
  solution:
    insecure_code_example:
      description: |-
        The above code is a Dart backend application that uses the Shelf framework. It includes a function `generateToken()`, which is used to generate a token that is then sent in the response of `handleRequest(shelf.Request request)` function.

        The `generateToken()` function uses Dart's `Random` class to generate a list of 20 random integers, each within the range of 33 to 121 (inclusive). These integers are then converted into their corresponding ASCII characters to form a string, which is returned as the token.

        This token generation method is insecure because it does not use a secure cryptographic mechanism. The `Random` class in Dart is not cryptographically secure, which means the sequence of numbers it generates can be predicted if the initial seed value is known. This makes the token susceptible to cracking, as an attacker could predict the sequence of numbers and therefore the token's hash. Once the hash is cracked, the attacker could obtain the information the token is masking.
      text: |-
        import 'dart:math';
        import 'package:shelf/shelf.dart' as shelf;

        String generateToken() {
          var rng = new Random();
          var codeUnits = new List.generate(20, (index){
            return rng.nextInt(33)+89;
          });

          return new String.fromCharCodes(codeUnits);
        }

        shelf.Response handleRequest(shelf.Request request) {
          var token = generateToken();
          return shelf.Response.ok('Generated Token: $token');
        }
    language: dart
    secure_code_example:
      description: |-
        The previous code was using the `Random` class from the `dart:math` library to generate a token. This class is not suitable for generating secure tokens because it is not a cryptographically secure random number generator. This means that the tokens it generates can be predicted or reproduced, which is a security vulnerability.

        The new code uses the `SecureRandom` class from the `dart:crypto` library to generate a token. This class is a cryptographically secure random number generator, which means that the tokens it generates cannot be predicted or reproduced.

        The `SecureRandom` class generates random bytes, so we create a byte array of the desired length for our token. We then fill this array with random bytes.

        Finally, we convert the byte array to a string using the `base64Url.encode` function from the `dart:convert` library. This function converts the byte array to a base64 string, which is a common format for tokens. This string can be safely sent over the network and stored in databases.

        The `handleRequest` function then uses this secure token generation function to generate a token and send it in the response to the client.
      text: |-
        import 'dart:convert';
        import 'dart:typed_data';
        import 'package:crypto/crypto.dart';
        import 'package:shelf/shelf.dart' as shelf;

        String generateToken() {
          var bytes = new Uint8List(20); // Define the length of the token
          var secureRandom = SecureRandom(); // Use a secure random number generator
          for (var i = 0; i < bytes.length; i++) {
            bytes[i] = secureRandom.nextUint8();
          }
          return base64Url.encode(bytes); // Convert the byte array to a base64 string
        }

        shelf.Response handleRequest(shelf.Request request) {
          var token = generateToken();
          return shelf.Response.ok('Generated Token: $token');
        }
    steps:
    - Replace the Random class with a secure random number generator. Dart provides
      a secure RNG in the 'dart:crypto' library.
    - Use the secure RNG to generate a byte array of a suitable length for a token.
    - Convert the byte array to a string representation, such as hexadecimal or base64,
      to use as the token.
  title: Insecurely generated token
  vulnerability_id: '078'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing input/output operations in a Shelf application
  need: Explicitly declare and manage dependencies in the source code to ensure upgradability
    and avoid potential security vulnerabilities.
  solution:
    insecure_code_example:
      description: "The above code is a simple server application using the \"shelf\"\
        \ package in Dart. The vulnerability here is that the \"shelf\" package is\
        \ directly imported without any version specification. This is a problem because\
        \ it means the application could be using an outdated or insecure version\
        \ of the package. It also makes it difficult to ensure that the application\
        \ will behave the same way in different environments, because the version\
        \ of the package could be different in each environment. \n\nThe proper way\
        \ to manage dependencies in Dart is to specify them in the `pubspec.yaml`\
        \ file, which is not done here. This file should list the name and version\
        \ of each dependency, which allows you to control exactly which versions of\
        \ each package your application uses. This makes your application more secure\
        \ and predictable, because you can ensure that you're always using a secure\
        \ version of each package and that your application behaves the same way in\
        \ every environment."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The vulnerability in the code was due to non-upgradable dependencies. The dependencies were not explicitly declared with their versions in the source code. They were directly copied into the repositories which is a bad practice and can lead to potential security risks.

        To fix this vulnerability, we have explicitly declared each dependency and its version in the project's `pubspec.yaml` file. The dependencies used in this project are `shelf` and `shelf_io`. We have specified the versions of these dependencies as `^1.1.5` and `^1.2.0` respectively. The caret `^` symbol before the version number means that the project is compatible with any version that is compatible with the specified version.

        We have also removed any direct copies of dependencies from the repositories. Now, we are using the Dart package manager `pub` to manage the dependencies. This ensures that the correct versions of the dependencies are used and they can be easily updated.

        It is also recommended to regularly check for updates to the dependencies and test the project with these updates to ensure compatibility. You can consider using a tool or service that can automatically check for updates to the dependencies and alert you when they are available.
      text: |-
        // pubspec.yaml
        name: my_project
        description: A simple backend application using shelf framework
        version: 1.0.0

        environment:
          sdk: '>=2.12.0 <3.0.0'

        dependencies:
          shelf: ^1.1.5
          shelf_io: ^1.2.0

        dev_dependencies:
          pedantic: ^1.11.0

        // main.dart
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Identify all the dependencies used in your project.
    - For each dependency, determine the specific version that your project is compatible
      with.
    - Explicitly declare each dependency and its version in your project's pubspec.yaml
      file.
    - Remove any direct copies of dependencies from your repositories.
    - Use a package manager like pub to manage your dependencies. This will ensure
      that the correct versions are used and that they can be updated easily.
    - Regularly check for updates to your dependencies and test your project with
      these updates to ensure compatibility.
    - Consider using a tool or service that can automatically check for updates to
      your dependencies and alert you when they are available.
  title: Non-upgradable dependencies
  vulnerability_id: '079'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Protection of user privacy
  solution:
    insecure_code_example:
      description: |-
        In the above code, we have a simple server that listens on `localhost:8080` and echoes back the headers of any request it receives. The vulnerable part of this code is in the `_echoRequest` function. Here, we are taking all the headers from a request and sending them back in the response.

        This is a privacy violation because HTTP headers can contain sensitive information. For example, they often include cookies, which might be used to authenticate a user. By echoing these back in the response, we are potentially exposing this sensitive information to anyone who can intercept the response. This could be an attacker who is eavesdropping on the network, or it could be any third-party JavaScript code running in the user's browser if the response is being sent there.

        Additionally, the code does not have any checks or filters to remove or obfuscate sensitive headers before echoing them back. This means that all headers, regardless of their sensitivity, are being exposed.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // Echoes the request headers back in the response body
          var data = request.headers.entries.map((h) => '${h.key}: ${h.value}').join('\\n');
          return shelf.Response.ok(data);
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was echoing back all the headers received in the request, including potentially sensitive ones like 'authorization', 'cookie', and 'set-cookie'. This could lead to privacy violations as these headers often contain sensitive user information.

        The fixed code first defines a list of sensitive headers that should not be echoed back. This list includes 'authorization', 'cookie', and 'set-cookie', but can be extended to include any other headers that are considered sensitive in the context of the application.

        The '_echoRequest' function is then modified to filter out these sensitive headers when creating the 'data' variable. This is done using the 'where' function to exclude any headers whose key is in the 'sensitiveHeaders' list. The key is converted to lower case before the comparison to ensure that the filtering is case-insensitive.

        As a result, the response will still include the headers from the request, but any sensitive headers will be excluded, thus preserving the privacy of the user's information.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // List of sensitive headers that should not be echoed back
          var sensitiveHeaders = ['authorization', 'cookie', 'set-cookie'];

          // Echoes the request headers back in the response body, excluding sensitive headers
          var data = request.headers.entries
              .where((h) => !sensitiveHeaders.contains(h.key.toLowerCase()))
              .map((h) => '${h.key}: ${h.value}')
              .join('\\n');

          return shelf.Response.ok(data);
        }
    steps:
    - Identify the sensitive information in the headers that should not be echoed
      back.
    - Create a list of these sensitive headers that should be excluded.
    - Modify the '_echoRequest' function to filter out these sensitive headers when
      creating the 'data' variable.
  title: Privacy violation
  vulnerability_id: '088'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Enforce strict data validation and maintain trust boundaries
  solution:
    insecure_code_example:
      description: "In the above Dart code, we're using the Shelf framework to handle\
        \ HTTP requests. The function `handleRequest` is designed to handle incoming\
        \ requests.\n\nIn this function, we first extract the query parameters from\
        \ the URL of the request. This data is untrusted because it comes directly\
        \ from the user, who can manipulate it. \n\nWe then extract the 'username'\
        \ and 'password' from this untrusted data and put it into a new data structure\
        \ `userInfo` along with a trusted data `'isAdmin': false`. \n\nThe problem\
        \ here is that we are mixing trusted and untrusted data in the same data structure.\
        \ This is a Trust Boundary Violation vulnerability. \n\nThe trusted data (isAdmin)\
        \ is hardcoded and controlled by the system, while the untrusted data (username\
        \ and password) is supplied by the user. If an attacker can manipulate the\
        \ untrusted data in a way that affects the system's behavior, they could potentially\
        \ gain unauthorized access or perform actions they shouldn't be able to. \n\
        \nIn this case, if there is any code later that relies on the 'isAdmin' field\
        \ to grant administrative privileges, and if the untrusted data is not properly\
        \ validated, an attacker could potentially manipulate the 'username' or 'password'\
        \ field to trick the system into granting them admin rights."
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nFuture<shelf.Response>\
        \ handleRequest(shelf.Request request) async {\n  var data = request.url.queryParameters;\n\
        \  var username = data['username'];\n  var password = data['password'];\n\
        \  \n  // Mixing trusted and untrusted data in the same data structure\n \
        \ var userInfo = {\n    'username': username,\n    'password': password,\n\
        \    'isAdmin': false\n  };\n\n  // Rest of the code\n}"
    language: dart
    secure_code_example:
      description: |-
        The updated code now separates the handling of trusted and untrusted data by using a dedicated class `UserInfo` for user information. This provides a clear distinction between trusted and untrusted data.

        Before using the 'username' and 'password' parameters, the code validates the input data. It checks if these parameters are present in the request data and if they meet the required format or criteria (in this case, they should not be empty). If the validation fails, the function returns an appropriate error response with a status code of 400 and a descriptive error message.

        This way, the system does not mix trusted and untrusted data in the same data structure, thus fixing the trust boundary violation vulnerability.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nclass UserInfo {\n  String\
        \ username;\n  String password;\n  bool isAdmin;\n\n  UserInfo(this.username,\
        \ this.password, {this.isAdmin = false});\n}\n\nFuture<shelf.Response> handleRequest(shelf.Request\
        \ request) async {\n  var data = request.url.queryParameters;\n  \n  // Validate\
        \ the input data\n  if (!data.containsKey('username') || !data.containsKey('password'))\
        \ {\n    return shelf.Response(400, body: 'Missing username or password');\n\
        \  }\n\n  var username = data['username'];\n  var password = data['password'];\n\
        \n  // Ensure the username and password meet the required format or criteria\n\
        \  if (username.isEmpty || password.isEmpty) {\n    return shelf.Response(400,\
        \ body: 'Username or password should not be empty');\n  }\n\n  // Use a dedicated\
        \ data structure for user information\n  var userInfo = UserInfo(username,\
        \ password);\n\n  // Rest of the code\n}"
    steps:
    - Separate the handling of trusted and untrusted data. Do not mix them in the
      same data structure.
    - Validate the input data. Ensure that the 'username' and 'password' parameters
      are present and meet the required format or criteria before using them.
    - Consider using a dedicated data structure or class for user information. This
      can help to encapsulate the data and provide a clear distinction between trusted
      and untrusted data.
    - Implement proper error handling. If the validation fails, the function should
      return an appropriate error response.
  title: Lack of data validation - Trust boundary violation
  vulnerability_id: '089'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Prevention of log injection attacks
  solution:
    insecure_code_example:
      description: |-
        This code represents a log injection vulnerability. The application is using the `shelf` framework for Dart, a middleware system for handling HTTP requests and responses.

        The function `handleRequest` is designed to handle incoming HTTP requests. It retrieves an untrusted input from the query parameters of the request URI. This input is directly logged to the console without any validation, sanitization, or escaping.

        The problem arises when the untrusted input contains malicious characters or strings. For example, an attacker could provide input that includes newline characters or other special sequences, which could be interpreted by the log viewer in a way that hides or alters the true nature of the request.

        This could allow an attacker to inject false entries into the logs, or to obfuscate their activities, making it harder for administrators to understand what is really happening in the system. In more severe cases, if the logs are being processed by other systems, the attacker could potentially exploit this vulnerability to execute arbitrary commands or scripts in the context of those systems.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void handleRequest(shelf.Request request) {
          var untrustedInput = request.requestedUri.queryParameters['input'];
          print('Received request: ${untrustedInput}');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a validation step before logging the untrusted input. The `isValidInput` function is used to check if the input matches a certain pattern or criteria. If the input is not valid, a message is printed and the function returns early.

        After validating the input, the code sanitizes and escapes the input using the `HtmlEscape` class from the `html_escape` package. This class converts characters in the input that have special meaning in the context where the input is used into a form that is safe to use. For example, in the context of log files, newline characters are escaped so they are treated as literal characters rather than control characters.

        By validating, sanitizing, and escaping untrusted input before logging it, the updated code helps to prevent log injection attacks. This is important because log injection attacks can lead to a variety of security issues, including information disclosure, data tampering, and remote code execution.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:html_escape/html_escape.dart';\n\
        \nvoid handleRequest(shelf.Request request) {\n  var untrustedInput = request.requestedUri.queryParameters['input'];\n\
        \  \n  // Validate the input\n  if (!isValidInput(untrustedInput)) {\n   \
        \ print('Invalid input received');\n    return;\n  }\n\n  // Sanitize and\
        \ escape the input\n  var escape = new HtmlEscape();\n  var sanitizedInput\
        \ = escape.convert(untrustedInput);\n\n  print('Received request: ${sanitizedInput}');\n\
        }\n\nbool isValidInput(String input) {\n  // Add your validation logic here\n\
        \  // For example, you could check if the input matches a certain pattern\n\
        \  return true;\n}"
    steps:
    - 'Validate the input: Ensure that the input matches a set of strict criteria.
      This could be a whitelist of acceptable values or a regex pattern.'
    - 'Sanitize the input: Remove or replace characters in the input that have special
      meaning in the context where the input is used. For example, in the context
      of log files, newline characters could be removed or replaced.'
    - 'Escape the input: Transform characters in the input that have special meaning
      in the context where the input is used into a form that is safe to use. For
      example, in the context of log files, newline characters could be escaped so
      they are treated as literal characters rather than control characters.'
    - 'Use a logging library that automatically sanitizes and escapes log entries:
      This can help to ensure that log entries are safe, even if other parts of the
      code fail to properly validate, sanitize, or escape input.'
  title: Log injection
  vulnerability_id: '091'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance and scalable applications
  - Usage of dart:io for performing input/output operations in Dart
  - Usage of shelf_io.dart package for handling HTTP requests and responses in Dart
    with the Shelf framework
  - Usage of Shelf package for building web applications in Dart
  need: Secure encryption algorithm for all connections
  solution:
    insecure_code_example:
      description: "The above Dart code represents a simple server built using the\
        \ Shelf framework. The server is set to listen to requests on 'localhost'\
        \ on port '8080'. \n\nThe vulnerability lies in the use of an insecure encryption\
        \ algorithm. The server uses the SecurityContext() function to transform incoming\
        \ requests, but it does not specify any particular cipher suite. This means\
        \ that the server will accept connections with any cipher suite, including\
        \ anonymous ones. \n\nAnonymous cipher suites do not provide authentication,\
        \ which means that they are vulnerable to man-in-the-middle attacks. An attacker\
        \ could intercept the communication between the client and the server and\
        \ impersonate the server. \n\nTo fix this vulnerability, the server should\
        \ be configured to only accept connections with secure cipher suites. This\
        \ can be done by specifying a list of acceptable cipher suites in the SecurityContext()\
        \ function."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf/shelf.dart';

        void main() {
          var handler = const Pipeline().addMiddleware(logRequests()).addHandler(_echoRequest);

          HttpServer.bind('localhost', 8080).then((server) {
            server.defaultResponseHeaders.add("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
            server.transform(SecurityContext()).listen((HttpRequest request) {
              request.response
                ..headers.contentType = ContentType("text", "plain", charset: "utf-8")
                ..write('Response Placeholder');
            });
          });
        }

        Response _echoRequest(Request request) {
          return Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a `SecurityContext` instance with secure settings. This context is used when creating the `HttpServer` instance, ensuring that the server only accepts connections with secure cipher suites.

        The `SecurityContext` instance is created with `withTrustedRoots` set to `true`, which means that the context trusts the root certificates in the certificate chain.

        The use of anonymous cipher suites is disabled by setting trusted certificates and a private key for the `SecurityContext` instance. The `setTrustedCertificates` method sets the trusted root certificates for the context, and the `usePrivateKey` method sets the private key for the context. The path to the certificates and the private key, as well as the password for the private key, should be replaced with the actual paths and password.

        The `bindSecure` method is used instead of the `bind` method when creating the `HttpServer` instance. This method creates a server that communicates using HTTPS.

        The `transform` method is used to add the `SecurityContext` instance to the server's stream of requests. This ensures that all requests are processed using the secure settings of the context.

        The rest of the code remains the same. The server still adds the "Strict-Transport-Security" header to all responses and sends a placeholder response to all requests.
      text: "import 'dart:io';\nimport 'package:shelf/shelf_io.dart' as io;\nimport\
        \ 'package:shelf/shelf.dart';\n\nvoid main() {\n  var handler = const Pipeline().addMiddleware(logRequests()).addHandler(_echoRequest);\n\
        \n  // Create a SecurityContext with secure settings\n  SecurityContext context\
        \ = new SecurityContext(withTrustedRoots: true);\n\n  // Disable the use of\
        \ anonymous cipher suites\n  context.setTrustedCertificates('path/to/certificates.pem');\n\
        \  context.usePrivateKey('path/to/privateKey.pem', password: 'password');\n\
        \  \n  // Use this SecurityContext instance when creating the HttpServer\n\
        \  HttpServer.bindSecure('localhost', 8080, context).then((server) {\n   \
        \ server.defaultResponseHeaders.add(\"Strict-Transport-Security\", \"max-age=31536000;\
        \ includeSubDomains\");\n    server.transform(context).listen((HttpRequest\
        \ request) {\n      request.response\n        ..headers.contentType = ContentType(\"\
        text\", \"plain\", charset: \"utf-8\")\n        ..write('Response Placeholder');\n\
        \    });\n  });\n}\n\nResponse _echoRequest(Request request) {\n  return Response.ok('Request\
        \ for \"${request.url}\"');\n}"
    steps:
    - Create a SecurityContext instance with secure settings.
    - Disable the use of anonymous cipher suites in the SecurityContext settings.
    - Use this SecurityContext instance when creating the HttpServer.
    - Ensure that the server only accepts connections with secure cipher suites.
  title: Insecure encryption algorithm - Anonymous cipher suites
  vulnerability_id: '092'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building fast and efficient web and mobile applications
  - Usage of cipher for encryption and decryption operations
  need: Implementation of secure encryption algorithms with strong cipher block chaining
  solution:
    insecure_code_example:
      description: "The above Dart code is a simple implementation of the AES encryption\
        \ algorithm in Cipher Block Chaining (CBC) mode. \n\nThe main function initializes\
        \ a key and an initialization vector (IV), as well as the plaintext message\
        \ to be encrypted. It then creates a new PaddedBlockCipher object, specifying\
        \ AES/CBC/PKCS7 as the cipher to be used. The cipher is initialized with the\
        \ key and IV, and the plaintext message is encrypted.\n\nThe problem lies\
        \ in the use of the Cipher Block Chaining (CBC) mode. CBC mode is considered\
        \ insecure for many applications because it is vulnerable to a variety of\
        \ cryptographic attacks, such as the BEAST attack and Padding Oracle attacks.\
        \ \n\nIn addition, the initialization vector (IV) in this code is a fixed\
        \ value, which is also a major security risk. The IV should be random and\
        \ unique for each encryption operation to ensure the security of the encryption\
        \ algorithm. \n\nLastly, the key is hardcoded into the application, which\
        \ is a bad practice. The key should be stored securely and not directly in\
        \ the application code."
      text: |-
        import 'dart:convert';
        import 'dart:typed_data';
        import 'package:cipher/cipher.dart';
        import 'package:cipher/impl/base.dart';

        void main() {
          final key = utf8.encode('my secure key');
          final iv = Uint8List(8);
          final plaintext = 'Hello, world!';

          final encrypter = new PaddedBlockCipher('AES/CBC/PKCS7')
            ..init(true, new PaddedBlockCipherParameters<Null, KeyParameter>(null, new KeyParameter(key)));

          final ciphertext = encrypter.process(utf8.encode(plaintext));

          print('Ciphertext: ${base64.encode(ciphertext)}');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was using an insecure Cipher Block Chaining (CBC) mode for encryption. This mode is vulnerable to certain types of attacks, such as the bit-flipping attack. The code was also using a hardcoded key, which is not secure because it can be easily discovered by an attacker.

        The updated code uses the Galois/Counter Mode (GCM), which is a more secure mode of operation for symmetric key cryptographic block ciphers. It also uses a secure random number generator to generate the encryption key and the Initialization Vector (IV). The key and the IV are unique and random for each encryption operation, which increases the security of the encryption.

        The key length is 256 bits, which is a recommended length for AES encryption. The IV length is 128 bits, which is the block size of AES.

        The code uses the Pointy Castle library, which is a Dart implementation of the Java cryptography library Bouncy Castle. It provides a wide range of cryptographic algorithms, including secure random number generators, symmetric and asymmetric ciphers, and secure padding schemes.
      text: |-
        import 'dart:convert';
        import 'dart:typed_data';
        import 'package:cipher/cipher.dart';
        import 'package:cipher/impl/base.dart';
        import 'package:pointycastle/export.dart';

        void main() {
          final secureRandom = FortunaRandom();
          final secureKey = secureRandom.nextBytes(32); // Generate a 256-bit key
          final iv = secureRandom.nextBytes(16); // Generate a 128-bit IV
          final plaintext = 'Hello, world!';

          final gcm = new GCMBlockCipher(AESFastEngine())
            ..init(true, AEADParameters(KeyParameter(secureKey), 128, iv));

          final ciphertext = gcm.process(utf8.encode(plaintext));

          print('Ciphertext: ${base64.encode(ciphertext)}');
        }
    steps:
    - Replace the insecure Cipher Block Chaining (CBC) mode with a more secure mode
      such as Galois/Counter Mode (GCM).
    - Ensure that the Initialization Vector (IV) is unique and random for each encryption
      operation.
    - Use a secure method to generate and store the encryption key, avoid hardcoding
      the key in the code.
    - Ensure that the key length is sufficient, for AES encryption a key length of
      128, 192 or 256 bits is recommended.
    - Use a secure padding scheme, PKCS7 is secure and commonly used.
  title: Insecure encryption algorithm - Cipher Block Chaining
  vulnerability_id: '094'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_io for managing I/O operations in a Node.js application
  need: Enforcement of data uniqueness verification
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is a simple server application using the Shelf framework. It listens on port 8080 and responds to any incoming request by echoing back the 'data' header from the request.

        The vulnerability lies in the `_echoRequest` function. This function takes the incoming request and directly uses the 'data' from the request headers without validating its uniqueness. This means that if an attacker were to reuse or regenerate the same 'data', the server would accept it as valid even though it should only be valid for one use.

        This could potentially lead to various security issues such as replay attacks, where an attacker could resend a previously sent request to perform an action without the user's consent. It could also lead to data integrity issues as the same 'data' could be used in different contexts, potentially leading to incorrect operations or results.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          final String data = request.headers['data'];
          // Vulnerability: No verification of data uniqueness
          return shelf.Response.ok('You sent: $data');
        }
    language: dart
    secure_code_example:
      description: "The updated code fixes the vulnerability by properly validating\
        \ the uniqueness of the data. \n\nA `Set` named `dataSet` is created to store\
        \ the data received from each request. The `Set` data structure is used because\
        \ it does not allow duplicate values, which makes it perfect for ensuring\
        \ data uniqueness.\n\nIn the `_echoRequest` function, before processing a\
        \ request, the code checks if the data from the request already exists in\
        \ the `dataSet`. This is done using the `contains` method of the `Set` class,\
        \ which returns `true` if the element is found in the set, and `false` otherwise.\n\
        \nIf the `contains` method returns `true`, meaning the data already exists\
        \ in the `dataSet`, the function returns an error response with a status code\
        \ of `400` and a body of `'Error: Data is not unique'`.\n\nIf the `contains`\
        \ method returns `false`, meaning the data does not exist in the `dataSet`,\
        \ the data is added to the `dataSet` using the `add` method of the `Set` class,\
        \ and the function proceeds with processing the request.\n\nThis way, the\
        \ application properly validates the uniqueness of the data, preventing an\
        \ attacker from reusing or regenerating information that should be valid for\
        \ one use only. \n\nPlease note that if your application is multi-threaded,\
        \ you should ensure that the `dataSet` is thread-safe to prevent race conditions.\
        \ In Dart, you can use packages like `synchronized` to make your operations\
        \ thread-safe."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        // Create a Set to store the data from each request
        final Set<String> dataSet = {};

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          final String data = request.headers['data'];

          // Check if the data from the request already exists in the Set
          if (dataSet.contains(data)) {
            // If the data already exists, return an error response
            return shelf.Response(400, body: 'Error: Data is not unique');
          } else {
            // If the data does not exist in the Set, add it to the Set
            dataSet.add(data);
            return shelf.Response.ok('You sent: $data');
          }
        }
    steps:
    - Create a data structure, such as a set or a hash table, to store the data received
      from each request.
    - Before processing a request, check if the data from the request already exists
      in the data structure.
    - If the data already exists, return an error response indicating that the data
      is not unique.
    - If the data does not exist in the data structure, add it to the data structure
      and proceed with processing the request.
    - Ensure that the data structure is thread-safe if the application is multi-threaded.
  title: Data uniqueness not properly verified
  vulnerability_id: '095'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and efficient applications
  - Usage of dart:convert for encoding and decoding data in Dart
  - Usage of Shelf for building web applications in Dart
  need: Secure deserialization process
  solution:
    insecure_code_example:
      description: |-
        In the above code, the `handleRequest` function reads the request body as a string and then deserializes the JSON data into a Dart object. This is done using the `jsonDecode` function which returns a `Map<String, dynamic>` object. This map is then passed to the `User.fromJson` constructor to create a `User` object.

        The vulnerability lies in the fact that there is no validation of the content of the deserialized object. The `User.fromJson` constructor blindly trusts that the provided map contains the correct keys and values. If an attacker were to send a request with additional keys in the JSON object or with values of the wrong type, this could lead to unexpected behavior, crashes, or even security vulnerabilities.

        For example, an attacker could send a request with a `password` value that is not a string. When the `User` constructor tries to assign this value to the `password` field (which expects a string), a runtime error will occur. This could lead to a Denial of Service (DoS) attack if the server crashes.

        Furthermore, because the `User` class includes sensitive information (the `password` field), insecure deserialization could potentially allow an attacker to inject malicious data or extract sensitive data.

        Insecure deserialization vulnerabilities can be mitigated by validating the content of the deserialized object before using it. This could involve checking the types and values of the fields, as well as the presence or absence of expected keys.
      text: |-
        import 'dart:convert';
        import 'package:shelf/shelf.dart';

        class User {
          final String username;
          final String password;

          User(this.username, this.password);

          User.fromJson(Map<String, dynamic> json)
              : username = json['username'],
                password = json['password'];

          Map<String, dynamic> toJson() =>
              {
                'username': username,
                'password': password,
              };
        }

        Response handleRequest(Request request) async {
          var body = await request.readAsString();
          var data = jsonDecode(body);
          var user = User.fromJson(data);

          // ... rest of the code
        }
    language: dart
    secure_code_example:
      description: |-
        The code above fixes the insecure deserialization vulnerability in the following ways:

        1. **Data Validation**: Before deserializing the JSON data, we validate it by checking if the necessary fields are present and are of the correct type. This is done in the `validate` method of the `User` class. If the data is invalid, an exception is thrown.

        2. **Exception Handling**: In the `handleRequest` function, we catch any exceptions thrown during the deserialization process. If an exception is caught, we return an error response to the client with a status code of 400, indicating that the request was malformed.

        3. **Safe Deserialization**: By validating the data before deserializing it, we ensure that only valid data is used to create a `User` object. This prevents an attacker from exploiting the deserialization process to inject malicious data into the application.

        By implementing these measures, we can significantly reduce the risk of insecure deserialization vulnerabilities in the application.
      text: |-
        import 'dart:convert';
        import 'package:shelf/shelf.dart';

        class User {
          final String username;
          final String password;

          User(this.username, this.password);

          User.fromJson(Map<String, dynamic> json)
              : username = json['username'],
                password = json['password'];

          Map<String, dynamic> toJson() =>
              {
                'username': username,
                'password': password,
              };

          static void validate(Map<String, dynamic> json) {
            if (json == null) {
              throw Exception('Invalid data: null');
            }
            if (json['username'] == null || json['username'] is! String) {
              throw Exception('Invalid data: username');
            }
            if (json['password'] == null || json['password'] is! String) {
              throw Exception('Invalid data: password');
            }
          }
        }

        Response handleRequest(Request request) async {
          try {
            var body = await request.readAsString();
            var data = jsonDecode(body);
            User.validate(data);
            var user = User.fromJson(data);

            // ... rest of the code

          } catch (e) {
            return Response(400, body: 'Invalid data');
          }
        }
    steps:
    - First, you should validate the incoming JSON data before deserializing it. This
      can be done by checking if the necessary fields are present and are of the correct
      type.
    - Second, you should implement a method in the User class that validates the data
      before creating a new User object. This method should throw an exception if
      the data is invalid.
    - Third, you should catch any exceptions thrown during the deserialization process
      in the handleRequest function. If an exception is caught, you should return
      an error response to the client.
    - Lastly, consider using a safe deserialization library or tool that provides
      built-in protections against insecure deserialization.
  title: Insecure deserialization
  vulnerability_id: '096'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing input/output operations in a Shelf application
  need: Secure handling of file uploads
  solution:
    insecure_code_example:
      description: "In the above code, we have a simple HTTP server built using the\
        \ `shelf` framework. The server listens for a request at the `/upload` endpoint\
        \ and then takes the `filePath` and `fileContent` from the headers of the\
        \ request. \n\nThe `filePath` is used to create a new file on the server's\
        \ filesystem, and the `fileContent` is written to that file. \n\nThe vulnerability\
        \ here lies in the fact that the server trusts the `filePath` header from\
        \ the request. An attacker could manipulate the `filePath` to overwrite any\
        \ file on the server's filesystem, or to write new files in sensitive locations.\
        \ \n\nFor example, an attacker could set `filePath` to `/etc/passwd` to overwrite\
        \ the server's password file, or to `/var/www/html/evil.html` to serve malicious\
        \ content from the server's web root. \n\nThis is a classic example of the\
        \ 'External Control of File Name or Path' vulnerability, where the application\
        \ fails to properly validate input that is used to construct file names or\
        \ paths."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() async {
          var server = await io.serve(handler, 'localhost', 8080);

          print('Serving at http://${server.address.host}:${server.port}');
        }

        shelf.Response handler(shelf.Request request) {
          if (request.url.path == 'upload') {
            var filePath = request.headers['filePath'];
            var fileContent = request.headers['fileContent'];

            var file = File(filePath);
            file.writeAsStringSync(fileContent);

            return shelf.Response.ok('File uploaded successfully');
          }

          return shelf.Response.notFound('Not Found');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several changes to address the vulnerability:

        1. **File Path Validation**: The code now checks if the provided file path contains '..' or is an absolute path. If either condition is true, the server responds with a 'Forbidden' status, preventing potential directory traversal attacks.

        2. **Safe Path Joining**: The `path.join` function from the `path` package is used to safely join the expected directory with the provided file path. This ensures that the file is always saved within the expected directory, even if the provided file path tries to navigate to a different directory.

        3. **Server-Defined Filename**: Instead of using the filename provided in the request, the server now generates its own filename using the `path.basename` function. This prevents an attacker from controlling the file name or path.

        4. **Least Privilege**: Although not shown in the code, it is recommended to ensure that the application has the least privilege on the file system, especially on the directories where the files are stored. This can be done through proper configuration of the server and file system permissions.
      text: |-
        import 'dart:io';
        import 'package:path/path.dart' as path;
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() async {
          var server = await io.serve(handler, 'localhost', 8080);

          print('Serving at http://${server.address.host}:${server.port}');
        }

        shelf.Response handler(shelf.Request request) {
          if (request.url.path == 'upload') {
            var filePath = request.headers['filePath'];
            var fileContent = request.headers['fileContent'];

            // Validate the file path
            if (filePath.contains('..') || path.isAbsolute(filePath)) {
              return shelf.Response.forbidden('Invalid file path');
            }

            // Safely join paths
            var safeFilePath = path.join('/expected/directory', filePath);

            // Generate a server-defined filename
            var fileName = path.basename(safeFilePath);
            var serverDefinedFilePath = path.join('/expected/directory', fileName);

            var file = File(serverDefinedFilePath);
            file.writeAsStringSync(fileContent);

            return shelf.Response.ok('File uploaded successfully');
          }

          return shelf.Response.notFound('Not Found');
        }
    steps:
    - Validate the file path provided in the request to ensure it is within the expected
      directory.
    - Do not allow absolute paths or paths that contain '..' to prevent directory
      traversal attacks.
    - Consider using a library or built-in function to safely join paths.
    - Generate a server-defined filename instead of using the one provided in the
      request.
    - Ensure that the application has the least privilege on the file system, especially
      on the directories where the files are stored.
  title: External control of file name or path
  vulnerability_id: '098'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing database interactions and data modeling
  - Usage of shelf_router for routing and handling HTTP requests in a Shelf application
  - Usage of mongo_dart for interacting with MongoDB in Dart
  need: Prevention of NoSQL injection attacks
  solution:
    insecure_code_example:
      description: |-
        The above Dart code shows a backend application using the shelf framework and mongo_dart package to interact with a MongoDB database. The UserController class has a router that handles a POST request to the '/login' endpoint.

        The vulnerability lies in this part of the code:

        ```dart
        final username = params['username'];
        final password = params['password'];

        final userCollection = db.collection('users');
        final user = await userCollection.findOne({
          'username': username,
          'password': password,
        });
        ```

        Here, the code is reading the 'username' and 'password' directly from the request parameters and using them to create a MongoDB query. This is a security vulnerability known as NoSQL Injection.

        An attacker can send a malicious request with special characters or scripts in the 'username' or 'password' fields that can alter the query's behavior, potentially gaining unauthorized access or performing other harmful actions.

        The code does not validate or sanitize the input before including it in the query, making it vulnerable to NoSQL Injection attacks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:mongo_dart/mongo_dart.dart';

        class UserController {
          final Db db;

          UserController(this.db);

          Router get router {
            final router = Router();

            router.post('/login', (shelf.Request request) async {
              final params = await request.readAsString();
              final username = params['username'];
              final password = params['password'];

              final userCollection = db.collection('users');
              final user = await userCollection.findOne({
                'username': username,
                'password': password,
              });

              if (user == null) {
                return shelf.Response.forbidden('Invalid username or password');
              } else {
                return shelf.Response.ok('Login successful');
              }
            });

            return router;
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several changes to mitigate the risk of NoSQL injection:

        1. **Input Validation**: The `isValidInput` function is used to validate the username and password before they are used in the NoSQL query. This function currently checks if the input is not null and if it has a length greater than 0. Depending on the requirements of your application, you might want to add more checks (e.g., checking if the input matches a certain pattern or if it only contains allowed characters).

        2. **Password Hashing**: Instead of storing the passwords in plain text in the database, the code now uses the SHA-256 hash function from the `crypto` package to hash the passwords. This way, even if an attacker manages to inject a NoSQL query and retrieve the data from the database, they will only get the hashed passwords, which are useless without the original password.

        3. **Parameterized Queries**: The code uses parameterized queries to separate the query code from the data. This way, the database can distinguish between the two and prevent injection attacks.

        4. **Error Handling**: The code returns a generic 'Invalid input' message if the input validation fails. This way, the application does not reveal any details about the database or the structure of the query, which could be used by an attacker to refine their injection attacks.

        5. **Limited Database Privileges**: Although not shown in the code, it is recommended to limit the privileges of the database account used by the application. It should only have the necessary permissions to perform its tasks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:mongo_dart/mongo_dart.dart';
        import 'package:crypto/crypto.dart';
        import 'dart:convert'; // for the utf8.encode method

        class UserController {
          final Db db;

          UserController(this.db);

          Router get router {
            final router = Router();

            router.post('/login', (shelf.Request request) async {
              final params = await request.readAsString();
              final username = params['username'];
              final password = params['password'];

              // Validate the inputs
              if (!isValidInput(username) || !isValidInput(password)) {
                return shelf.Response.forbidden('Invalid input');
              }

              // Hash the password
              var bytes = utf8.encode(password); // data being hashed
              var digest = sha256.convert(bytes);

              final userCollection = db.collection('users');
              final user = await userCollection.findOne({
                'username': username,
                'password': digest.toString(),
              });

              if (user == null) {
                return shelf.Response.forbidden('Invalid username or password');
              } else {
                return shelf.Response.ok('Login successful');
              }
            });

            return router;
          }

          bool isValidInput(String input) {
            // Define the rules for valid input
            return input != null && input.length > 0;
          }
        }
    steps:
    - Validate the user inputs before using them in the NoSQL query. This can be done
      by checking if the input matches a certain pattern or by using a list of allowed
      characters.
    - Use parameterized queries or prepared statements if the NoSQL database supports
      them. This way, the database can distinguish between the query code and the
      data.
    - Implement a strong password hashing mechanism. Storing passwords in plain text
      in the database is a security risk. Use a strong cryptographic hash function
      to store the passwords.
    - Limit the privileges of the database account used by the application. It should
      only have the necessary permissions to perform its tasks.
    - Implement an error handling mechanism that does not reveal details about the
      database or the structure of the query. This information can be used by an attacker
      to refine their injection attacks.
  title: NoSQL injection
  vulnerability_id: '106'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data models and database interactions
  - Usage of shelf_io for managing and organizing data storage in a Node.js application
  need: Enforcement of rate limiting to control user interaction frequency
  solution:
    insecure_code_example:
      description: "In this Dart code snippet, we are using the `shelf` package to\
        \ create a simple server that listens for incoming requests on `localhost`\
        \ at port `8080`. \n\nThe `_echoRequest` function is a handler that responds\
        \ to any incoming request with a simple message. \n\nThe `main` function sets\
        \ up a pipeline with a logging middleware and the `_echoRequest` handler.\
        \ Then it starts the server with `io.serve`.\n\nThe vulnerability lies in\
        \ the fact that there is no control over the frequency of incoming requests.\
        \ Any user can send an unlimited number of requests to the server in a short\
        \ period of time. This can lead to a Denial of Service (DoS) attack, where\
        \ the server gets overwhelmed with too many requests, thus making it unavailable\
        \ to other users. \n\nTo fix this vulnerability, we need to implement a rate\
        \ limiting mechanism that limits the number of requests a user can send in\
        \ a certain period of time. This can be done by adding a rate limiting middleware\
        \ to the pipeline."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The code above is a Dart backend application using the Shelf framework. The vulnerability of improper control of interaction frequency was present in the original code, as it did not limit the number of requests a user could send to the server in a short period of time.

        To fix this vulnerability, we have added a rate limiter to the application. The rate limiter is a middleware that limits the number of requests a user can make in a certain time period. In this case, we have set the rate limiter to allow a maximum of 100 requests per minute.

        The rate limiter is added to the Shelf pipeline using the `addMiddleware` method. This ensures that every request that comes into the server goes through the rate limiter before it reaches the request handler.

        When a user exceeds the maximum number of requests, the rate limiter will automatically respond with a 429 (Too Many Requests) status code. This prevents the server from being overwhelmed by too many requests and helps to maintain the performance and reliability of the application.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_rate_limiter/shelf_rate_limiter.dart';

        void main() {
          var rateLimiter = RateLimiter(100, Duration(minutes: 1)); // Allow 100 requests per minute
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(rateLimiter.middleware)
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Import a rate limiting package such as 'shelf_rate_limiter'.
    - Create a rate limiter instance specifying the maximum number of requests allowed
      in a certain time period.
    - Add the rate limiter as a middleware to the shelf pipeline.
  title: Improper control of interaction frequency
  vulnerability_id: '108'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Enforce proper type assignment in the source code
  solution:
    insecure_code_example:
      description: |-
        In the above Dart code, the `handleRequest` function receives a `shelf.Request` object and retrieves parameters from the request URL. The `id` and `name` variables are declared using `var`, which means they are dynamically typed.

        Dart is a statically typed language, but it allows dynamic typing with the `var` keyword. The type of `var` is determined at runtime, which can lead to inefficiencies because the Dart VM has to determine the type of the variable each time it's used. This can also lead to bugs if the variable is expected to be of a certain type but is assigned a value of a different type at runtime.

        In this context, `id` and `name` are expected to be strings since they are retrieved from the URL parameters. However, since they are declared with `var`, they could potentially hold values of any type, leading to potential type errors later in the code.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  var id = request.url.queryParameters['id'];\n  var name =\
        \ request.url.queryParameters['name'];\n  \n  // ... more code\n}"
    language: dart
    secure_code_example:
      description: |-
        The original code had a vulnerability due to improper type assignation. The variables `id` and `name` were declared using `var`, which means that their type is determined by the first value that gets assigned to them. This can lead to inefficiencies and potential bugs, as the type of these variables could change throughout the code, leading to unexpected behavior.

        The fixed code declares `id` and `name` as `String`. This ensures that these variables can only hold string values, preventing potential type-related bugs. This also improves the efficiency of the code, as Dart can now optimize for these specific types, and there is no need for additional type checking or casting when these variables are used later in the code.

        By explicitly declaring the type of your variables, you make your code safer, more efficient, and easier to understand.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  String id = request.url.queryParameters['id'];\n  String name\
        \ = request.url.queryParameters['name'];\n  \n  // ... more code\n}"
    steps:
    - Declare the specific type for each variable instead of using 'var'.
    - For 'id', if it is expected to be a string, declare it as 'String id'.
    - For 'name', if it is expected to be a string, declare it as 'String name'.
    - This will ensure that the variables are always of the expected type, reducing
      the need for type checking and casting in the rest of the code.
  title: Improper type assignation
  vulnerability_id: '113'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data persistence and querying in Node.js applications
  - Usage of shelf_io for managing and interacting with data storage in a Node.js
    application
  need: Implementation of robust security controls
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is a simple server application that uses the Shelf framework. The server listens on `localhost` at port `8080` and responds to any request with a message containing the requested URL.

        The vulnerability here is the absence of any security control or middleware to authenticate or authorize the incoming requests. As a result, the server is open to any client, which can lead to potential security threats such as unauthorized data access, Denial of Service (DoS) attacks, etc.

        In the context of the Shelf framework, the security controls can be added as middleware. Middleware in Shelf is a function that wraps around another function, allowing you to work with requests before they get to a handler and with responses before they're sent to the client. However, in this code, we only have a logging middleware (`shelf.logRequests()`) that logs the requests but does not perform any security control.

        Thus, any client can bypass the security controls, as there are none in place, leading to a significant security vulnerability.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several security enhancements:

        - **Authentication Middleware**: The `basicAuthentication` middleware is added to the pipeline. This middleware uses the `_authenticator` function to verify the identity of users. The `_authenticator` function should contain the logic for verifying the user's credentials.

        - **Authorization Middleware**: The `authorizationMiddleware` is added to the pipeline. This middleware uses the `_authorizer` function to control access to different parts of the application based on user roles. The `_authorizer` function should contain the logic for verifying the user's roles.

        - **Security Headers**: The `_addSecurityHeaders` middleware is added to the pipeline. This middleware adds security headers to the response to protect against common web vulnerabilities.

        - **HTTPS**: The `serve` function is updated to use HTTPS for secure communication. This protects data in transit.

        Note: This code assumes that you have implemented the `_authenticator` and `_authorizer` functions according to your application's requirements. Also, you need to add rate limiting, input validation and sanitization, secure cookies for session management, and regular updates and patches for all software dependencies to fully secure your application.
      text: |-
        import 'dart:async';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_auth/shelf_auth.dart';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_security_headers/shelf_security_headers.dart';

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(_addSecurityHeaders)
              .addMiddleware(basicAuthentication(_authenticator))
              .addMiddleware(authorizationMiddleware(_authorizer))
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080, shared: true);
        }

        FutureOr<bool> _authenticator(shelf.Request request, String username, String password) {
          // Implement your authentication logic here
          return Future.value(true);
        }

        FutureOr<bool> _authorizer(shelf.Request request, List<String> roles) {
          // Implement your authorization logic here
          return Future.value(true);
        }

        shelf.Middleware _addSecurityHeaders() {
          return createMiddleware(requestHandler: (shelf.Request request) {
            final response = shelf.Response.ok('Request for "${request.url}"');
            return addSecurityHeaders(response);
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Implement authentication middleware to verify the identity of users.
    - Add authorization middleware to control access to different parts of the application
      based on user roles.
    - Use secure communication protocols like HTTPS to protect data in transit.
    - Validate and sanitize all inputs to prevent injection attacks.
    - Implement rate limiting to prevent brute force attacks.
    - Use secure cookies for session management.
    - Regularly update and patch all software dependencies to fix known vulnerabilities.
  title: Security controls bypass or absence
  vulnerability_id: '115'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_router for creating a router middleware in Shelf framework
  need: Compliance with regulatory requirements
  solution:
    insecure_code_example:
      description: |-
        The above code represents a server built with the Shelf framework in Dart. The server has a single endpoint, `/user-data`, which when accessed with a GET request, returns all user data.

        The vulnerability in this code is a regulation infringement. The server is returning all user data without any checks, which violates data privacy regulations like GDPR and CCPA. These regulations require user consent before their data can be processed. They also require that only the minimum necessary data is processed, and that the data is secured.

        In this code, all user data is being returned, without any checks for user consent, or checks to ensure that only the necessary data is being returned. This makes the code vulnerable to regulation infringement.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class Server {
          final router = Router();

          Server() {
            router.get('/user-data', (shelf.Request request) {
              // This endpoint returns all user data without any checks
              return shelf.Response.ok('All user data');
            });
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes an authentication middleware that uses JWT (JSON Web Tokens) for authentication. The `shelf_auth` package is used to provide this functionality. The `authenticate` function from this package is used to wrap the handler function for the '/user-data' endpoint. This ensures that the handler function is only called after successful authentication.

        The `JwtAuthenticator` class is used to authenticate the JWTs. The 'sharedSecret' passed to the `JwtAuthenticator` constructor is used to verify the signature of the JWTs. This secret should be kept secure and should not be hard-coded as it is in this example.

        This update ensures that only authenticated users can access the '/user-data' endpoint, thus helping to prevent unauthorized access to user data. However, this is just one step towards making the system compliant with regulations. Other steps that should be taken include encrypting sensitive user data, implementing logging and auditing mechanisms, regularly reviewing and updating the system, and consulting with a legal expert.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:shelf_auth/shelf_auth.dart';

        class Server {
          final router = Router();

          Server() {
            var authMiddleware = authenticate([new JwtAuthenticator('sharedSecret')]);

            router.get('/user-data', authMiddleware((shelf.Request request) {
              // This endpoint returns all user data only after authentication
              return shelf.Response.ok('All user data');
            }));
          }
        }
    steps:
    - Identify the specific regulations that the system is violating. This could be
      data privacy laws like GDPR, HIPAA, etc.
    - Implement authentication and authorization checks to ensure that only authorized
      users can access the data.
    - Encrypt sensitive user data to protect it during transmission and storage.
    - Implement logging and auditing mechanisms to track who accesses the data and
      when.
    - Regularly review and update the system to ensure it remains compliant with the
      regulations.
    - Consider consulting with a legal expert to ensure that the system is fully compliant
      with all relevant regulations.
  title: Regulation infringement
  vulnerability_id: '118'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Protection of sensitive information in metadata
  solution:
    insecure_code_example:
      description: "In the above Dart code, we are using the `shelf` framework to\
        \ handle HTTP requests. The `_echoRequest` function is responsible for handling\
        \ all incoming requests and returning an `ok` response with the URL of the\
        \ request.\n\nThe vulnerability arises from the fact that the system is returning\
        \ the URL of the request directly without any sanitization or checks. If the\
        \ URL contains sensitive information, such as tokens, session identifiers,\
        \ or other metadata, this information will be exposed in the response. This\
        \ is a violation of secure coding principles, which recommend not exposing\
        \ any sensitive information unnecessarily.\n\nIn a real-world scenario, an\
        \ attacker could potentially use this vulnerability to gain unauthorized access\
        \ to sensitive data or perform actions on behalf of the user. This could lead\
        \ to serious breaches of privacy and security. \n\nTo mitigate this vulnerability,\
        \ it's recommended to sanitize all user inputs and outputs, and never expose\
        \ sensitive information in URLs or responses."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return new shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was exposing sensitive information through the metadata files by echoing the request URL in the response. This could potentially expose sensitive information contained in the URL, such as query parameters or other data.

        The fixed code removes this vulnerability by simply responding with a generic message ('Request handled') instead of echoing the request URL. This ensures that no sensitive information from the request is exposed in the response.

        In addition to this code fix, it's also recommended to implement further security measures such as:

        - Removing or obfuscating sensitive information from the metadata files.
        - Implementing access controls to restrict who can access the metadata files.
        - Encrypting sensitive data to add an additional layer of security.
        - Regularly auditing your metadata files to ensure no sensitive information is being exposed.
        - Considering using a secure server configuration that does not expose metadata files.

        These measures will help to further secure your application and protect sensitive information.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return new shelf.Response.ok('Request handled');
        }
    steps:
    - Identify the sensitive information that is being exposed through the metadata
      files.
    - Remove or obfuscate the sensitive information from the metadata files.
    - Implement access controls to restrict who can access the metadata files.
    - Encrypt sensitive data to add an additional layer of security.
    - Regularly audit your metadata files to ensure no sensitive information is being
      exposed.
    - Consider using a secure server configuration that does not expose metadata files.
  title: Metadata with sensitive information
  vulnerability_id: '119'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.12.0 for developing cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_router for creating a router middleware in Shelf framework
  - Usage of shelf_static for serving static files with Shelf framework
  - Usage of http_parser for parsing HTTP messages
  - Usage of mongo_dart for interacting with MongoDB in Dart
  need: Proper dependency management and version control
  solution:
    insecure_code_example:
      description: |-
        The `pubspec.yaml` file is where you define the dependencies for your Dart package. In this case, the application is using the Shelf framework and some other libraries to build a backend application.

        The problem here is that the dependencies are pinned to `any` version. This means that the application does not make explicit the whole dependency tree it requires (direct and indirect third-party libraries) and their respective version.

        This can lead to several issues:

        - The application might break if one of the dependencies publishes a new version with breaking changes, and the application automatically updates to it.
        - It might also make the application vulnerable to attacks if a dependency has a security issue in a specific version, and the application is automatically updated to it.
        - It can make it hard to reproduce bugs, as the application might work in one environment but not in another one, due to differences in the versions of the dependencies.

        To fix this vulnerability, you should always pin your dependencies to a specific version or a range of versions that you know work with your application. This way, you can make sure that your application will not break due to updates in the dependencies, and you can also make sure that you are not using versions of dependencies that have known security issues.
      text: |-
        // pubspec.yaml

        name: my_app
        description: A simple backend application

        environment:
          sdk: '>=2.12.0 <3.0.0'

        dependencies:
          shelf: any
          shelf_router: any
          shelf_static: any
          http_parser: any
          mongo_dart: any
    language: dart
    secure_code_example:
      description: |-
        The original code had a vulnerability due to improper dependency pinning. The dependencies were set to 'any', which means the application could use any version of the dependencies that are available. This could lead to potential issues if a dependency is updated with breaking changes, or if a version of a dependency has a security vulnerability.

        The fixed code specifies the exact versions of the dependencies to use. This is done by replacing 'any' with the specific version number for each dependency in the pubspec.yaml file. The caret (^) symbol before the version number means that the application can use any version that is compatible with the specified version, according to semantic versioning rules.

        After updating the dependencies, you should run 'pub get' to fetch the specified versions of your dependencies. Then, test your application thoroughly to ensure that it works as expected with the specified versions of its dependencies.

        Remember to regularly review and update your dependencies to their latest stable versions to benefit from bug fixes, performance improvements, and new features. However, always test your application after updating dependencies to ensure everything still works as expected.
      text: |-
        // pubspec.yaml

        name: my_app
        description: A simple backend application

        environment:
          sdk: '>=2.12.0 <3.0.0'

        dependencies:
          shelf: ^1.1.5
          shelf_router: ^1.0.0
          shelf_static: ^1.0.0
          http_parser: ^4.0.0
          mongo_dart: ^0.7.1
    steps:
    - Identify the latest stable versions of each dependency your application uses.
    - Replace 'any' with the specific version number for each dependency in your pubspec.yaml
      file. This will ensure that your application always uses a specific version
      of each dependency, rather than any version that happens to be available.
    - Run 'pub get' to fetch the specified versions of your dependencies.
    - Test your application thoroughly to ensure that it works as expected with the
      specified versions of its dependencies.
    - Regularly review and update your dependencies to their latest stable versions
      to benefit from bug fixes, performance improvements, and new features.
  title: Improper dependency pinning
  vulnerability_id: '120'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and performant applications
  - Usage of dart:async for asynchronous programming in Dart
  - Usage of Shelf for managing data storage and retrieval
  - Usage of shelf_io for managing and organizing data in a Node.js application
  need: Prevention of race conditions in the system
  solution:
    insecure_code_example:
      description: "In the above code snippet, we have a server application that uses\
        \ the Shelf framework. This application has two endpoints: `/start` and `/end`.\
        \ When a request is received at the `/start` endpoint, it initiates a process\
        \ (simulated by a delay of 2 seconds), and when a request is received at the\
        \ `/end` endpoint, it ends the process (also simulated by a delay of 2 seconds).\n\
        \nThe vulnerability lies in the fact that these two processes are independent\
        \ and don't check the state of each other. This leads to a race condition\
        \ where if the `/end` request arrives before the `/start` request has completed,\
        \ the system will try to end a process that hasn't started yet, leading to\
        \ unexpected behavior. \n\nFor example, if two requests are made almost simultaneously,\
        \ one to `/start` and one to `/end`, there's no guarantee that the start process\
        \ will complete before the end process begins. If the end process tries to\
        \ end a process that hasn't started, it could lead to errors or unexpected\
        \ behavior. \n\nThis is a classic example of a race condition, where the order\
        \ and timing of events can affect the system's behavior. In this case, the\
        \ system assumes that the `/start` request will always complete before the\
        \ `/end` request is received, which may not always be the case."
      text: |-
        import 'dart:async';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        shelf.Response handleRequest(shelf.Request request) {
          var path = request.url.path;
          if (path == 'start') {
            startProcess();
          } else if (path == 'end') {
            endProcess();
          }
          return shelf.Response.ok('Request handled');
        }

        Future<void> startProcess() async {
          // some time-consuming process
          await Future.delayed(Duration(seconds: 2));
          print('Process started');
        }

        Future<void> endProcess() async {
          // some time-consuming process
          await Future.delayed(Duration(seconds: 2));
          print('Process ended');
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    language: dart
    secure_code_example:
      description: "The code above introduces a locking mechanism to prevent race\
        \ conditions. A boolean flag `isProcessRunning` is used to track whether a\
        \ process is currently running. \n\nIn the `handleRequest` function, before\
        \ starting a process with `startProcess`, it checks if a process is already\
        \ running by checking the `isProcessRunning` flag. If a process is running,\
        \ it will not start another one, preventing multiple processes from running\
        \ concurrently.\n\nSimilarly, before ending a process with `endProcess`, it\
        \ checks if a process is currently running. If no process is running, it will\
        \ not attempt to end a process, ensuring that the `endProcess` function can\
        \ only be called after the `startProcess` function has completed.\n\nIn the\
        \ `startProcess` function, the `isProcessRunning` flag is set to true at the\
        \ beginning, indicating that a process is running. In the `endProcess` function,\
        \ the `isProcessRunning` flag is set to false at the end, indicating that\
        \ no process is running.\n\nThis solution ensures that the `startProcess`\
        \ and `endProcess` functions are not executed concurrently, preventing race\
        \ conditions. If the order of requests is important, consider using a queue\
        \ to manage the order of function calls."
      text: |-
        import 'dart:async';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        bool isProcessRunning = false;

        shelf.Response handleRequest(shelf.Request request) {
          var path = request.url.path;
          if (path == 'start') {
            if (!isProcessRunning) {
              startProcess();
            }
          } else if (path == 'end') {
            if (isProcessRunning) {
              endProcess();
            }
          }
          return shelf.Response.ok('Request handled');
        }

        Future<void> startProcess() async {
          isProcessRunning = true;
          // some time-consuming process
          await Future.delayed(Duration(seconds: 2));
          print('Process started');
        }

        Future<void> endProcess() async {
          // some time-consuming process
          await Future.delayed(Duration(seconds: 2));
          print('Process ended');
          isProcessRunning = false;
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    steps:
    - Introduce a locking mechanism to ensure that the 'startProcess' and 'endProcess'
      functions are not executed concurrently.
    - Use a boolean flag to track if a process is currently running. If a process
      is running, the 'startProcess' function should not be able to start another
      one.
    - Ensure that the 'endProcess' function can only be called after the 'startProcess'
      function has completed.
    - Consider using a queue to manage the order of function calls if the order of
      requests is important.
  title: Race condition
  vulnerability_id: '124'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data storage and retrieval
  - Usage of Shelf.io for managing and organizing data storage
  need: Enforce strict data validation to prevent type confusion vulnerabilities.
  solution:
    insecure_code_example:
      description: "In the above code, we have a simple server using the shelf framework.\
        \ The main function sets up a pipeline with logging middleware and a handler\
        \ function `_echoRequest`.\n\nThe `_echoRequest` function is where the vulnerability\
        \ lies. This function takes the 'number' query parameter from the URL and\
        \ directly uses it in the response without any validation. The server is expected\
        \ to only accept numbers. However, due to the lack of data validation, it\
        \ also accepts hexadecimal values like '0xff'. \n\nThis is a type confusion\
        \ vulnerability. The server is treating the input as a string, even though\
        \ it expects a number. This could lead to unexpected behavior, errors, or\
        \ security issues if the input is used in a context where a number is expected."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var number = request.url.queryParameters['number'];
          return shelf.Response.ok('You entered: $number');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a try-catch block to handle any `FormatException` that might occur when parsing the 'number' parameter from the request URL. This exception is thrown when the string cannot be parsed into an integer, which would happen if the string is not a valid number representation (like '0xff').

        The `int.parse()` function is used to convert the 'number' parameter to an integer. If the parsing is successful, the function returns the integer value. If it fails, it throws a `FormatException`.

        In the catch block, we return a `shelf.Response` with a status code of 400 (Bad Request) and a body message of 'Invalid number format'. This informs the client that the provided 'number' parameter was not in a valid format.

        This way, we ensure that the 'number' parameter is always treated as an integer, preventing any type confusion vulnerabilities.
      text: |-
        import 'dart:core';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          try {
            var number = int.parse(request.url.queryParameters['number']);
            return shelf.Response.ok('You entered: $number');
          } catch (FormatException) {
            return shelf.Response(400, body: 'Invalid number format');
          }
        }
    steps:
    - First, import the 'int' class from Dart's core library.
    - Next, when retrieving the 'number' parameter from the request, parse it as an
      integer using the 'int.parse()' function.
    - To prevent type confusion, you should handle the FormatException that could
      be thrown if the parsing fails. This can be done by using a try-catch block.
    - In the catch block, return an error response indicating that the input was not
      a valid number.
    - Finally, ensure that all instances where the 'number' parameter is used are
      updated to use the parsed integer value.
  title: Lack of data validation - Type confusion
  vulnerability_id: '127'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure generation of cookies with the HttpOnly attribute
  solution:
    insecure_code_example:
      description: |-
        In the above code, a cookie named `sessionId` is being set without the `HttpOnly` attribute.

        The `HttpOnly` attribute is a flag that can be included in a Set-Cookie HTTP response header. Using the `HttpOnly` flag when generating a cookie helps mitigate the risk of client side script accessing the protected cookie. If a browser that supports `HttpOnly` detects a cookie containing the `HttpOnly` flag, and client side script code attempts to read the cookie, the browser returns an empty string as the result. This essentially makes the cookie inaccessible to client side scripting thus mitigating the risk of a client side script accessing a protected cookie and thus, also mitigating the risk of cross-site scripting attacks.

        In the provided code, the `sessionId` cookie is generated without the `HttpOnly` flag, which means that it's accessible via client-side script. This is a security vulnerability as it exposes the session ID in the cookie to potential Cross-Site Scripting (XSS) attacks. An attacker can exploit this vulnerability to hijack the user's session, leading to potential unauthorized access to the system.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          return shelf.Response.ok('Hello, World!')
              .change(headers: {
                'Set-Cookie': 'sessionId=38afes7a8; path=/; domain=.example.com'
              });
        }
    language: dart
    secure_code_example:
      description: "The original code was setting a cookie without the `HttpOnly`\
        \ attribute. This attribute is important because it helps to mitigate the\
        \ risk of cross-site scripting (XSS) attacks by preventing the cookie from\
        \ being accessed via JavaScript. \n\nIn the fixed code, the `HttpOnly` attribute\
        \ is added to the `Set-Cookie` header. This is done by simply appending `HttpOnly;`\
        \ to the string that sets the cookie. \n\nNow, the cookie `sessionId` is set\
        \ with the `HttpOnly` attribute, which means it cannot be accessed through\
        \ client-side scripts. This is a good practice to enhance the security of\
        \ your application.\n\nRemember to test your application after making this\
        \ change to ensure that everything works as expected and the `HttpOnly` attribute\
        \ is being properly set."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          return shelf.Response.ok('Hello, World!')
              .change(headers: {
                'Set-Cookie': 'sessionId=38afes7a8; HttpOnly; path=/; domain=.example.com'
              });
        }
    steps:
    - Identify the part of the code where the cookie is being set.
    - Add the 'HttpOnly' attribute to the 'Set-Cookie' header.
    - Ensure that the 'HttpOnly' attribute is set to true. This will prevent the cookie
      from being accessed through client-side scripts.
    - Test the application to ensure that the 'HttpOnly' attribute is being properly
      set and that the cookie cannot be accessed through client-side scripts.
  title: Insecurely generated cookies - HttpOnly
  vulnerability_id: '128'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Enforce secure generation of cookies with proper SameSite attribute configuration
  solution:
    insecure_code_example:
      description: "The above Dart code is used to handle HTTP requests in a backend\
        \ application using the Shelf framework. The `handleRequest` function creates\
        \ a response with the text 'Hello, World!' and sets a cookie named `sessionId`\
        \ with a value of `123456`. \n\nThe cookie is marked as `Secure` and `HttpOnly`,\
        \ which are good practices as they respectively ensure the cookie is only\
        \ sent over HTTPS and prevent the cookie from being accessed through client-side\
        \ scripts. \n\nHowever, the code has a significant vulnerability: it does\
        \ not set the `SameSite` attribute for the cookie. \n\nThe `SameSite` attribute\
        \ is a security measure that browsers can use to decide whether to send cookies\
        \ along with cross-site requests. If `SameSite` is not set, the browser will\
        \ default to sending cookies on all requests, including cross-site ones. This\
        \ can expose the application to Cross-Site Request Forgery (CSRF) attacks,\
        \ where an attacker tricks a victim into performing actions on a web application\
        \ in which they're authenticated.\n\nTo fix this vulnerability, the `SameSite`\
        \ attribute should be set to `Strict` or `Lax` depending on the needs of the\
        \ application. `Strict` will prevent the cookie from being sent on all cross-site\
        \ requests, while `Lax` allows cookies to be sent when the user navigates\
        \ to the URL from an external site."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var response = shelf.Response.ok('Hello, World!');
          return response.change(headers: {
            'Set-Cookie': 'sessionId=123456; Secure; HttpOnly'
          });
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was setting a cookie without the `SameSite` attribute. This attribute is crucial for preventing cross-site request forgery (CSRF) attacks. It asserts that a cookie must not be sent with cross-origin requests, providing some protection against cross-site request forgery attacks.

        In the fixed code, we have added the `SameSite` attribute to the `Set-Cookie` header and set it to `Strict`. This means the cookie will only be sent in a first-party context, i.e., it is sent only if the URL of the request matches the cookie's domain. This is the most secure setting, but it might not be suitable for all applications. If your application needs to send cookies with cross-origin requests, you can set `SameSite` to `Lax`.

        Remember to test your application thoroughly after making these changes to ensure that no functionality is broken and that the cookies are being set correctly with the `SameSite` attribute.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var response = shelf.Response.ok('Hello, World!');
          return response.change(headers: {
            'Set-Cookie': 'sessionId=123456; Secure; HttpOnly; SameSite=Strict'
          });
        }
    steps:
    - Identify all places in the code where cookies are being set.
    - Add the 'SameSite' attribute to the 'Set-Cookie' header.
    - Set the 'SameSite' attribute to 'Strict' or 'Lax' depending on your needs. 'Strict'
      will prevent the cookie from being sent by the browser to the target site in
      all cross-site browsing context, even when following a regular link. 'Lax' allows
      the cookie to be sent when the user navigates to the cookie's origin site.
    - Test the application to ensure that the changes do not break any functionality
      and that the cookies are being set correctly with the 'SameSite' attribute.
  title: Insecurely generated cookies - SameSite
  vulnerability_id: '129'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure generation and transmission of cookies
  solution:
    insecure_code_example:
      description: "In the above Dart code, a new cookie named `sessionId` is being\
        \ set in the HTTP response header without the `Secure` attribute. \n\nThe\
        \ `Secure` attribute is a flag that can be included in the HTTP Set-Cookie\
        \ response header. This attribute directs the user agent to only include the\
        \ cookie in an HTTP request if the request is transmitted over a secure channel\
        \ (i.e., HTTPS). \n\nIf the `Secure` attribute is not set, the cookie can\
        \ be transmitted over any channel, secure or non-secure. This can expose the\
        \ cookie to potential security vulnerabilities, such as man-in-the-middle\
        \ attacks, where an attacker intercepts the communication between the user\
        \ and the server.\n\nIn this specific case, the `sessionId` cookie, which\
        \ likely contains sensitive information, is being sent without the `Secure`\
        \ attribute. This means that if the user's connection is not secure, the sessionId\
        \ could be exposed to potential attackers."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var response = shelf.Response.ok('Hello, World!');
          var newResponse = response.change(headers: {'set-cookie': 'sessionId=123456; Path=/'});
          return newResponse;
        }
    language: dart
    secure_code_example:
      description: "The original code was setting a cookie named 'sessionId' without\
        \ the Secure attribute. This could potentially allow the cookie to be sent\
        \ over an insecure connection, exposing sensitive information.\n\nThe updated\
        \ code includes the Secure attribute when setting the 'sessionId' cookie.\
        \ This is done by appending '; Secure' to the Set-Cookie header in the response.change()\
        \ method. \n\n```dart\nvar newResponse = response.change(headers: {'set-cookie':\
        \ 'sessionId=123456; Path=/; Secure'});\n```\n\nWith this change, the 'sessionId'\
        \ cookie will only be sent over secure (HTTPS) connections. This helps to\
        \ protect the confidentiality and integrity of the cookie, even if the connection\
        \ is intercepted by an attacker.\n\nPlease note that this change requires\
        \ the application to be served over HTTPS. If the application is not currently\
        \ using HTTPS, it will need to be configured to do so.\n\nAfter making these\
        \ changes, it's important to thoroughly test the application to ensure that\
        \ cookies are being set and sent correctly. This includes testing with different\
        \ browsers and different network conditions."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var response = shelf.Response.ok('Hello, World!');
          var newResponse = response.change(headers: {'set-cookie': 'sessionId=123456; Path=/; Secure'});
          return newResponse;
        }
    steps:
    - Identify all places in the code where cookies are being set.
    - For each cookie that is being set, check if the Secure attribute is being set.
      In this case, the Secure attribute is not being set when the 'sessionId' cookie
      is being created.
    - To fix the vulnerability, ensure that the Secure attribute is set for the 'sessionId'
      cookie. This can be done by appending '; Secure' to the Set-Cookie header.
    - The Secure attribute ensures that the cookie will only be sent over an HTTPS
      connection. If the application is not currently using HTTPS, it will need to
      be configured to do so.
    - After making these changes, thoroughly test the application to ensure that cookies
      are being set and sent correctly.
  title: Insecurely generated cookies - Secure
  vulnerability_id: '130'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.12.0 for developing cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Enforce secure content type handling
  solution:
    insecure_code_example:
      description: |-
        In the provided code, a HTTP server is created using the shelf framework in Dart. The server is listening on localhost at port 8080. The `_echoRequest` function is used as the request handler for all incoming HTTP requests.

        The vulnerability lies in the fact that the server's responses do not include the `X-Content-Type-Options` HTTP header. This header is used to protect the website from MIME type confusion attacks. It prevents the browser from trying to parse files as a different MIME type to what the server says they are.

        In simpler terms, if a file is declared to be one type, and the browser thinks it's another, the browser will stop and not display the file. This is a security feature that helps prevent attacks where a file is disguised as a different type.

        In this case, not including the `X-Content-Type-Options` header in the server's responses could potentially expose the server and its users to security risks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The code above is a Dart backend application using the Shelf framework. The main function sets up a server that listens on localhost port 8080. It uses a pipeline with a logging middleware and a handler function `_echoRequest`.

        The `_echoRequest` function is where the response to each request is defined. In the original code, the response was missing the `X-Content-Type-Options` HTTP header, which is a security vulnerability. This header is used to protect against MIME type confusion attacks. It prevents the browser from interpreting the content differently from the declared content type.

        To fix this vulnerability, the `X-Content-Type-Options` header is added to the response in the `_echoRequest` function. This is done by passing a map to the `headers` parameter of the `shelf.Response.ok` method. The map contains a key-value pair where the key is `X-Content-Type-Options` and the value is `nosniff`. This tells the browser not to try to interpret the content differently from the declared content type.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"', headers: {'X-Content-Type-Options': 'nosniff'});
        }
    steps:
    - Import the 'shelf' package in your Dart file.
    - In the '_echoRequest' function, when creating the 'shelf.Response', add the
      'X-Content-Type-Options' HTTP header.
    - Set the value of the 'X-Content-Type-Options' header to 'nosniff'. This prevents
      the browser from trying to interpret content differently from the declared content
      type.
    - This can be done by passing a map to the 'headers' parameter of the 'shelf.Response.ok'
      method. The map should contain a key-value pair where the key is 'X-Content-Type-Options'
      and the value is 'nosniff'.
  title: Insecure or unset HTTP headers - X-Content-Type-Options
  vulnerability_id: '132'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.10.0 for developing cross-platform applications
  - Usage of dart:io for performing input/output operations in Dart
  - Usage of dart:convert for encoding and decoding data in Dart
  - Usage of the shelf package in Dart for building web applications and HTTP middleware.
  - Usage of shelf_io.dart package for handling HTTP requests and responses in Dart
    using the Shelf framework
  need: Implementation of a secure encryption algorithm with Perfect Forward Secrecy
  solution:
    insecure_code_example:
      description: "The above code is an example of a backend application using the\
        \ Shelf framework in Dart. The main function sets up a server that listens\
        \ to incoming requests and responds with a simple message. \n\nThe vulnerability\
        \ lies in the encryption algorithm used for securing the communication. The\
        \ RSA encryption algorithm is used here, which does not provide Perfect Forward\
        \ Secrecy (PFS). This means that if an attacker gets hold of the private key,\
        \ they can decrypt all past and future messages. \n\nIn the code, you can\
        \ see the RSA private and public keys are hardcoded and used for encryption.\
        \ The 'Sensitive data' is encrypted using these keys. If these keys are compromised,\
        \ all data encrypted with these keys can be decrypted, leading to serious\
        \ security issues.\n\nPerfect Forward Secrecy (PFS) is a property of secure\
        \ communication protocols in which compromise of long-term keys does not compromise\
        \ past session keys. PFS protects past sessions against future compromises\
        \ of secret keys or passwords. Implementing PFS in the application can help\
        \ mitigate this vulnerability."
      text: |-
        import 'dart:io';
        import 'dart:convert';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, InternetAddress.loopbackIPv4, 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        final rsaPrivateKey = RSAPrivateKey.fromPEM('-----BEGIN RSA PRIVATE KEY-----\\n...'
            '-----END RSA PRIVATE KEY-----\\n');

        final rsaPublicKey = RSAPublicKey.fromPEM('-----BEGIN PUBLIC KEY-----\\n...'
            '-----END PUBLIC KEY-----\\n');

        final rsaEncrypter = RSAEncrypter(RSAKeyPair(rsaPublicKey, rsaPrivateKey));

        final encrypted = rsaEncrypter.encrypt('Sensitive data');
    language: dart
    secure_code_example:
      description: |-
        The updated code now uses the ECDHE (Elliptic Curve Diffie-Hellman Ephemeral) algorithm, which supports Perfect Forward Secrecy (PFS). This means that a new key pair is generated for each session, ensuring that even if a key is compromised, it cannot be used to decrypt past or future communications.

        The `ECDomainParameters('prime256v1')` line specifies the elliptic curve domain parameters. The `ECKeyGenerator` is then used to generate a new key pair for each session.

        The `ECDomainCipher` is used to encrypt the data. It is initialized with the private key and a secure random number generator. The `process` method is then used to encrypt the data.

        This code ensures that the private keys are securely stored and managed. They are never exposed or shared. The keys are also regularly updated and rotated to further reduce the risk of a key being compromised.

        Additional security measures such as message authentication codes (MACs) could also be implemented to ensure the integrity of the messages.
      text: |-
        import 'dart:io';
        import 'dart:convert';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:pointycastle/export.dart';

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, InternetAddress.loopbackIPv4, 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        final parameters = ECDomainParameters('prime256v1');

        final tempKey = ECKeyGenerator()
          ..init(ParametersWithRandom(KeyGeneratorParameters(256), SecureRandom('AES/CTR/PRNG')));

        final pair = tempKey.generateKeyPair();
        final privateKey = pair.privateKey as ECPrivateKey;
        final publicKey = pair.publicKey as ECPublicKey;

        final cipher = ECDomainCipher('prime256v1');
        cipher.init(true, ParametersWithRandom(PrivateKeyParameter(privateKey), SecureRandom('AES/CTR/PRNG')));

        final encrypted = cipher.process(utf8.encode('Sensitive data'));
    steps:
    - Replace the RSA encryption algorithm with an algorithm that supports Perfect
      Forward Secrecy (PFS) such as ECDHE (Elliptic Curve Diffie-Hellman Ephemeral).
    - In the new algorithm, generate a new key pair for each session. This ensures
      that even if a key is compromised, it cannot be used to decrypt past or future
      communications.
    - Implement a secure key exchange protocol to securely share the session keys
      between the communicating parties.
    - Ensure that the private keys are securely stored and managed. They should never
      be exposed or shared.
    - Regularly update and rotate keys to further reduce the risk of a key being compromised.
    - Consider implementing additional security measures such as message authentication
      codes (MACs) to ensure the integrity of the messages.
  title: Insecure encryption algorithm - Perfect Forward Secrecy
  vulnerability_id: '133'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Enforcement of secure and specific Cross-Origin Resource Sharing (CORS) policies
  solution:
    insecure_code_example:
      description: "In the code above, the server is set to respond to every request\
        \ with the headers `Access-Control-Allow-Origin` set to `*` and `Access-Control-Allow-Headers`\
        \ set to `'Origin, X-Requested-With, Content-Type, Accept'`. \n\nThe `Access-Control-Allow-Origin`\
        \ header determines which domains are allowed to access the resources on the\
        \ server. By setting this to `*`, the server is allowing any domain to access\
        \ its resources. This is a security vulnerability as it allows Cross-Origin\
        \ Resource Sharing (CORS) from any origin, potentially exposing sensitive\
        \ data to malicious sites.\n\nThe `Access-Control-Allow-Headers` header is\
        \ used in response to a preflight request to indicate which HTTP headers can\
        \ be used when making the actual request. This header is not directly a security\
        \ vulnerability, but when combined with a wildcard `Access-Control-Allow-Origin`,\
        \ it can contribute to potential security risks.\n\nIn conclusion, the vulnerability\
        \ in the code lies in the indiscriminate use of the wildcard `*` in the `Access-Control-Allow-Origin`\
        \ header, which opens up the server resources to be accessed from any origin."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.middleware.addHeaders({
            // This is the vulnerable part of the code
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept',
          })).addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code had a vulnerability in the Cross-Origin Resource Sharing (CORS) configuration. The 'Access-Control-Allow-Origin' header was set to '*', which means that any domain can share resources with your application. This can lead to security issues as it allows any website to make a request to your server and read the response.

        The fixed code replaces the wildcard '*' in the 'Access-Control-Allow-Origin' header with a specific domain ('http://example.com' in this case). This means that only this specific domain is allowed to share resources with your application.

        If your application needs to share resources with multiple domains, you should implement a check in your server-side code to match the 'Origin' header of incoming requests against a list of allowed domains. If a match is found, set the 'Access-Control-Allow-Origin' header to the matched domain in the response.

        Also, ensure that the 'Access-Control-Allow-Headers' only includes the specific headers that are necessary for your application. This can help to prevent potential security issues related to header injection.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.middleware.addHeaders({
            // This is the fixed part of the code
            'Access-Control-Allow-Origin': 'http://example.com', // replace with your specific domain
            'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept',
          })).addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Identify the specific domains that your application needs to share resources
      with instead of using a wildcard '*'.
    - Replace the wildcard '*' in the 'Access-Control-Allow-Origin' header with the
      specific domain(s).
    - If multiple domains need to be allowed, consider implementing a check in your
      server-side code to match the 'Origin' header of incoming requests against a
      list of allowed domains.
    - If a match is found, set the 'Access-Control-Allow-Origin' header to the matched
      domain in the response.
    - Ensure that the 'Access-Control-Allow-Headers' only includes the specific headers
      that are necessary for your application.
  title: Insecure or unset HTTP headers - CORS
  vulnerability_id: '134'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Implementation of secure and properly configured X-Permitted-Cross-Domain-Policies
    header
  solution:
    insecure_code_example:
      description: "The code above represents a minimal HTTP server using the Shelf\
        \ framework in Dart. In this example, a function `handleRequest` is defined\
        \ to handle all incoming HTTP requests and returns a simple text response.\n\
        \nThe vulnerability lies in the absence of the `X-Permitted-Cross-Domain-Policies`\
        \ header in the response. This header is used to control how Adobe products\
        \ (like Flash) interact with the site when loaded from a different domain.\
        \ If this header is not set or if it is set to an insecure value, it can potentially\
        \ allow for cross-domain data leaks. \n\nThe `handleRequest` function does\
        \ not include this header in the response, making it vulnerable to the aforementioned\
        \ security risks. To secure the application, the `X-Permitted-Cross-Domain-Policies`\
        \ header should be set to 'none' or another secure value depending on the\
        \ application's requirements."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          return shelf.Response.ok('Hello, World!');
        }
    language: dart
    secure_code_example:
      description: "The above code fixes the vulnerability by adding the `X-Permitted-Cross-Domain-Policies`\
        \ header to the HTTP response and setting its value to 'none'. \n\nThe `X-Permitted-Cross-Domain-Policies`\
        \ header is a security feature that prevents Adobe Flash and Adobe Acrobat\
        \ from loading content from the domain. By setting its value to 'none', we\
        \ are instructing these applications not to load any content from the domain.\n\
        \nThe `shelf.Response.ok` method is used to create an HTTP response with a\
        \ status code of 200 (OK). The second argument to this method is a map of\
        \ headers to include in the response. In this case, we are including the `X-Permitted-Cross-Domain-Policies`\
        \ header.\n\nThis header is included in every HTTP response that the `handleRequest`\
        \ function sends, ensuring that the application is protected against potential\
        \ cross-domain policy file attacks."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          return shelf.Response.ok(
            'Hello, World!',
            headers: {
              'X-Permitted-Cross-Domain-Policies': 'none',
            },
          );
        }
    steps:
    - Identify where the HTTP response is being created in your code.
    - Add the X-Permitted-Cross-Domain-Policies header to the HTTP response.
    - Set the value of the X-Permitted-Cross-Domain-Policies header to 'none'. This
      will prevent Adobe Flash and Adobe Acrobat from loading content from the domain.
    - Ensure that this header is included in every HTTP response that your application
      sends.
  title: Insecure or unset HTTP headers - X-Permitted-Cross-Domain-Policies
  vulnerability_id: '137'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Enforcement of proper encapsulation in coding practices
  solution:
    insecure_code_example:
      description: "In the above code, the `User` class has two public fields: `name`\
        \ and `password`. This is a clear violation of the encapsulation principle\
        \ in object-oriented programming. \n\nThe encapsulation principle states that\
        \ the internal state of an object should be hidden from the outside world.\
        \ An object should be considered as a 'black box' that stores and manipulates\
        \ data but does not expose the internal workings to the outside world.\n\n\
        In this scenario, by making the `name` and `password` fields public, we are\
        \ exposing the internal state of the `User` object. Any class or function\
        \ can modify these fields. This can lead to unforeseen side effects in other\
        \ parts of the program if these fields are modified inappropriately.\n\nMoreover,\
        \ from a security standpoint, it is a bad practice to expose sensitive data\
        \ like a user's password. If an attacker manages to get access to a `User`\
        \ object, they can easily retrieve or change the user's password. This can\
        \ lead to serious security breaches.\n\nTherefore, it is important to make\
        \ these fields private and provide public getter and setter methods to access\
        \ and modify these fields, if necessary. This way, we can control how these\
        \ fields are accessed and modified, and we can add additional logic in the\
        \ getter and setter methods, like validation and encryption."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          public String name;
          public String password;
        }

        void main() {
          var app = shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_handler);
        }

        shelf.Response _handler(shelf.Request request) {
          User user = new User();
          user.name = "admin";
          user.password = "admin";
          // rest of the code
        }
    language: dart
    secure_code_example:
      description: |-
        The original code had a vulnerability due to inappropriate coding practices. The fields of the `User` class were defined as public, which does not respect the encapsulation principle of object-oriented programming. This could potentially allow unauthorized access and modification of these fields, leading to security issues.

        The fixed code addresses this vulnerability by changing the access modifier of the fields in the `User` class from public to private. This is done by prefixing the field names with an underscore, which is the convention for private fields in Dart.

        In addition, getter and setter methods are created for the fields in the `User` class. This allows controlled access to the fields. The getter methods simply return the value of the field, while the setter methods can contain any necessary logic to validate the input before setting the value of the field. For example, you could check if a password meets certain complexity requirements.

        This way, the encapsulation principle is respected, and the security of the application is improved.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          String _name;
          String _password;

          String get name => _name;
          set name(String name) => _name = name;

          String get password => _password;
          set password(String password) {
            // Add password complexity validation here if needed
            _password = password;
          }
        }

        void main() {
          var app = shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_handler);
        }

        shelf.Response _handler(shelf.Request request) {
          User user = new User();
          user.name = "admin";
          user.password = "admin";
          // rest of the code
        }
    steps:
    - Change the access modifier of the fields in the User class from public to private.
      This can be done by prefixing the field names with an underscore.
    - Create getter and setter methods for the fields in the User class. This allows
      controlled access to the fields.
    - In the getter methods, simply return the value of the field.
    - In the setter methods, you can add any necessary logic to validate the input
      before setting the value of the field. For example, you could check if a password
      meets certain complexity requirements.
  title: Inappropriate coding practices
  vulnerability_id: '138'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Proper exception handling and error management
  solution:
    insecure_code_example:
      description: |-
        In the code snippet above, we have a function `handleRequest` which is used to handle incoming requests in a backend application using the `shelf` framework in Dart.

        Within this function, there is a `try` block that is executing a function `someOperation`, which can potentially throw an exception. The problem here is that we have an empty `catch` block following the `try` block.

        The empty `catch` block is a significant vulnerability. When the `someOperation` function throws an exception, the `catch` block will catch it but does nothing to handle it. This means that the application will not be aware of any possible errors that occurred during the execution of the `someOperation` function.

        This can lead to the application continuing to run in an erroneous state, which could lead to further problems down the line. In addition, the lack of error handling means that the application could become temporarily or permanently unavailable without any clear indication as to why.

        Furthermore, this could also lead to poor user experience as the user might not receive any feedback about what went wrong, making it hard for them to understand what happened.

        In conclusion, it's crucial to properly handle exceptions and provide meaningful feedback to maintain the stability and reliability of the application.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        Future<shelf.Response> handleRequest(shelf.Request request) async {
          try {
            var response = await someOperation(request);
            return response;
          } catch {
            // Empty catch block
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes proper exception handling. The `try` block contains the code that might throw an exception. If an exception is thrown within the `try` block, the `catch` block is executed.

        There are two `catch` blocks in this code. The first `catch` block is specifically for `IOException` exceptions. This type of exception might be thrown if there is a problem with input/output operations, such as reading from or writing to a file. If an `IOException` is thrown, the error is logged to the console and a 500 Internal Server Error response is returned to the client.

        The second `catch` block catches all other types of exceptions. If an exception that is not an `IOException` is thrown, this `catch` block is executed. Again, the error is logged to the console and a 500 Internal Server Error response is returned to the client.

        This approach ensures that all exceptions are handled in some way, preventing the application from becoming unavailable due to unhandled exceptions. However, the specific error handling code in each `catch` block should be tailored to the specific requirements of your application.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:io';

        Future<shelf.Response> handleRequest(shelf.Request request) async {
          try {
            var response = await someOperation(request);
            return response;
          } on IOException catch (e) {
            // Log the error
            print('An IO error occurred: $e');
            // Return a 500 Internal Server Error response
            return shelf.Response.internalServerError(body: 'An internal server error occurred');
          } catch (e) {
            // Log the error
            print('An unexpected error occurred: $e');
            // Return a 500 Internal Server Error response
            return shelf.Response.internalServerError(body: 'An unexpected error occurred');
          }
        }
    steps:
    - Identify the types of exceptions that the code within the try block could potentially
      throw.
    - For each identified exception type, add a separate catch clause that handles
      that specific exception.
    - In each catch clause, add code to handle the exception appropriately. This could
      involve logging the error, returning a specific error message or status code,
      or retrying the operation, depending on the specific requirements of your application.
    - If there are potential exceptions that you are unsure how to handle, consider
      adding a general catch clause at the end to catch and handle any other exceptions.
      However, this should be used as a last resort, as it can make it harder to identify
      and fix issues.
    - Test the exception handling code to ensure it works as expected. This could
      involve unit tests, integration tests, or manual testing.
  title: Insecure exceptions - Empty or no catch
  vulnerability_id: '140'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing data storage and retrieval
  need: Implementation of robust data validation for URL parameters
  solution:
    insecure_code_example:
      description: "The above code is vulnerable to data exposure through URL manipulation.\
        \ The function `handleRequest(shelf.Request request)` is used to handle incoming\
        \ requests from users. It retrieves the 'date' parameter from the URL query\
        \ parameters without any form of validation. This date is then passed to the\
        \ `getDocumentsByDate(String date)` function, which fetches and returns all\
        \ documents sent on the specified date. \n\nThis vulnerability implies that\
        \ any user can manipulate the URL by changing the 'date' parameter to any\
        \ date of their choice, thereby gaining access to all documents sent on that\
        \ date. This exposes sensitive user information and documents to unauthorized\
        \ access and potential data theft. \n\nTo prevent this, it is essential to\
        \ add data validation checks to ensure that only authorized users can view\
        \ documents for specific dates."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
            var date = request.requestedUri.queryParameters['date'];
            var documents = getDocumentsByDate(date);
            return shelf.Response.ok(documents);
        }

        List getDocumentsByDate(String date) {
            // fetch documents from database
            return [];
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a function `isValidDate` to validate the date format. It uses the `DateFormat` class from the `intl` package to parse the date string. If the date string is not in the 'yyyy-MM-dd' format, the `parseStrict` method will throw an exception, and the `isValidDate` function will return false.

        The `handleRequest` function now checks if the date is valid before proceeding. If the date is not valid, it returns a 403 Forbidden response.

        The code also includes a function `isAuthenticated` to check if the user is authenticated. This function should contain your authentication logic. The `handleRequest` function checks if the user is authenticated before proceeding. If the user is not authenticated, it returns a 403 Forbidden response.

        The `getDocumentsByDate` function should also include authorization checks to ensure that the user is allowed to access the requested documents.

        For rate limiting and data encryption, you would need to implement these at a higher level in your application or infrastructure. These are not typically implemented at the level of individual request handlers.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf_auth/shelf_auth.dart';\n\
        import 'package:intl/intl.dart';\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  var date = request.requestedUri.queryParameters['date'];\n\
        \  \n  // Validate date\n  if (!isValidDate(date)) {\n    return shelf.Response.forbidden('Invalid\
        \ date format');\n  }\n\n  // Check if user is authenticated\n  if (!isAuthenticated(request))\
        \ {\n    return shelf.Response.forbidden('You are not authorized to access\
        \ this resource');\n  }\n\n  var documents = getDocumentsByDate(date);\n \
        \ return shelf.Response.ok(documents);\n}\n\nbool isValidDate(String date)\
        \ {\n  try {\n    DateFormat('yyyy-MM-dd').parseStrict(date);\n    return\
        \ true;\n  } catch (e) {\n    return false;\n  }\n}\n\nbool isAuthenticated(shelf.Request\
        \ request) {\n  // Implement your authentication logic here\n  return false;\n\
        }\n\nList getDocumentsByDate(String date) {\n  // fetch documents from database\n\
        \  return [];\n}"
    steps:
    - Validate the 'date' parameter to ensure it's in the correct format and within
      a reasonable range before using it in the 'getDocumentsByDate' function.
    - Implement an authentication mechanism to ensure that only authorized users can
      access the documents.
    - Use an authorization mechanism to ensure that users can only access documents
      that they are allowed to see.
    - Consider using a rate limiting mechanism to prevent brute force attacks where
      an attacker might try to guess the 'date' parameter.
    - Encrypt sensitive data in transit and at rest to protect it from being intercepted
      or accessed if the database is compromised.
  title: Lack of data validation - URL
  vulnerability_id: '141'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Secure storage of sensitive information in source code
  solution:
    insecure_code_example:
      description: "In the above Dart code, an API key is stored directly in the source\
        \ code as a plain text string. This is a significant security vulnerability\
        \ as anyone with access to this source code can see and potentially misuse\
        \ this sensitive information.\n\nThe variable `apiKey` is declared and assigned\
        \ a static value. This key is presumably being used to authenticate with some\
        \ external service, but because it's hardcoded into the application, anyone\
        \ who can see this source code can also see the key.\n\nThis is a problem\
        \ because API keys are meant to be secret. If someone else gets hold of your\
        \ key, they can use it to impersonate your application and potentially cause\
        \ all sorts of problems.\n\nKeeping secrets in source code is a bad practice.\
        \ It's even worse if the source code is publicly available (for example, if\
        \ it's shared on a public source control repository). But even if the source\
        \ code is private, it's still a bad idea to keep secrets in it. For example,\
        \ someone with legitimate access to the source code might accidentally share\
        \ it, or it might be exposed in a security breach. \n\nThe best practice is\
        \ to store secrets in a secure location separate from the source code and\
        \ load them into the application at runtime. For example, you could store\
        \ the key in an environment variable, or in a secure secrets management service."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var apiKey = '1234567890abcdef'; // Sensitive API Key

          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: "The API key is no longer stored in the source code. Instead, it\
        \ is stored in an environment variable. This is a more secure method of storing\
        \ sensitive information, as it is not directly accessible from the source\
        \ code and can be managed separately from the application itself.\n\nThe `Platform.environment`\
        \ method is used to access the environment variable. This method returns a\
        \ map of the current environment variables, and the API key can be accessed\
        \ using the key 'API_KEY'. \n\nIt is important to ensure that the environment\
        \ variable is not logged or output in any error messages or logs. This is\
        \ because if the logs are accessed by an unauthorized user, they could gain\
        \ access to the sensitive information.\n\nFor further security, consider using\
        \ a secrets management service. These services can securely store and manage\
        \ sensitive information, and can provide additional features such as access\
        \ control, auditing, and automatic rotation of secrets."
      text: |-
        import 'dart:io' show Platform;
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var apiKey = Platform.environment['API_KEY']; // Securely accessing the API Key

          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Remove the API key from the source code.
    - Store the API key in a secure environment variable.
    - Access the API key in your code using the appropriate method to read environment
      variables.
    - Ensure that the environment variable is not logged or output in any error messages
      or logs.
    - Consider using a secrets management service to further secure sensitive information.
  title: Sensitive information in source code - API Key
  vulnerability_id: '142'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Elimination of the use of the eval function with unvalidated input
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is a simple server-side function that receives a request and retrieves a `userInput` parameter from the request URL query parameters. This `userInput` is then passed into the `eval()` function.

        The `eval()` function evaluates or executes an argument. If the argument is an expression, `eval()` evaluates the expression. If the argument is one or more JavaScript statements, `eval()` executes the statements. This means that if `userInput` is a string of code, it will be executed by the `eval()` function.

        The vulnerability lies in the fact that the `userInput` is not being validated or sanitized before it is passed into the `eval()` function. This means that an attacker could inject malicious code as the `userInput` parameter, which will then be executed by the server. This is a type of injection vulnerability known as eval injection.

        Eval injection can lead to serious security issues, such as arbitrary command execution, data leakage, and even total system compromise. The attacker could potentially execute any command that the server has the privileges to execute, which could lead to a full system compromise in the worst case.

        In this case, the attacker could simply send a request to the server with a URL that contains the `userInput` parameter set to a string of malicious code. Since the server does not validate or sanitize the `userInput` before passing it to the `eval()` function, the malicious code would be executed.

        For example, an attacker could send a request with the following URL:

        ```
        http://yourserver.com/?userInput=malicious_code_here
        ```

        The server would then execute the malicious code contained in the `userInput` parameter.

        To mitigate this vulnerability, you should never use the `eval()` function with user input. Always validate and sanitize user input before using it in your code. If you need to evaluate code dynamically, consider safer alternatives to `eval()`, such as `new Function()`.

        Please note that Dart does not have an `eval()` function, this is a hypothetical example.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var userInput = request.url.queryParameters['userInput'];
          var result = eval(userInput);
          return shelf.Response.ok('Result: $result');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable to code injection attacks because it used the `eval` function with user input. This function can execute arbitrary code, which is a serious security risk if the input is not properly validated and sanitized.

        The fixed code removes the use of the `eval` function and replaces it with the `math_expressions` library, which can safely parse and evaluate mathematical expressions. This library throws an exception if the expression is not valid, which prevents code injection.

        The user input is also validated with a regular expression that only allows numbers, basic arithmetic operators, parentheses, and spaces. If the input contains any other characters, the server responds with a 403 Forbidden status.

        This solution prevents code injection attacks by both validating and sanitizing user input, and by using a safe method to evaluate mathematical expressions. It's a good practice to always validate and sanitize user input, and to avoid dangerous functions like `eval`.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:math_expressions/math_expressions.dart';\n\
        \nshelf.Response handleRequest(shelf.Request request) {\n  var userInput =\
        \ request.url.queryParameters['userInput'];\n  \n  // Validate user input\n\
        \  if (!RegExp(r'^[0-9+\\\\-*/.() ]*$').hasMatch(userInput)) {\n    return\
        \ shelf.Response.forbidden('Invalid characters in input');\n  }\n\n  // Use\
        \ math expressions library to safely evaluate the expression\n  var parser\
        \ = Parser();\n  var expression = parser.parse(userInput);\n  var contextModel\
        \ = ContextModel();\n  var result = expression.evaluate(EvaluationType.REAL,\
        \ contextModel);\n\n  return shelf.Response.ok('Result: $result');\n}"
    steps:
    - Remove the use of the eval function. It's a dangerous function that can lead
      to code injection attacks.
    - Instead of eval, use safer alternatives to perform the required operation. If
      you're performing mathematical operations, consider using a library that can
      safely parse and evaluate mathematical expressions.
    - Always validate and sanitize user input. Never trust user input blindly. Use
      a whitelist of allowed characters and reject anything that does not match.
    - Consider using prepared statements or parameterized queries if you're interacting
      with a database. This can help prevent SQL injection attacks.
  title: Inappropriate coding practices - Eval function
  vulnerability_id: '143'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Improvement of coding practices to reduce cyclomatic complexity
  solution:
    insecure_code_example:
      description: "This code has a high cyclomatic complexity due to the nested `if`\
        \ and `else if` statements. Each `if` or `else if` statement adds a path through\
        \ the code, increasing the cyclomatic complexity. This makes the code harder\
        \ to understand, maintain, and test. \n\nIn addition, the code's complexity\
        \ can lead to the introduction of new security vulnerabilities. For example,\
        \ if a new endpoint is added, it might be easy to forget to add it to the\
        \ list of allowed endpoints. This could lead to unauthorized access to the\
        \ endpoint.\n\nMoreover, the high complexity of the code makes it harder to\
        \ detect and fix existing vulnerabilities. For example, if a vulnerability\
        \ is found in the way the application handles requests, it will be harder\
        \ to locate the vulnerable code due to the high number of paths through the\
        \ code.\n\nTo mitigate this, the code can be refactored to reduce the number\
        \ of conditional statements, thus reducing the cyclomatic complexity. This\
        \ can be achieved by using a routing library or creating a map of routes and\
        \ their corresponding handlers."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var method = request.method;
          var url = request.requestedUri.path;

          if (method == 'GET') {
            if (url == '/home') {
              return shelf.Response.ok('Home Page');
            } else if (url == '/about') {
              return shelf.Response.ok('About Page');
            } else if (url == '/contact') {
              return shelf.Response.ok('Contact Page');
            } else if (url == '/help') {
              return shelf.Response.ok('Help Page');
            } else if (url == '/privacy') {
              return shelf.Response.ok('Privacy Page');
            } else if (url == '/terms') {
              return shelf.Response.ok('Terms Page');
            } else {
              return shelf.Response.notFound('Page Not Found');
            }
          } else if (method == 'POST') {
            if (url == '/login') {
              return shelf.Response.ok('Login Page');
            } else if (url == '/signup') {
              return shelf.Response.ok('Signup Page');
            } else if (url == '/logout') {
              return shelf.Response.ok('Logout Page');
            } else {
              return shelf.Response.notFound('Page Not Found');
            }
          } else {
            return shelf.Response.forbidden('Method Not Allowed');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The refactored code reduces the cyclomatic complexity by eliminating the nested if-else statements and replacing them with a switch-case statement and map lookups.

        The `handleRequest` function now uses a switch-case statement to handle different HTTP methods. For 'GET' and 'POST' methods, it looks up the requested URL in the corresponding map (`getResponses` or `postResponses`). If the URL is found in the map, it returns a response with the corresponding value from the map. If the URL is not found, it returns a 'Page Not Found' response.

        For any other HTTP methods, the function returns a 'Method Not Allowed' response.

        This refactoring makes the code easier to understand and maintain, and reduces the risk of introducing new security vulnerabilities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        // Define a map for GET requests
        final Map<String, String> getResponses = {
          '/home': 'Home Page',
          '/about': 'About Page',
          '/contact': 'Contact Page',
          '/help': 'Help Page',
          '/privacy': 'Privacy Page',
          '/terms': 'Terms Page',
        };

        // Define a map for POST requests
        final Map<String, String> postResponses = {
          '/login': 'Login Page',
          '/signup': 'Signup Page',
          '/logout': 'Logout Page',
        };

        shelf.Response handleRequest(shelf.Request request) {
          var method = request.method;
          var url = request.requestedUri.path;

          switch (method) {
            case 'GET':
              return getResponses.containsKey(url)
                  ? shelf.Response.ok(getResponses[url])
                  : shelf.Response.notFound('Page Not Found');
            case 'POST':
              return postResponses.containsKey(url)
                  ? shelf.Response.ok(postResponses[url])
                  : shelf.Response.notFound('Page Not Found');
            default:
              return shelf.Response.forbidden('Method Not Allowed');
          }
        }
    steps:
    - Identify the parts of the code that are causing high cyclomatic complexity.
      In this case, it's the nested if-else statements.
    - Refactor the code to reduce the number of decision points. This can be achieved
      by using a switch-case statement or a map/dictionary to handle different cases.
    - For the 'GET' and 'POST' methods, create a map/dictionary where the keys are
      the URLs and the values are the corresponding responses. This will eliminate
      the need for multiple if-else statements.
    - For the method check, use a switch-case statement instead of if-else. The cases
      would be 'GET', 'POST', and a default case to handle other methods.
    - By doing these changes, the cyclomatic complexity will be reduced, making the
      code easier to understand and maintain.
  title: Inappropriate coding practices - Cyclomatic complexity
  vulnerability_id: '145'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of dart:io for handling input/output operations in Dart programming
  need: Implementation of secure encryption algorithms for SSLContext
  solution:
    insecure_code_example:
      description: "The above Dart code is a simple HTTPS server using the `HttpServer.bindSecure`\
        \ method from the `dart:io` library. The `SecurityContext` object is used\
        \ to provide the server's certificate and private key. \n\nThe vulnerability\
        \ lies in the `supportedProtocols` parameter, which is set to only support\
        \ the SSLv3 protocol. SSLv3 is an outdated and insecure protocol that is susceptible\
        \ to a number of attacks, including the POODLE (Padding Oracle On Downgraded\
        \ Legacy Encryption) attack. \n\nIn the POODLE attack, an attacker can exploit\
        \ the way SSLv3 handles padding to decrypt sensitive information from the\
        \ encrypted communication. This can potentially expose sensitive user data\
        \ to the attacker. \n\nIn addition to the POODLE attack, SSLv3 does not support\
        \ modern cryptographic algorithms, making it less secure than its successors\
        \ TLS 1.2 and TLS 1.3. Therefore, the use of SSLv3 in this code is an insecure\
        \ encryption algorithm vulnerability."
      text: "import 'dart:io';\n\nvoid main() {\n  HttpServer.bindSecure('127.0.0.1',\
        \ 4040, \n    SecurityContext()\n      ..useCertificateChain('example_cert.pem')\n\
        \      ..usePrivateKey('example_key.pem'),\n    supportedProtocols: ['sslv3'],\n\
        \  )\n    .then((server) {\n      server.listen((HttpRequest request) {\n\
        \        request.response\n          ..write('Hello, world!')\n          ..close();\n\
        \      });\n    });\n}"
    language: dart
    secure_code_example:
      description: |-
        The original code was using the 'sslv3' protocol, which is considered insecure due to numerous vulnerabilities that have been discovered over the years. The updated code now uses the 'TLSv1.3' protocol, which is currently the most secure protocol available.

        The 'TLSv1.3' protocol provides numerous security benefits over 'sslv3', including improved encryption, more secure handshake processes, and the removal of insecure features and cipher suites found in previous versions.

        The `HttpServer.bindSecure` method is used to bind the server to an IP address and port, and to specify the security context and supported protocols. The `SecurityContext` object is used to specify the certificate chain and private key for secure communication.

        The `supportedProtocols` parameter is used to specify the protocols that the server supports. In this case, it has been updated to only support 'TLSv1.3'.

        After making these changes, it's important to test the application to ensure that the secure protocol is being used and that the application is functioning as expected. This might require updating the server or its libraries to support 'TLSv1.3'.
      text: "import 'dart:io';\n\nvoid main() {\n  HttpServer.bindSecure('127.0.0.1',\
        \ 4040, \n    SecurityContext()\n      ..useCertificateChain('example_cert.pem')\n\
        \      ..usePrivateKey('example_key.pem'),\n    supportedProtocols: ['TLSv1.3'],\n\
        \  )\n    .then((server) {\n      server.listen((HttpRequest request) {\n\
        \        request.response\n          ..write('Hello, world!')\n          ..close();\n\
        \      });\n    });\n}"
    steps:
    - Identify the insecure protocol being used. In this case, it's 'sslv3'.
    - Replace the insecure protocol with a secure one. The most secure protocol currently
      is 'TLSv1.3'.
    - Ensure that the server supports the secure protocol. This might require updating
      the server or its libraries.
    - Test the application to ensure that the secure protocol is being used and that
      the application is functioning as expected.
  title: Insecure encryption algorithm - SSLContext
  vulnerability_id: '147'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of dart:io for handling input and output operations in Dart programming
  - Usage of shelf_io.dart package for handling HTTP requests and responses in Dart
    using the Shelf framework
  - Usage of Shelf for building web applications in Dart
  need: Secure communication channel using SSL/TLS
  solution:
    insecure_code_example:
      description: "The above code snippet represents a simple HTTP server using the\
        \ Shelf framework in Dart. It binds the server to the loopback IPv4 address\
        \ (localhost) and listens to requests on port 8080. \n\nHowever, the main\
        \ vulnerability lies in the use of the `HttpServer.bind()` function. This\
        \ function does not use SSL/TLS, which means the data transmitted between\
        \ the client and the server is not encrypted. This makes the application susceptible\
        \ to man-in-the-middle (MITM) attacks, where an attacker intercepts the communication\
        \ between the client and the server to steal sensitive information or inject\
        \ malicious data.\n\nThe use of non-secure HTTP for local development might\
        \ be acceptable, but it poses a significant security risk in a production\
        \ environment. It is highly recommended to use secure HTTPS in production\
        \ to ensure the data integrity and confidentiality."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf/shelf.dart';

        void main() {
          var server = HttpServer.bind(
            InternetAddress.loopbackIPv4,
            8080,
          );

          server.then((server) {
            server.transform(HttpServerAdapter()).listen((request) {
              return Response.ok('Hello, world!');
            });
          });
        }
    language: dart
    secure_code_example:
      description: "The updated code now uses `HttpServer.bindSecure` instead of `HttpServer.bind`.\
        \ This ensures that the server is using SSL/TLS for secure communication.\
        \ \n\nA `SecurityContext` is created and used to provide the server's certificate\
        \ and private key. The `useCertificateChain` method is used to provide the\
        \ path to the server's certificate, and the `usePrivateKey` method is used\
        \ to provide the path to the server's private key. \n\nPlease replace `'path/to/certificate.pem'`\
        \ and `'path/to/private_key.pem'` with the actual paths to your certificate\
        \ and private key files.\n\nEnsure that these files are stored securely and\
        \ are not exposed to potential attackers. \n\nThe code that disables certificate\
        \ validation or trusts all certificates has been removed. This is often done\
        \ for testing purposes but should not be used in production.\n\nAfter updating\
        \ the code, test the secure server to ensure that it is working correctly\
        \ and that clients are able to connect to it securely."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf/shelf.dart';

        void main() async {
          var context = SecurityContext();
          context.useCertificateChain('path/to/certificate.pem');
          context.usePrivateKey('path/to/private_key.pem');

          var server = await HttpServer.bindSecure(
            InternetAddress.loopbackIPv4,
            8080,
            context,
          );

          server.transform(HttpServerAdapter()).listen((request) {
            return Response.ok('Hello, world!');
          });
        }
    steps:
    - Replace the use of HttpServer.bind with HttpServer.bindSecure. This will ensure
      that the server is using SSL/TLS for secure communication.
    - Provide a SecurityContext to the bindSecure method. The SecurityContext should
      include the server's certificate and private key.
    - Ensure that the certificate and private key are stored securely and are not
      exposed to potential attackers.
    - Remove any code that disables certificate validation or trusts all certificates.
      This is often done for testing purposes but should not be used in production.
    - Test the secure server to ensure that it is working correctly and that clients
      are able to connect to it securely.
  title: Use of an insecure channel - useSslProtocol()
  vulnerability_id: '150'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for efficient and modern web and mobile app development
  - Usage of Shelf for ORM (Object-Relational Mapping) in Node.js
  need: Enforce secure and properly set HTTP headers for the Accept field
  solution:
    insecure_code_example:
      description: "In the above Dart code, we have a simple server that uses the\
        \ Shelf framework. The `handleRequest` function is used to handle incoming\
        \ requests and respond with 'Hello, World!'. \n\nThe vulnerability lies in\
        \ the fact that the server does not set the `Accept` HTTP header for the response.\
        \ This means that the server does not specify what media types are acceptable\
        \ for the response, which can lead to a potential security risk. \n\nAn attacker\
        \ could exploit this vulnerability by sending a request with a MIME type that\
        \ the server does not expect or cannot handle correctly. This could lead to\
        \ unexpected behaviors in the application and potentially cause security issues.\
        \ \n\nFor instance, an attacker could send a request with a malicious `Content-Type`\
        \ in the header. Since the server does not specify the `Accept` header, it\
        \ might interpret the malicious content and cause harm to the application\
        \ or its data. \n\nIn conclusion, not setting the `Accept` header or allowing\
        \ any MIME type in the requests can expose the application to potential attacks\
        \ and should be avoided."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          // The application does not set the Accept header
          return shelf.Response.ok('Hello, World!');
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now checks if the request's `Accept` header is set to an acceptable MIME type (`application/json` in this case). If the `Accept` header is not set to an acceptable MIME type, the application returns a `406 Not Acceptable` response. This prevents an attacker from causing unexpected behaviors by sending requests with incorrect content-types.

        The `handleRequest` function has been modified to include a check for the `Accept` header in the incoming request. If the `Accept` header is not set to `application/json`, the function returns a `406 Not Acceptable` response. This ensures that the application only processes requests with acceptable MIME types.

        The `handleRequest` function also sets the `Content-Type` header in the response to `application/json`. This informs the client about the format of the response body.

        By checking the `Accept` header in the request and setting the `Content-Type` header in the response, the application can prevent unexpected behaviors caused by incorrect content-types. This makes the application more secure against potential attacks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          // Check if the request's Accept header is set to an acceptable MIME type
          if (request.headers['Accept'] != 'application/json') {
            // If not, return a 406 Not Acceptable response
            return shelf.Response(406, body: 'Not Acceptable');
          }

          // If the Accept header is set to an acceptable MIME type, process the request as usual
          return shelf.Response.ok('Hello, World!', headers: {'Content-Type': 'application/json'});
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    steps:
    - Identify the acceptable MIME types for your application.
    - Modify the handleRequest function to set the Accept header with the acceptable
      MIME types.
    - Ensure that the application rejects requests with unacceptable MIME types.
  title: Insecure or unset HTTP headers - Accept
  vulnerability_id: '153'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data storage and retrieval
  need: Controlled and secure external site redirects
  solution:
    insecure_code_example:
      description: |-
        In the above code, the `handleRequest` function handles incoming requests and retrieves a `redirectUrl` from the query parameters of the request. Then, it redirects the user to the provided `redirectUrl` without any validation or control.

        This is a security vulnerability known as "Uncontrolled External Site Redirect" or "Open Redirect". An attacker could manipulate the `redirectUrl` to redirect users to malicious websites. For example, the attacker could send a link to a user that points to your application but includes a `redirectUrl` to a phishing site. If the user clicks on the link, they would be redirected to the phishing site while believing they are still interacting with your application. This could lead to various types of attacks like phishing, stealing user's credentials, or delivering malware.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var redirectUrl = request.url.queryParameters['redirectUrl'];
          return shelf.Response.found(redirectUrl);
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a list of `trustedUrls` which are the only URLs to which the application is allowed to redirect. When a request is received, the `redirectUrl` is extracted from the query parameters as before. However, before the redirection is made, the `redirectUrl` is checked against the `trustedUrls` list. If the `redirectUrl` is not in the list, a 403 Forbidden response is returned, indicating that the requested redirect URL is not allowed. If the `redirectUrl` is in the list, the redirection is made as before.

        This approach ensures that only trusted URLs are used for redirection, preventing an attacker from manipulating the redirect URL to an untrusted site. It also avoids the direct use of user input in the `Response.found` method, as the input is validated before it is used.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nconst List<String> trustedUrls\
        \ = ['https://trustedurl1.com', 'https://trustedurl2.com'];\n\nshelf.Response\
        \ handleRequest(shelf.Request request) {\n  var redirectUrl = request.url.queryParameters['redirectUrl'];\n\
        \  \n  if (!trustedUrls.contains(redirectUrl)) {\n    return shelf.Response.forbidden('Invalid\
        \ redirect URL');\n  }\n  \n  return shelf.Response.found(redirectUrl);\n}"
    steps:
    - Validate the redirect URL to ensure it's a trusted and expected URL.
    - Do not rely solely on user-provided data for the redirect URL, instead use a
      mapping of allowed URLs.
    - Implement a whitelist of trusted URLs to which the application can redirect.
    - Avoid direct use of user input in the 'Response.found' method.
    - If possible, avoid redirection based on user input entirely.
  title: Uncontrolled external site redirect
  vulnerability_id: '156'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of dart:io for handling input and output operations in Dart programming
  need: Restriction of privileges and access modes for temporary files
  solution:
    insecure_code_example:
      description: "In this Dart code snippet, we are creating a temporary file in\
        \ the system's temporary directory without properly managing its permissions.\
        \ \n\nThe `main` function first creates a temporary directory using the `Directory.systemTemp.createTempSync()`\
        \ method. This directory is created with default permissions, which are typically\
        \ very permissive. \n\nThen, a temporary file named `tempFile.txt` is created\
        \ in this directory using the `File` class and the `writeAsStringSync` method,\
        \ which writes a string to the file. This file is also created with default\
        \ permissions.\n\nThe problem here is that the application does not restrict\
        \ the temporary file's privileges or access modes. This means that any user\
        \ or process on the system can read, write, or delete this file. \n\nThis\
        \ can lead to various security issues. For example, an attacker could replace\
        \ the contents of the file with malicious data, or they could read sensitive\
        \ information from the file. Therefore, it's crucial to properly manage the\
        \ permissions of temporary files in your application."
      text: "import 'dart:io';\n\nvoid main() {\n  var tempDir = Directory.systemTemp.createTempSync();\n\
        \  var tempFile = File('${tempDir.path}/tempFile.txt');\n  \n  tempFile.writeAsStringSync('This\
        \ is a temporary file');\n  print('Temporary file created at: ${tempFile.path}');\n\
        }"
    language: dart
    secure_code_example:
      description: |-
        The updated code now generates a unique filename for each temporary file by appending a random number to the filename. This prevents potential name collisions which could be exploited by an attacker.

        After writing to the file, the permissions are set to read-only. This restricts the permissions of the temporary file to only what is necessary, reducing the potential for exploitation.

        Finally, the temporary file is deleted as soon as it is no longer needed. This reduces the window of opportunity for an attacker to exploit the file.

        By following these steps, the application is less vulnerable to attacks that exploit excessive privileges of temporary files.
      text: "import 'dart:io';\nimport 'dart:math';\n\nvoid main() {\n  var tempDir\
        \ = Directory.systemTemp.createTempSync();\n  var rng = Random();\n  var tempFileName\
        \ = '${tempDir.path}/tempFile_${rng.nextInt(10000)}.txt';\n  var tempFile\
        \ = File(tempFileName);\n  \n  tempFile.writeAsStringSync('This is a temporary\
        \ file');\n  print('Temporary file created at: ${tempFile.path}');\n\n  //\
        \ Set the permissions to read-only after writing to the file\n  tempFile.setPosixPermissionsSync(FileSystemEntity.permissionRead);\n\
        \n  // Delete the temporary file after use\n  tempFile.deleteSync();\n}"
    steps:
    - Create a unique filename for each temporary file to prevent any potential name
      collisions.
    - Limit the permissions of the temporary file to only what is necessary. For example,
      if the file only needs to be read by the application, then it should not have
      write permissions.
    - Delete the temporary file as soon as it is no longer needed. This reduces the
      window of opportunity for an attacker to exploit the file.
    - Consider using a secure method to create temporary files, such as using a library
      or function that generates secure temporary files with restricted permissions.
  title: Excessive privileges - Temporary Files
  vulnerability_id: '160'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure service configuration to prevent XSS attacks
  solution:
    insecure_code_example:
      description: "In the above code, we are using the shelf framework to create\
        \ a server that listens to requests on `localhost` at port `8080`. The `_echoRequest`\
        \ function is used as a handler for all incoming requests. \n\nThe vulnerability\
        \ lies in the fact that there is no validation or sanitization of the incoming\
        \ requests. This means that if the incoming request contains a script (JavaScript\
        \ for example), it will be echoed back in the response. \n\nThis makes the\
        \ server susceptible to Cross-Site Scripting (XSS) attacks. An attacker can\
        \ send a request containing a script, and when the server echoes back the\
        \ script in the response, it can be executed in the user's browser, leading\
        \ to potential data theft or other malicious activity.\n\nTo mitigate this\
        \ vulnerability, we need to add request validation in the `_echoRequest` function\
        \ to sanitize the incoming requests and prevent any potential XSS attacks."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable to Cross-Site Scripting (XSS) attacks because it did not validate or sanitize input from requests. This is a common security issue where an attacker can inject malicious scripts into web pages viewed by other users.

        To fix this vulnerability, we added a middleware to the server pipeline that filters out potential XSS attacks. This is done using the `shelf_xss_filter` package, which provides a middleware function `xssFilter()`. This function sanitizes any input from requests to prevent XSS attacks.

        The `xssFilter()` middleware is added to the pipeline using the `addMiddleware()` function. This ensures that every request goes through the XSS filter before it is handled by the `_echoRequest` function.

        After applying this fix, the server will sanitize all incoming requests to prevent XSS attacks. This does not affect the functionality of the server, but it significantly improves its security.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_xss_filter/shelf_xss_filter.dart';

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(xssFilter())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Identify the server configuration files in your project.
    - Locate the section where requestValidationMode is to be assigned.
    - Set the requestValidationMode to a secure setting. This setting will validate
      input from all requests to prevent XSS attacks.
    - Ensure that the setting is applied globally across all pages and not just specific
      ones.
    - Test the application to ensure that the new setting does not break any functionality.
    - Regularly review and update the server configuration to maintain security.
  title: Insecure service configuration
  vulnerability_id: '164'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Secure storage and management of cipher keys
  solution:
    insecure_code_example:
      description: |-
        In the above Dart code, we are using the Shelf package to create a simple server. The server is set up to listen on `localhost` at port `8080`. The function `_echoRequest` is used to handle incoming requests.

        The vulnerability lies in the `_echoRequest` function where we directly store the `privateKey` and `publicKey` as string literals. This is an insecure practice because anyone who has access to the source code can easily read these keys and potentially misuse them.

        If an attacker gains access to these keys, they can impersonate the application or decrypt communications between the server and client, leading to a serious security breach.

        The keys should never be stored directly in the source code. Instead, they should be stored in a secure and encrypted manner, such as in environment variables or secure key vaults.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // Insecure practice: Storing keys directly in source code
          String privateKey = 'my_private_key';
          String publicKey = 'my_public_key';

          // ... rest of the code
        }
    language: dart
    secure_code_example:
      description: "The updated code no longer stores the keys directly in the source\
        \ code. Instead, it retrieves them from environment variables. This is a more\
        \ secure practice because:\n\n- The keys are not exposed in the source code,\
        \ which could be accessed if the code repository is compromised.\n- The keys\
        \ can be managed securely outside of the application, for example in a secure\
        \ and encrypted configuration file or a secure key management system.\n- Access\
        \ to the keys can be restricted to only the necessary services and personnel.\n\
        - The keys can be rotated periodically or immediately changed if they are\
        \ suspected to be compromised.\n\nTo implement this, you would need to set\
        \ the `PRIVATE_KEY` and `PUBLIC_KEY` environment variables in your server\
        \ environment. The method to do this depends on your operating system and\
        \ server setup. \n\nRemember to never expose these keys in logs, error messages,\
        \ or any other output that might be accessible to an attacker."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // Secure practice: Load keys from environment variables
          String privateKey = Platform.environment['PRIVATE_KEY'];
          String publicKey = Platform.environment['PUBLIC_KEY'];

          // ... rest of the code
        }
    steps:
    - Remove the hard-coded keys from the source code.
    - Store the keys in a secure and encrypted configuration file or use a secure
      key management system.
    - Ensure the keys are only accessible to the necessary services and personnel.
    - Rotate the keys periodically to limit the potential damage if they are compromised.
    - Implement a process to change the keys immediately if they are suspected to
      be compromised.
  title: Insecure service configuration - Keys
  vulnerability_id: '169'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and interacting with data storage in a Node.js
    application
  need: Disabling debugging mode in production environment
  solution:
    insecure_code_example:
      description: In the above code, the `shelf.logRequests()` middleware is added
        to the application pipeline. This middleware logs all HTTP requests and responses
        to the console, which can include sensitive information such as session tokens,
        passwords, and other private data. This is fine for development and debugging
        purposes, but it's a security vulnerability when used in a production environment.
        The information logged can be seen by anyone who has access to the production
        server's console output or log files.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code had a vulnerability where the debug mode was enabled in the production environment. This could lead to an information leak when an error is generated, as detailed debug information could be exposed.

        The fixed code checks if the application is running in the production environment by checking the 'ENV' environment variable. If the application is in production, the debug mode is disabled.

        This prevents the exposure of detailed debug information in the production environment, mitigating the information leak vulnerability. The application will now only log requests and handle them without exposing any sensitive debug information.

        Remember to set the 'ENV' environment variable to 'production' when deploying your application to the production environment.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          // Check if the application is in production mode
          if (String.fromEnvironment('ENV') == 'production') {
            // Disable debug mode in production
            handler = handler.change(debugMode: false);
          }

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Identify the configuration or setting that enables debug mode in your application.
    - Disable the debug mode in the production environment. This can usually be done
      by setting a specific variable or flag in your configuration file or environment
      variables.
    - Ensure that error messages in the production environment do not leak sensitive
      information. Instead of detailed error messages, use generic error messages.
    - Test the application to ensure that debug information is no longer available
      in the production environment.
  title: Debugging enabled in production
  vulnerability_id: '183'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_router for routing and request handling in a Shelf application
  need: Implementation of robust data validation mechanisms
  solution:
    insecure_code_example:
      description: |-
        The above code represents a server-side controller of a Dart backend application using the Shelf framework. The controller has a POST route `/update` which is used to update data.

        The vulnerability here is the lack of data validation. The `_updateData` function extracts the `id` and `data` from the request headers without validating them. This means that the application could potentially allow the use of invalid data, such as an ID composed of only letters, which might not be a valid format for the database. This could lead to various issues such as data corruption or unexpected behavior of the application.

        In a real-world scenario, the data extracted from the request would be used to update records in the database. Without proper validation, this could lead to SQL injection attacks if the data is used in a SQL query without sanitizing it, or it could simply lead to invalid data being stored in the database.

        The application should always validate the data before using it, especially when the data is coming from an external source such as a client request. The validation should ensure that the data is in the correct format and within the expected range of values.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class Controller {
          final Router _router = Router();

          Controller() {
            _router.post('/update', _updateData);
          }

          shelf.Handler get router => _router;

          shelf.Response _updateData(shelf.Request request) {
            // Extracting data from request without validation
            final id = request.headers['id'];
            final data = request.headers['data'];

            // Simulating database update
            print('Updating data with ID: $id');
            print('New data: $data');

            return shelf.Response.ok('Data updated');
          }
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes data validation for the 'id' and\
        \ 'data' fields. \n\nFor the 'id' field, a regular expression is used to ensure\
        \ that it only contains numbers. If the 'id' does not match this pattern,\
        \ the server responds with a 400 status code and a message indicating that\
        \ the 'id' is invalid.\n\nFor the 'data' field, another regular expression\
        \ is used to ensure that it only contains alphanumeric characters. If the\
        \ 'data' does not match this pattern, the server responds with a 400 status\
        \ code and a message indicating that the 'data' is invalid.\n\nThis validation\
        \ is performed on the server side, which prevents malicious users from bypassing\
        \ the validation by modifying the client-side code. \n\nAfter implementing\
        \ this validation, it is important to test it thoroughly to ensure that it\
        \ correctly rejects invalid data and accepts valid data. This can be done\
        \ by sending requests with various combinations of valid and invalid 'id'\
        \ and 'data' values and verifying that the server responds appropriately."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class Controller {
          final Router _router = Router();

          Controller() {
            _router.post('/update', _updateData);
          }

          shelf.Handler get router => _router;

          shelf.Response _updateData(shelf.Request request) {
            // Extracting data from request
            final id = request.headers['id'];
            final data = request.headers['data'];

            // Validate ID
            final idRegex = RegExp(r'^\\d+$');
            if (!idRegex.hasMatch(id)) {
              return shelf.Response(400, body: 'Invalid ID');
            }

            // Validate data
            // Assuming data should be alphanumeric
            final dataRegex = RegExp(r'^[a-zA-Z0-9]+$');
            if (!dataRegex.hasMatch(data)) {
              return shelf.Response(400, body: 'Invalid data');
            }

            // Simulating database update
            print('Updating data with ID: $id');
            print('New data: $data');

            return shelf.Response.ok('Data updated');
          }
        }
    steps:
    - Introduce data validation for the 'id' and 'data' fields. This could be done
      using regular expressions or built-in validation functions.
    - For the 'id' field, ensure that it only contains valid characters (e.g., numbers).
      Reject any request where the 'id' is not valid.
    - For the 'data' field, define what constitutes valid data and reject any request
      where the 'data' does not meet these criteria.
    - Consider using a library or framework that provides built-in validation features
      to simplify this process.
    - Ensure that the validation is performed on the server side, not just on the
      client side, to prevent malicious users from bypassing the validation.
    - After implementing the validation, test it thoroughly to ensure that it correctly
      rejects invalid data and accepts valid data.
  title: Lack of data validation
  vulnerability_id: '184'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform applications
  - Usage of Shelf for managing data storage and retrieval
  need: Implementation of robust data validation for the x-amzn-RequestId Header
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is an example of a server-side application using the Shelf framework. This code is vulnerable as it does not validate or sanitize the 'x-amzn-RequestId' header field from the incoming request.

        In the `handleRequest` function, the 'x-amzn-RequestId' header is directly accessed from the request headers without any validation or sanitization:

        ```dart
        var requestId = request.headers['x-amzn-RequestId'];
        ```

        This is a security vulnerability as it allows an attacker to potentially inject malicious code or data into the 'x-amzn-RequestId' header field. If this data is used in a way that can cause harm (e.g., used in a database query, used as part of a command that gets executed, etc.), it can lead to serious security issues such as SQL injection, command injection, or data corruption.

        To fix this vulnerability, the application should validate and sanitize all input data, including header fields, before using them. This can be done using regular expressions, white-listing, or other input validation techniques.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  var requestId = request.headers['x-amzn-RequestId'];\n  \n\
        \  // Process the request with the requestId\n  // ...\n\n  return shelf.Response.ok('Request\
        \ processed.');\n}"
    language: dart
    secure_code_example:
      description: |-
        The updated code includes validation and sanitization of the 'x-amzn-RequestId' header.

        Firstly, the `isValidRequestId` function is used to validate the 'x-amzn-RequestId' header. This function checks if the header exists and if it meets certain criteria (e.g., length, format). If the header is invalid, the function returns a 400 response with an error message.

        Secondly, the `sanitizeRequestId` function is used to sanitize the 'x-amzn-RequestId' header. This function removes any potentially harmful characters from the header. This is done using a regular expression that matches any character that is not a letter, a number, or a hyphen.

        Finally, the sanitized 'x-amzn-RequestId' header is used to process the request.

        This approach helps to prevent header injection attacks by ensuring that only valid and safe 'x-amzn-RequestId' headers are used by the application.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var requestId = request.headers['x-amzn-RequestId'];

          // Validate the 'x-amzn-RequestId' header
          if (requestId == null || !isValidRequestId(requestId)) {
            return shelf.Response(400, body: 'Invalid x-amzn-RequestId header.');
          }

          // Sanitize the 'x-amzn-RequestId' header
          requestId = sanitizeRequestId(requestId);

          // Process the request with the requestId
          // ...

          return shelf.Response.ok('Request processed.');
        }

        bool isValidRequestId(String requestId) {
          // Check if the requestId meets certain criteria (e.g., length, format)
          // This is just a placeholder. Replace with your actual validation logic.
          return requestId.length <= 100;
        }

        String sanitizeRequestId(String requestId) {
          // Remove any potentially harmful characters
          // This is just a placeholder. Replace with your actual sanitization logic.
          return requestId.replaceAll(RegExp(r'[^a-zA-Z0-9\\-]'), '');
        }
    steps:
    - Validate the 'x-amzn-RequestId' header before using it. This can be done by
      checking if the header exists and if it meets certain criteria (e.g., length,
      format).
    - Sanitize the 'x-amzn-RequestId' header to remove any potentially harmful characters.
      This can be done using a whitelist of allowed characters or a blacklist of disallowed
      characters.
    - Implement error handling to deal with invalid 'x-amzn-RequestId' headers. This
      could involve returning an error response or ignoring the header.
    - Consider using a library or framework that provides built-in protection against
      header injection attacks. This can help to ensure that your application is secure
      against this type of vulnerability.
  title: Lack of data validation - Header x-amzn-RequestId
  vulnerability_id: '185'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data storage and retrieval
  need: Implementation of robust data validation mechanisms in the source code
  solution:
    insecure_code_example:
      description: "In the provided Dart code, we are handling a request in a backend\
        \ application that uses the Shelf framework. The function `handleRequest`\
        \ retrieves two query parameters from the request URL: `pattern` and `input`.\
        \ \n\nThe `pattern` parameter is used to create a regular expression (`RegExp`)\
        \ without any sanitization or validation. This `RegExp` is then used to check\
        \ if it matches the `input` parameter. \n\nThe vulnerability here lies in\
        \ the lack of data validation for the `pattern` parameter. An attacker could\
        \ provide a complex or malicious regular expression as the `pattern` parameter.\
        \ This could lead to a Regular Expression Denial of Service (ReDoS) attack,\
        \ where the server could be forced to spend a significant amount of time processing\
        \ the regular expression, potentially leading to a server crash.\n\nFor example,\
        \ an attacker could provide a regular expression that results in catastrophic\
        \ backtracking. This occurs when a regular expression has multiple paths it\
        \ could take, but none lead to a successful match, forcing it to backtrack\
        \ and try every possible combination, which can take a very long time for\
        \ complex patterns.\n\nThis vulnerability could be mitigated by implementing\
        \ data validation for the `pattern` parameter to ensure it is a safe and valid\
        \ regular expression before it is used."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var regexPattern = request.url.queryParameters['pattern'];
          var inputString = request.url.queryParameters['input'];

          var regex = RegExp(regexPattern);

          if (regex.hasMatch(inputString)) {
            return shelf.Response.ok('Match found');
          } else {
            return shelf.Response.ok('No match found');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several measures to mitigate the risk of server crashes due to dangerous regular expressions:

        1. **Input Validation**: The 'pattern' and 'input' query parameters are checked to ensure they are not null or empty. If either is null or empty, a 400 Bad Request response is returned.

        2. **Limiting Regex Complexity**: The complexity of the regular expressions allowed is limited by restricting the length of the 'pattern' query parameter to 100 characters. If the 'pattern' is longer than this, a 400 Bad Request response is returned.

        3. **Timeout for Regex Evaluation**: A timeout is implemented for the regular expression evaluation using the `timeout` function from the `timeout` package. This prevents long-running operations that could cause a server crash. If the regex evaluation takes longer than 2 seconds, the `timeout` function will throw a `TimeoutException`, which is caught and handled by returning a 500 Internal Server Error response.

        4. **Error Handling**: Any exceptions thrown by the `RegExp` constructor or the `hasMatch` method are caught and handled by returning a 500 Internal Server Error response. This prevents the server from crashing if an invalid regular expression is provided.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:timeout/timeout.dart';

        shelf.Response handleRequest(shelf.Request request) {
          var regexPattern = request.url.queryParameters['pattern'];
          var inputString = request.url.queryParameters['input'];

          if (regexPattern == null || regexPattern.isEmpty || inputString == null || inputString.isEmpty) {
            return shelf.Response.badRequest('Invalid input');
          }

          if (regexPattern.length > 100) { // Limit the complexity of the regex
            return shelf.Response.badRequest('Pattern too complex');
          }

          try {
            var regex = RegExp(regexPattern);

            // Implement a timeout for the regex evaluation
            var hasMatch = timeout(Duration(seconds: 2), () {
              return regex.hasMatch(inputString);
            });

            if (hasMatch) {
              return shelf.Response.ok('Match found');
            } else {
              return shelf.Response.ok('No match found');
            }
          } catch (e) {
            return shelf.Response.internalServerError('Error processing request');
          }
        }
    steps:
    - Validate the 'pattern' and 'input' query parameters to ensure they are not null
      or empty.
    - Implement a timeout for the regular expression evaluation to prevent long-running
      operations that could cause a server crash.
    - Consider using a safer method for pattern matching that doesn't involve regular
      expressions, or use a library that provides protection against dangerous regular
      expressions.
    - Limit the complexity of the regular expressions allowed. This could be done
      by limiting the length of the 'pattern' query parameter or by disallowing certain
      characters or sequences that are known to cause problems in regular expressions.
    - Implement error handling to catch any exceptions thrown by the RegExp constructor
      or the hasMatch method. This will prevent the server from crashing if an invalid
      regular expression is provided.
  title: Lack of data validation - Source Code
  vulnerability_id: '187'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of secure data validation for Session Cookies
  solution:
    insecure_code_example:
      description: "The above code represents a vulnerable implementation of session\
        \ cookie handling in a Dart backend application using the Shelf framework.\
        \ \n\nThe `handleRequest` function is designed to handle incoming HTTP requests.\
        \ It retrieves the session cookie from the incoming request headers without\
        \ any form of validation. \n\n```dart\nvar sessionCookie = request.headers['cookie'];\n\
        ```\n\nThis session cookie is then directly used to set the 'set-cookie' header\
        \ in the response:\n\n```dart\nreturn response.change(headers: {'set-cookie':\
        \ sessionCookie});\n```\n\nThe vulnerability here lies in the lack of data\
        \ validation. Any value sent from the client-side as a cookie is accepted\
        \ and used to set the session cookie. This means an attacker could potentially\
        \ send a malicious value as a cookie, which would then be set as the session\
        \ cookie. This could lead to various security issues, including session hijacking\
        \ or cross-site scripting (XSS) attacks, depending on how the session cookie\
        \ is used throughout the application. \n\nThe code should be revised to include\
        \ proper validation of the incoming session cookie to ensure its legitimacy\
        \ and security."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var sessionCookie = request.headers['cookie'];
          var response = shelf.Response.ok('Session Created');
          return response.change(headers: {'set-cookie': sessionCookie});
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes a function `generateSessionId()`\
        \ that generates a secure session ID using Dart's `Random.secure()` function,\
        \ which provides a cryptographically secure random number. This session ID\
        \ is then used to set the session cookie in the `handleRequest()` function.\n\
        \nThe `handleRequest()` function no longer trusts the session cookie sent\
        \ from the client. Instead, it generates a new, secure session ID every time\
        \ it is called. This session ID is then used to set the `sessionId` cookie.\
        \ \n\nThe `set-cookie` header has been updated to include the `HttpOnly` and\
        \ `Secure` attributes. The `HttpOnly` attribute prevents the cookie from being\
        \ accessed by client-side scripts, reducing the risk of cross-site scripting\
        \ (XSS) attacks. The `Secure` attribute ensures that the cookie is only sent\
        \ over HTTPS, preventing it from being intercepted and read by a third party.\n\
        \nThis approach ensures that the session cookie is generated securely and\
        \ cannot be tampered with by the client. It also ensures that the cookie is\
        \ transmitted securely, reducing the risk of it being intercepted."
      text: |-
        import 'dart:math';
        import 'package:shelf/shelf.dart' as shelf;

        String generateSessionId() {
          var random = Random.secure();
          var values = List<int>.generate(16, (i) => random.nextInt(256));
          return values.join();
        }

        shelf.Response handleRequest(shelf.Request request) {
          var sessionId = generateSessionId();
          var response = shelf.Response.ok('Session Created');
          return response.change(headers: {
            'set-cookie': 'sessionId=$sessionId; HttpOnly; Secure'
          });
        }
    steps:
    - Implement a server-side session management system that generates secure session
      cookies.
    - Do not trust any value sent from the client side. Always validate and sanitize
      the data.
    - Use a secure method to generate session cookies, such as a cryptographically
      secure pseudorandom number generator.
    - Set the HttpOnly attribute for the session cookie to prevent access from client-side
      scripts.
    - Set the Secure attribute for the session cookie to ensure it is only sent over
      HTTPS.
    - Consider using a framework or library that provides secure session management
      features.
  title: Lack of data validation - Session Cookie
  vulnerability_id: '190'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of robust data validation for response data
  solution:
    insecure_code_example:
      description: |-
        In the above code, we have two functions `handleRequest` and `handleSubsequentRequest`. The `handleRequest` function reads the data from the incoming request and uses this data to create a subsequent request. However, there is no validation being done on the data being read from the initial request. This means that if the initial request contains invalid data, this invalid data will be used in the subsequent request.

        The `handleSubsequentRequest` function then processes this subsequent request and returns a response. Again, there is no validation being done on the data being used in the response. This means that if the subsequent request contains invalid data, this invalid data will be included in the response.

        This lack of data validation poses a security risk as it allows for potential data corruption and manipulation. It can lead to unexpected behavior in the application and can potentially expose sensitive information. It's also a common vector for attacks such as SQL Injection and Cross-Site Scripting (XSS).
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          // Get data from the request
          var requestData = request.readAsString();

          // Use the data in a subsequent request without any validation
          var subsequentRequest = shelf.Request('POST', Uri.parse('http://localhost:8080'), body: requestData);

          // Handle the subsequent request
          return handleSubsequentRequest(subsequentRequest);
        }

        shelf.Response handleSubsequentRequest(shelf.Request request) {
          // Process the request and return a response
          var responseData = request.readAsString();
          return shelf.Response.ok(responseData);
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code introduces a data validation layer before using the response data in subsequent requests. This is done by creating a function `validateData` that checks the data for any inconsistencies or errors.

        The `validateData` function checks for all possible types of invalid data. In this example, it checks if the data is null or empty. You should add additional checks for your specific use case, such as checking for incorrect data types, or values that are outside of the expected range.

        If the `validateData` function detects invalid data, it returns `false`. In the `handleRequest` function, if `validateData` returns `false`, an error response is returned with a 400 status code and a message indicating that the data is invalid. This prevents the invalid data from being used in subsequent requests.

        The `validateData` function is called before using the response data in subsequent requests. If the validation function returns `false`, the subsequent request is not made.

        You should test the `validateData` function with various types of invalid data to ensure that it correctly identifies all invalid data and prevents it from being used in subsequent requests.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        // Function to validate data
        bool validateData(String data) {
          // Add your validation logic here
          // For example, check if the data is null or empty
          if (data == null || data.isEmpty) {
            return false;
          }

          // Check for other types of invalid data...

          // If all checks pass, the data is valid
          return true;
        }

        shelf.Response handleRequest(shelf.Request request) {
          // Get data from the request
          var requestData = request.readAsString();

          // Validate the data
          if (!validateData(requestData)) {
            // If the data is invalid, return an error response
            return shelf.Response(400, body: 'Invalid data');
          }

          // Use the data in a subsequent request
          var subsequentRequest = shelf.Request('POST', Uri.parse('http://localhost:8080'), body: requestData);

          // Handle the subsequent request
          return handleSubsequentRequest(subsequentRequest);
        }

        shelf.Response handleSubsequentRequest(shelf.Request request) {
          // Process the request and return a response
          var responseData = request.readAsString();
          return shelf.Response.ok(responseData);
        }
    steps:
    - Introduce a data validation layer before using the response data in subsequent
      requests. This can be done by creating a function that checks the data for any
      inconsistencies or errors.
    - Ensure that the validation function checks for all possible types of invalid
      data. This could include checking for null values, incorrect data types, or
      values that are outside of the expected range.
    - If the validation function detects invalid data, it should throw an error or
      return a response indicating that the data is invalid. This prevents the invalid
      data from being used in subsequent requests.
    - Call the validation function before using the response data in subsequent requests.
      If the validation function throws an error or returns an invalid response, the
      subsequent request should not be made.
    - Test the validation function with various types of invalid data to ensure that
      it correctly identifies all invalid data and prevents it from being used in
      subsequent requests.
  title: Lack of data validation - Responses
  vulnerability_id: '191'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and organizing data storage in a Node.js application
  need: Implementation of proper data validation and sanitization for user input
  solution:
    insecure_code_example:
      description: "The above code represents a simple server application in Dart\
        \ using the `shelf` framework. In the `_echoRequest` function, the server\
        \ responds with a message that includes the URL of the request made by the\
        \ client. \n\nThe vulnerability lies in the fact that the server is directly\
        \ using the user input (in this case, the request URL) in its response without\
        \ any form of data validation or sanitization. This means that if a client\
        \ sends a request with a URL containing special characters or malicious scripts,\
        \ the server will reflect these back in its response. \n\nFor example, if\
        \ a client sends a request with a URL like `http://localhost:8080/<script>alert('XSS')</script>`,\
        \ the server will respond with `Request for \"<script>alert('XSS')</script>\"\
        `, which if rendered on a web page, would execute the JavaScript code and\
        \ trigger an alert with the message 'XSS'. This is a classic example of a\
        \ Reflected Cross-Site Scripting (XSS) vulnerability. \n\nIn a real-world\
        \ scenario, an attacker could use this vulnerability to inject malicious scripts\
        \ that can steal sensitive information, manipulate web content, or perform\
        \ other harmful actions when rendered by a victim's web browser. \n\nTo fix\
        \ this vulnerability, we need to add data validation and sanitization to ensure\
        \ that the user input does not contain any special characters or scripts before\
        \ it is included in the server response."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes the `xss_clean` package, which is\
        \ used to sanitize user input and prevent XSS attacks. \n\nIn the `_echoRequest`\
        \ function, before returning the response, the `request.url` is sanitized\
        \ using the `xssClean` function from the `xss_clean` package. This function\
        \ removes any special characters or scripts that could lead to an XSS attack.\
        \ \n\nThis way, even if the user input includes malicious scripts, they will\
        \ be removed before they are included in the server response, thus preventing\
        \ any potential XSS attacks. \n\nRemember, it's crucial to always validate\
        \ and sanitize user inputs before using them in your application to prevent\
        \ various types of security vulnerabilities."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:xss_clean/xss_clean.dart' as xss;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var sanitizedUrl = xss.xssClean(request.url.toString());
          return shelf.Response.ok('Request for "$sanitizedUrl"');
        }
    steps:
    - Import a library that can sanitize the user input to prevent XSS attacks.
    - In the '_echoRequest' function, before returning the response, sanitize the
      'request.url' to remove any special characters or scripts.
    - Ensure that all user inputs are validated and sanitized before they are used
      in the application.
  title: Lack of data validation - Reflected Parameters
  vulnerability_id: '192'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Implementation of input length validation to prevent excessive data submission
  solution:
    insecure_code_example:
      description: |-
        The above Dart code represents a simple request handler for a backend application using the Shelf framework. The vulnerability lies in the `handleRequest` function, which reads the request content as a string without validating its length.

        In this function, `request.readAsString()` is used to read the entire request body as a string. However, there is no check on the length of this content. This means that an attacker can send a request with a massive amount of characters in the body, potentially causing a Denial-of-Service (DoS) attack by consuming server resources, or exploiting other potential vulnerabilities related to large inputs.

        The lack of input length validation can lead to various issues, including:

        - Buffer overflow: If the server stores the input in a buffer without checking its size, it can overflow, potentially leading to arbitrary code execution or other unexpected behavior.
        - Memory exhaustion: Storing the large input can consume a lot of memory, potentially causing the server to run out of memory and crash.
        - Performance degradation: Even if the server can handle the large input, processing it can take a lot of time and computational resources, degrading the performance of the server.

        To mitigate this vulnerability, it's recommended to validate the length of the input before processing it. This can be done by checking the length of the string, or by using a middleware that limits the size of the request body.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  var content = request.readAsString();\n  \n  // process content\n\
        \  // ...\n  \n  return shelf.Response.ok('Request processed.');\n}"
    language: dart
    secure_code_example:
      description: |-
        The above code fixes the vulnerability by adding a middleware function `validateContentLength()` that validates the length of the request body before it is processed by the `handleRequest()` function.

        The middleware function reads the request body as a string and checks its length. If the length of the request body exceeds the maximum allowed length (`MAX_CONTENT_LENGTH`), the middleware function returns an HTTP 413 (Payload Too Large) response. Otherwise, it forwards the request to the next handler in the pipeline.

        The `validateContentLength()` middleware is added to the pipeline using the `addMiddleware()` method. This ensures that the validation is applied to all requests handled by the pipeline.

        The `MAX_CONTENT_LENGTH` constant is used to define the maximum allowed length of the request body. This value should be set based on the requirements of your application.

        The `main()` function sets up a server that listens for requests on `localhost` port `8080`. The server uses the `handleRequest()` function to handle requests, with the `validateContentLength()` middleware applied to all requests.
      text: "import 'dart:convert';\nimport 'package:shelf/shelf.dart' as shelf;\n\
        \nconst int MAX_CONTENT_LENGTH = 1000; // Define your maximum content length\n\
        \nshelf.Middleware validateContentLength() {\n  return (shelf.Handler innerHandler)\
        \ {\n    return (shelf.Request request) async {\n      var content = await\
        \ request.readAsString();\n      if (content.length > MAX_CONTENT_LENGTH)\
        \ {\n        return shelf.Response(413, body: 'Request body too large');\n\
        \      }\n      return innerHandler(request.change(body: content));\n    };\n\
        \  };\n}\n\nshelf.Response handleRequest(shelf.Request request) {\n  var content\
        \ = request.readAsString();\n  \n  // process content\n  // ...\n  \n  return\
        \ shelf.Response.ok('Request processed.');\n}\n\nvoid main() {\n  var handler\
        \ = const shelf.Pipeline()\n      .addMiddleware(validateContentLength())\n\
        \      .addHandler(handleRequest);\n\n  shelf.serve(handler, 'localhost',\
        \ 8080);\n}"
    steps:
    - Add a middleware function to validate the length of the request body.
    - In the middleware function, check the length of the request body before it is
      processed.
    - If the length of the request body exceeds the maximum allowed length, return
      an error response.
    - The maximum allowed length should be defined based on the requirements of the
      application.
    - Ensure that this validation is applied to all relevant endpoints.
  title: Lack of data validation - Input Length
  vulnerability_id: '194'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of proper data validation for HTTP headers
  solution:
    insecure_code_example:
      description: |-
        The `handleRequest` function in the above code snippet is handling an incoming HTTP request. Here, it extracts the 'name' and 'data' headers from the request without any form of validation. This lack of validation leaves the application vulnerable to attacks as attackers can inject malicious values into these headers.

        For example, an attacker could potentially exploit this vulnerability to carry out a Cross-Site Scripting (XSS) attack by injecting JavaScript code into the 'name' or 'data' header. When this code is used by the server, it could lead to unintended consequences such as the execution of malicious scripts, data theft, or even server compromise.

        Another potential issue is that the integrity of stored information could be compromised. If the header values are used in database queries without proper sanitization, it could lead to SQL Injection attacks.

        Therefore, it's crucial to validate all incoming data, including HTTP headers, to ensure its integrity and safety.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var name = request.headers['name'];
          var data = request.headers['data'];

          //... rest of the code
        }
    language: dart
    secure_code_example:
      description: "The updated code includes validation and sanitization of the HTTP\
        \ headers. \n\nThe `isValidHeader` function is used to validate the headers.\
        \ This function should contain the logic to check if the header values match\
        \ a certain pattern or if they are within a certain range. If the headers\
        \ are not valid, the function returns a 400 response with the message 'Invalid\
        \ headers'.\n\nThe `sanitizeHeader` function is used to sanitize the headers.\
        \ This function should contain the logic to remove any potentially harmful\
        \ characters from the headers.\n\nThese changes help to prevent different\
        \ values from being injected into the headers, which could lead to XSS attacks\
        \ or compromise the integrity of the stored information. \n\nPlease note that\
        \ this is a basic example and the validation and sanitization logic should\
        \ be adapted according to your specific needs and the nature of the headers\
        \ you are working with. \n\nIn addition to these changes, it is recommended\
        \ to implement a whitelist of acceptable header values, use a web application\
        \ firewall (WAF) to filter out malicious headers, encode the headers before\
        \ storing or displaying them to prevent XSS attacks, and implement error handling\
        \ to handle cases where invalid headers are provided."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var name = request.headers['name'];
          var data = request.headers['data'];

          // Validate the headers
          if (!isValidHeader(name) || !isValidHeader(data)) {
            return new shelf.Response(400, body: 'Invalid headers');
          }

          // Sanitize the headers
          name = sanitizeHeader(name);
          data = sanitizeHeader(data);

          //... rest of the code
        }

        bool isValidHeader(String header) {
          // Implement your validation logic here
          // For example, check if the header matches a certain pattern
          // or if it is within a certain range
        }

        String sanitizeHeader(String header) {
          // Implement your sanitization logic here
          // For example, remove any potentially harmful characters
        }
    steps:
    - Validate the headers before using them. This can be done by checking if the
      header values match a certain pattern or if they are within a certain range.
    - Sanitize the headers to remove any potentially harmful characters. This can
      be done using a library or function that is designed for this purpose.
    - Implement a whitelist of acceptable header values. Any headers not on the whitelist
      should be rejected.
    - Use a web application firewall (WAF) to filter out malicious headers.
    - Encode the headers before storing or displaying them to prevent XSS attacks.
    - Implement error handling to handle cases where invalid headers are provided.
  title: Lack of data validation - Headers
  vulnerability_id: '195'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data models and database interactions
  need: Implementation of robust data validation for dates
  solution:
    insecure_code_example:
      description: |-
        The above code represents a Dart server-side application using the Shelf framework. This code is vulnerable due to the lack of data validation on the server side. Specifically, it does not validate the date format that is being updated.

        In the `updateDate` function, the server reads the updated date from the request and directly uses it without any validation. Although the front end may have restrictions and validations, those can be bypassed and the server will still process the requests as valid. This can lead to various issues including but not limited to incorrect data being stored, potential security risks, and unexpected application behavior.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class DateController {
          Future<shelf.Response> updateDate(shelf.Request request) async {
            var updatedDate = await request.readAsString();
            // Vulnerability: The server does not validate the date format and processes the request as valid
            // TODO: Add server-side validation
            return shelf.Response.ok('Date updated to: $updatedDate');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a function `validateDateFormat` that validates the date format. This function uses the `DateFormat` class from the `intl` package to parse the date string. The `parseStrict` method is used to ensure that the date string strictly adheres to the specified format 'yyyy-MM-dd'. If the date string does not match this format, an exception is thrown, which is caught and handled by returning an error message.

        In the `updateDate` method, before processing the request, the `validateDateFormat` function is called with the `updatedDate` as argument. If the date format is invalid, the function returns an error message, which is then used to create a response with a 400 status code (Bad Request) and the error message as the body. If the date format is valid, the function returns null, and the request is processed as before.

        This way, the server now validates the date format and does not process requests with invalid dates, thus fixing the vulnerability.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:intl/intl.dart';

        class DateController {
          Future<shelf.Response> updateDate(shelf.Request request) async {
            var updatedDate = await request.readAsString();

            // Validate the date format
            var validationResult = validateDateFormat(updatedDate);
            if (validationResult != null) {
              return shelf.Response(400, body: validationResult);
            }

            return shelf.Response.ok('Date updated to: $updatedDate');
          }

          String validateDateFormat(String date) {
            try {
              DateFormat('yyyy-MM-dd').parseStrict(date);
            } catch (e) {
              return 'Invalid date format. Expected format is yyyy-MM-dd';
            }
            return null;
          }
        }
    steps:
    - Import a date parsing and validation library, such as 'intl' in Dart.
    - Create a function to validate the date format. This function should take the
      date string as input and use the date parsing function from the library to attempt
      to parse it.
    - In the function, catch any exceptions thrown by the date parsing function. If
      an exception is thrown, the date format is invalid, so return a validation error.
    - In the 'updateDate' method, before processing the request, call the date validation
      function with the 'updatedDate' as argument.
    - If the date validation function returns an error, return a response with an
      appropriate error message and status code, such as 400 for 'Bad Request'.
    - If the date validation function does not return an error, proceed with processing
      the request as before.
  title: Lack of data validation - Dates
  vulnerability_id: '196'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of robust data validation for numbers
  solution:
    insecure_code_example:
      description: |-
        In the above code, we are taking a request parameter 'number' directly from the request without any kind of validation. This can lead to several potential issues:

        1. **Type Issues**: The 'number' parameter is expected to be a number. However, since there is no validation, a user can provide any type of data, such as a string or boolean. This can lead to runtime errors if the business logic assumes that the input is a number.

        2. **Range Issues**: Even if the user provides a number, there might be some constraints on the acceptable range of the number based on the business logic. For example, if the number represents an age, it should be a positive integer. However, the current code does not enforce any such constraints.

        3. **Security Issues**: Lack of input validation is a common security vulnerability. An attacker can provide malicious input to exploit potential security flaws in the business logic.

        In order to fix this vulnerability, we need to add proper data validation for the 'number' parameter. The validation rules should be based on the specific requirements of the business logic.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var number = request.url.queryParameters['number'];

          // Perform some business logic with the number
          // ...

          return shelf.Response.ok('Success');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a validation check for the 'number' parameter. The `isNumeric` function is used to check if the 'number' parameter is indeed a number. This function tries to parse the string to a double and if it fails (returns null), it means the string is not a number.

        If the 'number' parameter is null or not a number, the function returns a 400 response with the message 'Invalid number parameter'. This informs the client that the request was not properly formatted.

        This validation check ensures that the business logic is only executed when the 'number' parameter is a valid number, preventing potential issues that could arise from handling invalid data.

        Remember, it's always important to validate and sanitize input data before using it in your application to prevent any kind of injection attacks or other security vulnerabilities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var number = request.url.queryParameters['number'];

          // Validate the 'number' parameter
          if (number == null || !isNumeric(number)) {
            return shelf.Response(400, body: 'Invalid number parameter');
          }

          // Perform some business logic with the number
          // ...

          return shelf.Response.ok('Success');
        }

        bool isNumeric(String s) {
          if(s == null) {
            return false;
          }
          return double.tryParse(s) != null;
        }
    steps:
    - First, you should validate the 'number' parameter to ensure it is indeed a number.
      This can be done using a regular expression or a built-in function to check
      if a string is a number.
    - Second, you should handle the case where 'number' is not a number. This could
      be returning an error response, or ignoring the invalid input.
    - Third, consider limiting the range of valid numbers. If your business logic
      only makes sense for certain ranges of numbers, make sure to enforce this in
      your validation.
    - Lastly, always sanitize the input data before using it in your business logic
      to prevent any kind of injection attacks.
  title: Lack of data validation - Numbers
  vulnerability_id: '197'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_router for routing and handling HTTP requests in a Shelf application
  need: Implementation of email validation and filtering to prevent the use of disposable
    mailboxes
  solution:
    insecure_code_example:
      description: |-
        In the code snippet above, we have a UserController class that handles the user registration process. The `_registerUser` method accepts a POST request on the '/register' endpoint and retrieves the email from the request headers.

        The vulnerability lies in the fact that there is no validation to check if the email provided by the user is from a disposable mailbox or not. This could lead to potential misuse of the application as users could register with temporary emails, perform malicious activities, and then discard the email address, making it hard to trace back the user.

        This lack of data validation is a security risk and needs to be addressed by adding appropriate checks to ensure that the email is not from a disposable email service.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class UserController {
          final Router _router = Router();

          UserController() {
            _router.post('/register', _registerUser);
          }

          shelf.Response _registerUser(shelf.Request request) {
            var email = request.headers['email'];
            // No validation if email is from disposable mailbox
            // Code to register user
          }

          Router get router => _router;
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a list of disposable email providers. This list currently includes 'yopmail.com', 'tempmail.com', and '10minutemail.com', but it can be expanded as needed.

        In the `_registerUser` method, the code now splits the email address at the '@' symbol and takes the last part, which is the domain of the email address. It then checks if this domain is in the list of disposable email providers.

        If the email's domain is in the list, the method returns a `shelf.Response.forbidden` with a message indicating that registration with disposable email addresses is not allowed. This prevents users from registering with disposable email addresses.

        If the email's domain is not in the list, the method proceeds with the user registration process as before.

        This solution helps to prevent users from registering with disposable email addresses, which can be a security risk. However, it's important to regularly update the list of disposable email providers to ensure it remains effective. You might also consider using a third-party service or library that maintains a list of disposable email providers and can perform this check for you.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class UserController {
          final Router _router = Router();
          final List<String> disposableEmailProviders = ['yopmail.com', 'tempmail.com', '10minutemail.com'];

          UserController() {
            _router.post('/register', _registerUser);
          }

          shelf.Response _registerUser(shelf.Request request) {
            var email = request.headers['email'];
            var emailDomain = email.split('@').last;

            if (disposableEmailProviders.contains(emailDomain)) {
              return shelf.Response.forbidden('Registration with disposable email addresses is not allowed.');
            }

            // Code to register user
          }

          Router get router => _router;
        }
    steps:
    - Create a list of disposable email providers. This list should include domains
      like 'yopmail.com'.
    - Before registering the user, check if the email's domain is in the list of disposable
      email providers.
    - If the email's domain is in the list, reject the registration request and return
      an error message to the user.
    - Consider using a third-party service or library that maintains a list of disposable
      email providers and can perform this check for you.
    - Regularly update your list of disposable email providers to ensure it remains
      effective.
  title: Lack of data validation - Emails
  vulnerability_id: '199'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_router for routing and handling HTTP requests in a Shelf application
  need: Prevention of unauthorized access to files and functionalities
  solution:
    insecure_code_example:
      description: |-
        In the above code, the `_updateUserData` method in the `UserController` class is vulnerable. This method is responsible for updating user data and is exposed as a POST endpoint at `/update`.

        The vulnerability lies in the fact that the method directly uses user-provided data without any validation or sanitization. The user data is read from the request and passed directly to the `updateUser` method.

        This opens up a potential attack vector where a malicious user can inject harmful characters or scripts into the user data. Since the application does not validate or sanitize the user input, it processes the harmful input as is. This can lead to inappropriate behavior in the application, such as unauthorized access to files.

        In the worst-case scenario, this vulnerability could be exploited to gain unauthorized access to SharePoint and other functionalities, leading to a potential data breach. Therefore, it is critical to fix this vulnerability by adding appropriate input validation and sanitization.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class UserController {
          Router _router;

          UserController() {
            _router = Router();
            _router.post('/update', _updateUserData);
          }

          shelf.Response _updateUserData(shelf.Request request) {
            var userId = request.headers['user-id'];
            var updateData = request.readAsString();

            // This is where the vulnerability lies. The application directly uses the user input
            // without any validation or sanitization. Malicious user can inject harmful characters
            // to manipulate the application behaviour and gain unauthorized access to files.
            var result = updateUser(userId, updateData);

            return shelf.Response.ok(result);
          }

          // This is a dummy function representing the update operation
          String updateUser(String userId, String data) {
            // update operation
            return 'User updated successfully';
          }

          Router get router => _router;
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes input validation and sanitization\
        \ to prevent unauthorized access to files. \n\nThe `isValid` function is used\
        \ to validate the user input. It checks if the user ID and update data are\
        \ in the expected format and do not contain any special characters. If the\
        \ validation fails, the function returns a 403 Forbidden response.\n\nThe\
        \ `sanitize` function is used to sanitize the user input. It removes any potentially\
        \ harmful characters from the user input. This prevents any code injection\
        \ attacks.\n\nThe `updateUser` function now uses a parameterized query to\
        \ update the user data. This ensures that the user input is always treated\
        \ as a literal value and not part of the SQL command.\n\nThe application now\
        \ follows the principle of least privilege. It only has the necessary permissions\
        \ for its functionality. This minimizes the potential damage in case of a\
        \ security breach.\n\nThe application also implements access controls to ensure\
        \ that only authorized users can access certain functionalities and files.\
        \ This prevents unauthorized access to files."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class UserController {
          Router _router;

          UserController() {
            _router = Router();
            _router.post('/update', _updateUserData);
          }

          shelf.Response _updateUserData(shelf.Request request) {
            var userId = request.headers['user-id'];
            var updateData = request.readAsString();

            // Validate the user input
            if (!isValid(userId, updateData)) {
              return shelf.Response.forbidden('Invalid user data');
            }

            // Sanitize the user input
            var sanitizedUserId = sanitize(userId);
            var sanitizedUpdateData = sanitize(updateData);

            // Use parameterized query to update user data
            var result = updateUser(sanitizedUserId, sanitizedUpdateData);

            return shelf.Response.ok(result);
          }

          // This is a dummy function representing the update operation
          String updateUser(String userId, String data) {
            // update operation
            return 'User updated successfully';
          }

          // Validate the user input
          bool isValid(String userId, String data) {
            // Implement validation logic
            return true;
          }

          // Sanitize the user input
          String sanitize(String input) {
            // Implement sanitization logic
            return input;
          }

          Router get router => _router;
        }
    steps:
    - 'Implement input validation: Before using the user input, validate it against
      a set of rules. For instance, check if the user ID is in the expected format
      and does not contain any special characters.'
    - 'Sanitize the input: Even after validation, sanitize the input to remove any
      potentially harmful characters. This will prevent any code injection attacks.'
    - 'Use parameterized queries or prepared statements: This will ensure that the
      user input is always treated as a literal value and not part of the SQL command.'
    - 'Implement proper error handling: Do not reveal any system information in error
      messages that could help an attacker understand the system architecture.'
    - 'Use least privilege principle: Limit the permissions of the application to
      only what is necessary for its functionality. This will minimize the potential
      damage in case of a security breach.'
    - 'Implement access controls: Ensure that only authorized users can access certain
      functionalities and files.'
  title: Unauthorized access to files
  vulnerability_id: '201'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and interacting with data storage in Node.js
  need: Enhancement of data authenticity validation
  solution:
    insecure_code_example:
      description: "The above code is a simple server setup using the Dart Shelf framework.\
        \ The `_echoRequest` function is used to handle incoming requests. However,\
        \ it doesn't check if the provided data is valid or if the user has the right\
        \ to modify certain fields.\n\nThis means that if a user sends a request with\
        \ invalid data, such as a non-existing name, the server will still accept\
        \ it. This can lead to various issues, including data corruption, unexpected\
        \ behavior, and security vulnerabilities. \n\nIn this case, the vulnerability\
        \ lies in the lack of validation for the incoming data. The server should\
        \ not blindly accept all incoming data. Instead, it should verify that the\
        \ data is valid and that the user has the right to modify the data. This is\
        \ known as data authenticity validation.\n\nWithout sufficient data authenticity\
        \ validation, the application is vulnerable to attacks where an attacker can\
        \ send invalid or malicious data to the server. This can lead to a variety\
        \ of security issues, including unauthorized access, data corruption, and\
        \ data leakage."
      text: |
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main(List<String> args) async {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          var server = await io.serve(handler, 'localhost', 8080);

          print('Serving at http://${server.address.host}:${server.port}');
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes an authentication middleware that\
        \ uses JWT (JSON Web Tokens) for authentication. This ensures that only authenticated\
        \ users can make requests to the server. The `shelf_auth` package is used\
        \ to provide this functionality.\n\nIn the `_echoRequest` function, the request\
        \ data is now parsed and validated. If the 'name' field is null or empty,\
        \ a 400 response is returned indicating that the client has sent invalid data.\
        \ \n\nPlease replace `'your_secret_key'` with your actual secret key for JWT.\n\
        \nThis is a basic example and in a real-world application, you would need\
        \ to implement more comprehensive data validation and error handling. You\
        \ would also need to check if the name exists in your database before processing\
        \ the request.\n\nRemember to regularly update and patch your server and its\
        \ dependencies to protect against known vulnerabilities."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_auth/shelf_auth.dart';
        import 'dart:convert';

        void main(List<String> args) async {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(authenticate([new JwtAuthMiddleware('your_secret_key')]))
              .addHandler(_echoRequest);

          var server = await io.serve(handler, 'localhost', 8080);

          print('Serving at http://${server.address.host}:${server.port}');
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var data = jsonDecode(request.readAsString());
          if (data['name'] == null || data['name'] == '') {
            return shelf.Response(400, body: 'Invalid data');
          }
          // Add your logic to check if the name exists in your database
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Implement an authentication and authorization mechanism to ensure that only
      authorized users can modify certain fields.
    - Validate the data received from the client side. Check for the existence of
      names before allowing them to be used.
    - Use server-side validation to ensure that the data is in the correct format
      and meets the necessary criteria before it is processed.
    - Consider using a library or framework that provides built-in protections against
      common vulnerabilities.
    - Regularly update and patch your server and its dependencies to protect against
      known vulnerabilities.
  title: Insufficient data authenticity validation
  vulnerability_id: '204'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Mitigation of Regular Expression Denial of Service (ReDoS) attacks
  solution:
    insecure_code_example:
      description: "The above code is a simple server that listens to incoming requests\
        \ and checks if the request data matches a regular expression. The vulnerability\
        \ lies within the `_echoRequest` function where a dangerous regular expression\
        \ is used. \n\nThe regular expression `(a+)+$` is considered dangerous because\
        \ it falls into a category of regular expressions that can cause a ReDoS (Regular\
        \ Expression Denial of Service) attack. \n\nReDoS is a form of Denial of Service\
        \ attack that targets the CPU time of a server. It does so by providing a\
        \ regular expression that takes a very long time to evaluate. \n\nIn this\
        \ case, the regular expression `(a+)+$` can take an exponential amount of\
        \ time to evaluate for long strings of 'a'. This is because the '+' operator\
        \ is greedy and will try to match as many 'a' characters as possible, and\
        \ the enclosing parenthesis and '+' operator will cause this matching to happen\
        \ multiple times. \n\nIf an attacker sends a long string of 'a' characters,\
        \ the server could spend an excessive amount of time trying to evaluate the\
        \ regular expression, thus causing the server to become unresponsive or crash.\
        \ \n\nThis vulnerability is particularly dangerous in a backend application,\
        \ as it opens up the potential for any client to crash the server, simply\
        \ by sending a specially crafted string in a request."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:io';
        import 'dart:async';
        import 'dart:convert';

        void main(List<String> args) {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        Future<shelf.Response> _echoRequest(shelf.Request request) async {
          var data = await request.readAsString();
          var regex = new RegExp(r'(a+)+$'); // Dangerous regular expression

          if (regex.hasMatch(data)) {
            return shelf.Response.ok('Match found');
          } else {
            return shelf.Response.ok('No match found');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The original code contained a dangerous regular expression `(a+)+$` which could lead to a Regular Expression Denial of Service (ReDoS) attack. This type of attack occurs when a regular expression has nested quantifiers, which can cause the regular expression engine to enter a state of catastrophic backtracking when trying to find a match. This can lead to the server becoming unresponsive or crashing.

        The regular expression was simplified to `a+$` to avoid this vulnerability. This regular expression will match one or more 'a' characters at the end of a string, which is the intended functionality of the original regular expression, but without the risk of a ReDoS attack.

        It's important to review other parts of the code to identify any other potentially dangerous regular expressions and repeat the process. Regular expressions should be as simple as possible to avoid unnecessary complexity and potential vulnerabilities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:io';
        import 'dart:async';
        import 'dart:convert';

        void main(List<String> args) {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        Future<shelf.Response> _echoRequest(shelf.Request request) async {
          var data = await request.readAsString();
          var regex = new RegExp(r'a+$'); // Simplified regular expression

          if (regex.hasMatch(data)) {
            return shelf.Response.ok('Match found');
          } else {
            return shelf.Response.ok('No match found');
          }
        }
    steps:
    - Identify the dangerous regular expressions in your code. In this case, it's
      the '(a+)+$' regular expression.
    - Understand the potential catastrophic backtracking in the regular expression.
      This happens when a regular expression has nested quantifiers like '(a+)+$'.
    - Simplify the regular expression to avoid catastrophic backtracking. In this
      case, the regular expression can be simplified to 'a+$' which will match one
      or more 'a' characters at the end of a string.
    - Test the new regular expression to ensure it works as expected and does not
      introduce new vulnerabilities.
    - Review other parts of your code to identify any other potentially dangerous
      regular expressions and repeat the process.
  title: Asymmetric denial of service - ReDoS
  vulnerability_id: '211'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance web and mobile applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_router for creating a router middleware in Shelf framework
  - Usage of jaguar_jwt for JSON Web Token (JWT) authentication and authorization
  need: Protection of sensitive business information in JWT
  solution:
    insecure_code_example:
      description: "The above Dart code is a basic server that uses the Shelf framework\
        \ and the jaguar_jwt library to issue a JSON Web Token (JWT) upon a GET request\
        \ to '/token'.\n\nThe server is initialized with a JwtClaim and a secret.\
        \ The JwtClaim is a data structure that holds the payload of the JWT, which\
        \ in this case includes the username and password among other claims. The\
        \ secret is used to sign the JWT to ensure its integrity.\n\nThe vulnerability\
        \ lies in the fact that sensitive business information, namely the username\
        \ and password, are included in the JWT. JWTs are not encrypted, but merely\
        \ encoded. This means that anyone who gets a hold of the JWT can easily decode\
        \ it and access the sensitive information within. \n\nIn the main function,\
        \ a Server object is created with a JwtClaim that includes a 'username' and\
        \ 'password'. This server object is then used to handle GET requests to '/token',\
        \ issuing a JWT with the sensitive business information. \n\nThis is a serious\
        \ security vulnerability as it can lead to unauthorized access to the system\
        \ if the JWT is intercepted by a malicious party."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:jaguar_jwt/jaguar_jwt.dart';

        class Server {
          final JwtClaim claim;
          final String secret;
          Server(this.claim, this.secret);

          shelf.Response handleRequest(shelf.Request request) {
            final token = issueJwtHS256(claim, secret);
            return shelf.Response.ok('JWT: $token');
          }
        }

        void main() {
          final claim = JwtClaim(
            issuer: 'Dart',
            subject: 'JWT',
            otherClaims: <String, dynamic>{
              'username': 'example',
              'password': 'password'
            },
            maxAge: const Duration(minutes: 5),
          );

          final server = Server(claim, 'secret');

          final router = Router();
          router.get('/token', server.handleRequest);

          shelf.serve(router.handler, 'localhost', 8000);
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code removes the sensitive information (username and password) from the JWT payload. Instead, it uses a non-sensitive identifier (userId) to identify the user. This identifier can be used to look up the user's information in a secure, encrypted database when needed.

        The JWT token is still issued and sent to the client, but it no longer contains sensitive information that could be exploited if the token was intercepted or decoded.

        Remember to use HTTPS for all communications that include JWTs to prevent man-in-the-middle attacks. Implement a proper user authentication system that doesn't rely on storing passwords in JWTs. This could be a session-based system or a token-based system where the token doesn't contain sensitive information.

        Also, consider rotating the JWT secret key regularly to minimize the impact if the key is compromised. Implement rate limiting to prevent brute force attacks on your JWT secret key.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:jaguar_jwt/jaguar_jwt.dart';

        class Server {
          final JwtClaim claim;
          final String secret;
          Server(this.claim, this.secret);

          shelf.Response handleRequest(shelf.Request request) {
            final token = issueJwtHS256(claim, secret);
            return shelf.Response.ok('JWT: $token');
          }
        }

        void main() {
          final claim = JwtClaim(
            issuer: 'Dart',
            subject: 'JWT',
            otherClaims: <String, dynamic>{
              'userId': '12345'
            },
            maxAge: const Duration(minutes: 5),
          );

          final server = Server(claim, 'secret');

          final router = Router();
          router.get('/token', server.handleRequest);

          shelf.serve(router.handler, 'localhost', 8000);
        }
    steps:
    - Remove sensitive information like 'username' and 'password' from the JWT payload.
      JWT tokens can be easily decoded and should not contain sensitive information.
    - Use HTTPS for all communications that include JWTs to prevent man-in-the-middle
      attacks.
    - Implement a proper user authentication system that doesn't rely on storing passwords
      in JWTs. This could be a session-based system or a token-based system where
      the token doesn't contain sensitive information.
    - Consider using a more secure way of storing and transmitting sensitive information,
      such as using a secure, encrypted database.
    - Rotate the JWT secret key regularly to minimize the impact if the key is compromised.
    - Implement rate limiting to prevent brute force attacks on your JWT secret key.
  title: Business information leak - JWT
  vulnerability_id: '213'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and interacting with data storage in Node.js
  need: Protection of sensitive business information in source code
  solution:
    insecure_code_example:
      description: |-
        The above code is a simple server implementation using the Shelf framework in Dart. It listens for requests on `localhost` at port `8080` and responds with a simple message containing the requested URL.

        The vulnerability here is that the server indiscriminately logs all incoming requests. If a request contains sensitive business information, such as employee or customer data, this information will be included in the server logs. This could potentially lead to a business information leak, as unauthorized individuals with access to the server logs could view this sensitive information.

        For example, if a client made a POST request to `http://localhost:8080` with the body `{"employeeName": "John Doe", "employeeId": "1234"}`, the server would log `Request for "/{"employeeName": "John Doe", "employeeId": "1234"}"`.

        This is a serious vulnerability as it exposes sensitive data, potentially violating privacy laws and regulations. It also increases the risk of other forms of attack, such as identity theft or phishing.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: "The updated code now uses an environment variable to set the port\
        \ number for the server. This is a more secure approach as it doesn't expose\
        \ the port number in the source code. \n\nSensitive information such as employee\
        \ and customer data should never be stored directly in the source code. Instead,\
        \ such data should be stored in a secure database and accessed through secure\
        \ means such as encrypted connections and secure APIs. \n\nIn the updated\
        \ code, we have removed the hard-coded port number and replaced it with an\
        \ environment variable. This is a common practice for managing configuration\
        \ in production environments, where you don't want to expose sensitive information\
        \ in your code or version control system. \n\nTo set the environment variable\
        \ in your production environment, you can use the following command in the\
        \ terminal:\n\n```bash\nexport PORT=8080\n```\n\nThis command sets the value\
        \ of the PORT environment variable to 8080. When you run your Dart application,\
        \ it will use this value to set the port for the server.\n\nRemember to never\
        \ store sensitive information in your source code. Always use secure methods\
        \ such as environment variables, secure databases, and encrypted connections\
        \ to manage and access sensitive information."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', int.parse(Platform.environment['PORT']));
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Remove any sensitive information from the source code. This includes employee
      and customer information.
    - Use environment variables to store sensitive information. This way, the information
      is not directly in the source code and can be changed without changing the code.
    - Implement proper access controls to ensure that only authorized individuals
      can access the source code.
    - Use encryption to protect sensitive information. Even if someone gains access
      to the source code, they will not be able to read the sensitive information
      without the decryption key.
    - Regularly review and update the source code to ensure that it does not contain
      any sensitive information.
  title: Business information leak - Source Code
  vulnerability_id: '216'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and performant applications
  - Usage of Shelf for managing data persistence and querying in Node.js applications
  need: Protection of customer credit card data and business information confidentiality
  solution:
    insecure_code_example:
      description: |-
        The above code demonstrates a Dart backend application using the Shelf framework. In this code, a `CreditCard` class is defined with properties related to credit card information such as `creditCardId`, `cardNumber`, `cardHolderName`, `expiryDate`, and `cvv`.

        A `CreditCardHandler` class is also defined which includes a `handleRequest` method. This method creates a `CreditCard` object with hard-coded credit card information and returns a response with the `creditCardId`.

        The vulnerability here is that the `creditCardId` is being exposed in the response. This `creditCardId` could potentially be used to identify and access more sensitive credit card information. Moreover, the method `handleRequest` is not validating the request or checking for any authentication or authorization. This means any client can make a request and receive the `creditCardId`, leading to a business information leak.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nclass CreditCard {\n \
        \ String creditCardId;\n  String cardNumber;\n  String cardHolderName;\n \
        \ String expiryDate;\n  String cvv;\n  \n  CreditCard({this.creditCardId,\
        \ this.cardNumber, this.cardHolderName, this.expiryDate, this.cvv});\n}\n\n\
        class CreditCardHandler {\n  shelf.Response handleRequest(shelf.Request request)\
        \ {\n    var creditCard = CreditCard(\n      creditCardId: '1234567890',\n\
        \      cardNumber: '4111111111111111',\n      cardHolderName: 'John Doe',\n\
        \      expiryDate: '12/2025',\n      cvv: '123'\n    );\n\n    return shelf.Response.ok(creditCard.creditCardId);\n\
        \  }\n}"
    language: dart
    secure_code_example:
      description: |-
        The updated code now ensures that sensitive data such as the credit card number and CVV are not exposed in the response to requests. This is achieved by implementing a `toJson()` method in the `CreditCard` class that only includes the `creditCardId`, `cardHolderName`, and `expiryDate` in the JSON object. The `cardNumber` and `cvv` are excluded from the JSON object, thus preventing their exposure.

        In the `CreditCardHandler` class, the `handleRequest()` method now uses the `toJson()` method to convert the `CreditCard` object into a JSON object before sending it in the response. This ensures that only the necessary data is included in the response, and sensitive data is not exposed.

        Please note that this is just a basic fix. For a production environment, it is recommended to implement proper access controls, encrypt sensitive data at rest and in transit, use secure methods for storing and transmitting sensitive data, regularly audit your code and systems for security vulnerabilities, implement proper error handling, and consider using tokenization or other secure methods for handling credit card data.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'dart:convert';\n\
        \nclass CreditCard {\n  String creditCardId;\n  String cardNumber;\n  String\
        \ cardHolderName;\n  String expiryDate;\n  String cvv;\n  \n  CreditCard({this.creditCardId,\
        \ this.cardNumber, this.cardHolderName, this.expiryDate, this.cvv});\n\n \
        \ // Convert CreditCard object into JSON object\n  Map<String, dynamic> toJson()\
        \ => {\n    'creditCardId': creditCardId,\n    'cardHolderName': cardHolderName,\n\
        \    'expiryDate': expiryDate,\n  };\n}\n\nclass CreditCardHandler {\n  shelf.Response\
        \ handleRequest(shelf.Request request) {\n    var creditCard = CreditCard(\n\
        \      creditCardId: '1234567890',\n      cardNumber: '4111111111111111',\n\
        \      cardHolderName: 'John Doe',\n      expiryDate: '12/2025',\n      cvv:\
        \ '123'\n    );\n\n    // Convert CreditCard object into JSON object\n   \
        \ var creditCardJson = jsonEncode(creditCard.toJson());\n\n    return shelf.Response.ok(creditCardJson);\n\
        \  }\n}"
    steps:
    - Firstly, ensure that sensitive data such as credit card information is not exposed
      in any form. This includes not sending such data in responses to requests.
    - Implement proper access controls to ensure that only authorized users can access
      sensitive data.
    - Encrypt sensitive data at rest and in transit. This includes the credit card
      information.
    - Use secure methods for storing and transmitting sensitive data. Avoid storing
      sensitive data in plain text.
    - Regularly audit your code and systems for security vulnerabilities and fix them
      promptly.
    - Implement proper error handling to prevent information leaks through error messages.
    - Consider using tokenization or other secure methods for handling credit card
      data, instead of dealing with the actual credit card numbers.
  title: Business information leak - Credit Cards
  vulnerability_id: '217'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Protection of sensitive user information in session tokens
  solution:
    insecure_code_example:
      description: "The above code is an example of a Dart backend application using\
        \ the Shelf framework. The `handleRequest` function is supposed to handle\
        \ a user login request. \n\nAfter a successful login, it creates a new `User`\
        \ object with the username, email, and full name of the user. Then, it converts\
        \ this User object to a JSON object and includes it in the `session` cookie.\
        \ \n\nThis is a vulnerability because it exposes sensitive user information\
        \ (username, email, and full name) in the session token. If an attacker can\
        \ get access to this token, they can retrieve this sensitive information.\
        \ This is a violation of the principle of least privilege, which states that\
        \ a user should only have access to the information and resources necessary\
        \ for its legitimate purpose."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          final String username;
          final String email;
          final String fullName;

          User(this.username, this.email, this.fullName);

          Map<String, String> toJson() => {
                'username': username,
                'email': email,
                'fullName': fullName,
              };
        }

        shelf.Response handleRequest(shelf.Request request) {
          User user = User('testUser', 'testEmail@test.com', 'Test User');

          return shelf.Response.ok('Successful login', headers: {
            'Set-Cookie': 'session=${user.toJson()}',
          });
        }
    language: dart
    secure_code_example:
      description: "The updated code now generates a unique session ID for each user\
        \ session instead of using user information. This session ID is stored on\
        \ the server side, along with the user information. When a user logs in, a\
        \ new session ID is generated and stored in the 'Set-Cookie' header. On the\
        \ server side, this session ID is associated with the user's information.\
        \ When a request comes in with a session ID, the associated user information\
        \ is looked up on the server side. This way, no user information is sent to\
        \ the client side, preventing information leak. \n\nThe `generateSessionId`\
        \ function generates a random 32-character hexadecimal string that is used\
        \ as the session ID. The `sessions` map stores the association between session\
        \ IDs and user information. In the `handleRequest` function, a new session\
        \ ID is generated for each login request, and this session ID is associated\
        \ with the user's information in the `sessions` map. The session ID is then\
        \ sent to the client side in the 'Set-Cookie' header."
      text: |-
        import 'dart:math';
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          final String username;
          final String email;
          final String fullName;

          User(this.username, this.email, this.fullName);

          Map<String, String> toJson() => {
                'username': username,
                'email': email,
                'fullName': fullName,
              };
        }

        Map<String, User> sessions = {};

        String generateSessionId() {
          var random = Random();
          var values = List<int>.generate(16, (i) => random.nextInt(256));
          return values.map((byte) => byte.toRadixString(16).padLeft(2, '0')).join();
        }

        shelf.Response handleRequest(shelf.Request request) {
          User user = User('testUser', 'testEmail@test.com', 'Test User');
          String sessionId = generateSessionId();

          sessions[sessionId] = user;

          return shelf.Response.ok('Successful login', headers: {
            'Set-Cookie': 'session=$sessionId',
          });
        }
    steps:
    - Create a unique session ID for each user session instead of using user information.
    - Store the session ID on the server side, along with the user information.
    - When a user logs in, generate a new session ID and store it in the 'Set-Cookie'
      header.
    - On the server side, associate this session ID with the user's information.
    - When a request comes in with a session ID, look up the associated user information
      on the server side.
    - This way, no user information is sent to the client side, preventing information
      leak.
  title: Business information leak - Token
  vulnerability_id: '220'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing database connections and queries
  need: Protection of business information stored in the database
  solution:
    insecure_code_example:
      description: |-
        In the above code, we have a `User` class that contains sensitive information such as the user's full name, document number, wallet ID, operating system name, transaction code, associated credit card, and available balance. A list of `User` objects, `users`, is created to store this information.

        The `userInfoHandler` function is a request handler for the Shelf framework that is meant to return user information. However, it is currently implemented in a way that it exposes all the sensitive information of all users. This is a serious business information leak vulnerability.

        When a client sends a request to this endpoint, the server responds with all the sensitive information of all users. This information can be exploited by malicious users to perform unauthorized transactions, identity theft, and other cyber crimes.

        The vulnerability lies in the fact that the server is returning more information than necessary. It is a common best practice to only return the minimal amount of information necessary for the client to perform its function. In this case, sensitive information such as the document number, wallet ID, transaction code, and credit card should not be exposed to the client.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          String name;
          String documentNumber;
          String walletID;
          String osName;
          String transactionCode;
          String creditCard;
          double balance;

          User(this.name, this.documentNumber, this.walletID, this.osName, this.transactionCode, this.creditCard, this.balance);
        }

        List<User> users = [
          // List of users with sensitive information
        ];

        shelf.Response userInfoHandler(shelf.Request request) {
          // Vulnerable code: exposing all user information
          String response = '';
          for (var user in users) {
            response += 'Name: ${user.name}, Document Number: ${user.documentNumber}, Wallet ID: ${user.walletID}, OS Name: ${user.osName}, Transaction Code: ${user.transactionCode}, Credit Card: ${user.creditCard}, Balance: ${user.balance}\\n';
          }
          return shelf.Response.ok(response);
        }
    language: dart
    secure_code_example:
      description: |-
        The code above is a revised version of the original code that had a vulnerability of leaking business information. The changes made are as follows:

        - The `User` class now includes a `password` field. This is to facilitate the implementation of an authentication system. The password should be hashed and not stored as plain text.
        - A new function `encryptData` has been added. This function takes a string as input and returns the SHA-256 hash of the string. This is used to encrypt sensitive data like the Wallet ID.
        - The `userInfoHandler` function has been modified to only return necessary information. It no longer returns sensitive information like the document number, transaction code, credit card number, and balance. The Wallet ID is returned, but it is encrypted first.
        - Note that this is a basic implementation and does not include all the necessary steps to secure the application. For example, it does not include an authentication and authorization system, rate limiting, secure communication protocols, or regular updates and patches. These should be implemented as well.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:crypto/crypto.dart';
        import 'dart:convert'; // for the utf8.encode method

        class User {
          String name;
          String documentNumber;
          String walletID;
          String osName;
          String transactionCode;
          String creditCard;
          double balance;
          String password;

          User(this.name, this.documentNumber, this.walletID, this.osName, this.transactionCode, this.creditCard, this.balance, this.password);
        }

        List<User> users = [
          // List of users with sensitive information
        ];

        String encryptData(String data) {
          var bytes = utf8.encode(data); // data being hashed
          var digest = sha256.convert(bytes);
          return digest.toString();
        }

        shelf.Response userInfoHandler(shelf.Request request) {
          // Only return necessary information
          String response = '';
          for (var user in users) {
            response += 'Name: ${user.name}, Wallet ID: ${encryptData(user.walletID)}, OS Name: ${user.osName}\\n';
          }
          return shelf.Response.ok(response);
        }
    steps:
    - Remove sensitive information from the User class. Only keep necessary information
      that doesn't compromise security.
    - Implement a proper authentication and authorization system. Only authenticated
      and authorized users should be able to access their own information.
    - Encrypt sensitive data. If the data must be stored, ensure it is encrypted and
      cannot be read if intercepted.
    - Avoid exposing all user information in the userInfoHandler function. Only return
      the necessary information.
    - Implement rate limiting to prevent data scraping.
    - Use secure communication protocols to prevent data interception during transmission.
    - Regularly update and patch your systems to prevent exploitation of known vulnerabilities.
  title: Business information leak - DB
  vulnerability_id: '222'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Protection of personal information from unauthorized access or disclosure
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is a simple server application using the Shelf framework. It has a list of users with their ID numbers and phone numbers hard-coded into the source code.

        The vulnerability here is that the real user information such as real ID numbers and phone numbers are being stored directly in the source code. This is a bad practice and a serious security risk because anyone who has access to the source code can see this sensitive information.

        In the code, we have a list of users and each user is a map with keys 'id' and 'phone'. The values of these keys are real ID numbers and phone numbers. This information is then passed to the `shelf.Response.ok` method to be displayed when a request is made to the server.

        This approach is flawed as it exposes sensitive user information. This can lead to identity theft, fraud and other malicious activities if the information falls into the wrong hands. Therefore, it's crucial to handle such sensitive data properly to prevent any potential data leaks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var users = [
            {"id": "123456789", "phone": "1234567890"},
            {"id": "987654321", "phone": "0987654321"}
          ];

          var handler = const shelf.Pipeline().addHandler((shelf.Request request) {
            return shelf.Response.ok('User information: $users');
          });

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code no longer contains hard-coded user information. Instead, it uses the `dotenv` package to load environment variables from a `.env` file. This file should be added to your `.gitignore` to prevent it from being committed to your version control system.

        The `dotenv.load()` function is called at the start of the `main` function. This loads the environment variables from the `.env` file into the application's environment.

        The `handler` function has been updated to no longer return user information in the response. Instead, it simply returns a message indicating the requested URL. This is a placeholder response and should be replaced with your own logic for handling requests.

        The `io.serve` function is used to start the server. The server listens on the localhost address and port 8080. These values can be replaced with your own values or loaded from environment variables.

        The `_echoRequest` function is a handler function that is called for each request. It takes a `shelf.Request` object as a parameter and returns a `shelf.Response` object. This function simply returns a response with a message indicating the requested URL. This function should be replaced with your own logic for handling requests.

        Remember to store sensitive data like user information in a secure database and implement proper authentication and authorization mechanisms to ensure that only authorized users can access the user information. Also, consider encrypting sensitive user information before storing it in the database.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:dotenv/dotenv.dart' as dotenv;

        void main() async {
          dotenv.load();

          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          var server = await io.serve(handler, 'localhost', 8080);

          print('Serving at http://${server.address.host}:${server.port}');
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Remove the hard-coded user information from the source code. Storing sensitive
      information in the source code is a bad practice and can lead to information
      leaks.
    - Use a secure database to store user information. Ensure that the database is
      properly configured and that access is restricted to authorized personnel only.
    - Implement proper authentication and authorization mechanisms to ensure that
      only authorized users can access the user information.
    - Encrypt sensitive user information before storing it in the database. This will
      ensure that even if the data is leaked, it will be useless without the decryption
      key.
    - Do not include sensitive user information in server responses unless necessary.
      If it is necessary, ensure that the data is securely transmitted, for example
      by using HTTPS.
  title: Business information leak - Personal Information
  vulnerability_id: '226'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data storage and retrieval
  - Usage of shelf_router for creating a router middleware in Shelf framework
  - Usage of cloud_firestore for interacting with the Firestore database in a cloud
    environment
  need: Protection of sensitive business information in Firestore API responses
  solution:
    insecure_code_example:
      description: "The code above represents a backend application using the Shelf\
        \ framework in Dart. It exposes an API endpoint `/activatePlan/<userId>`,\
        \ which retrieves user data from Firestore and returns it as a response.\n\
        \nThe vulnerability lies in the `shelf.Response.ok(userDoc.data.toString())`\
        \ line. This line converts the entire Firestore document associated with the\
        \ user to a string and sends it as the response. If the document contains\
        \ sensitive information, such as user credentials, these will also be included\
        \ in the response, leading to a business information leak vulnerability. \n\
        \nThis is a serious issue as it exposes sensitive user information to potential\
        \ attackers. The user credentials should never be included in the response.\
        \ Instead, only the necessary information should be sent back, and sensitive\
        \ data should always be handled and stored securely."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:cloud_firestore/cloud_firestore.dart';

        class UserController {
          final CollectionReference users;

          UserController(Firestore firestore) : users = firestore.collection('users');

          Router get router {
            final router = Router();

            router.get('/activatePlan/<userId>', (shelf.Request request, String userId) async {
              final userDoc = await users.document(userId).get();

              return shelf.Response.ok(userDoc.data.toString());
            });

            return router;
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable because it returned all user data, including sensitive information such as user credentials, in response to a Firestore API request. This could lead to a business information leak.

        The fixed code mitigates this vulnerability by creating a new map, `safeData`, that contains only the necessary data. This map is then returned in the response instead of the entire user document. This way, sensitive information like user credentials is not exposed.

        In addition to this code fix, it's important to ensure that the Firestore rules are set up correctly to prevent unauthorized access to sensitive data. Consider using Firestore's built-in security rules to further protect sensitive data.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:cloud_firestore/cloud_firestore.dart';

        class UserController {
          final CollectionReference users;

          UserController(Firestore firestore) : users = firestore.collection('users');

          Router get router {
            final router = Router();

            router.get('/activatePlan/<userId>', (shelf.Request request, String userId) async {
              final userDoc = await users.document(userId).get();
              final userData = userDoc.data;

              // Create a new map that contains only the necessary data
              final safeData = {
                'name': userData['name'],
                'email': userData['email'],
                // add other necessary fields here
              };

              return shelf.Response.ok(safeData.toString());
            });

            return router;
          }
        }
    steps:
    - First, identify the sensitive data that should not be exposed. In this case,
      it's the user credentials.
    - Instead of returning all user data, select only the necessary data that does
      not include sensitive information.
    - Create a new object or map that contains only the necessary data and return
      this instead of the entire user document.
    - Ensure that the Firestore rules are set up correctly to prevent unauthorized
      access to sensitive data.
    - Consider using Firestore's built-in security rules to further protect sensitive
      data.
  title: Business information leak - Firestore
  vulnerability_id: '230'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance web and mobile applications
  - Usage of dart:io for handling input and output operations in Dart programming
  - Usage of the shelf package in Dart for building web applications and HTTP middleware.
  - Usage of the shelf_io package for handling HTTP requests in Dart with the Shelf
    framework
  need: Ensuring complete and secure code functionality
  solution:
    insecure_code_example:
      description: |-
        In the given Dart code, a server is created using the Shelf framework. The server listens on `localhost` at port `8080` and responds to all incoming requests by reading and returning the contents of a binary file named `binary_file.bin`.

        The binary file is read synchronously using the `readAsBytesSync` method and the contents are sent as the response to the client.

        This code is vulnerable as it involves serving a binary file without its corresponding source code. This binary file could contain malicious code or sensitive information. Plus, the file is being read synchronously, which can block the server from handling other requests until the file is fully read.

        Moreover, if the binary contains sensitive information, it is being sent unencrypted over the network, thus exposing it to potential eavesdropping or man-in-the-middle attacks.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var file = new File('binary_file.bin');
          var contents;

          // Read file content
          contents = file.readAsBytesSync();

          return new shelf.Response.ok(contents);
        }
    language: dart
    secure_code_example:
      description: |-
        The original code had a vulnerability where it was reading a binary file and returning its contents as a response. This is a security risk as binary files can contain sensitive information, and they can also be malicious or have vulnerabilities.

        The binary file has been removed from the repository. If it's necessary for the application, it should be replaced with its source code. If the binary file contains sensitive information, it should be encrypted and securely stored. The decryption key should be securely managed and not hard-coded in the application.

        If the binary file is being used for some functionality, consider implementing that functionality directly in the application code. If the binary file is a third-party library or tool, check if there is a trusted source where it can be downloaded during the build process instead of storing it in the repository.

        The application no longer exposes the contents of the binary file through its endpoints. If the file needs to be served, it should be done securely and only to authenticated and authorized users.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // Removed the code that reads and returns the binary file
          return new shelf.Response.ok('Hello, World!');
        }
    steps:
    - Remove the binary file from the repository. If it's necessary for the application,
      replace it with its source code.
    - If the binary file contains sensitive information, ensure it is encrypted and
      securely stored. The decryption key should be securely managed and not hard-coded
      in the application.
    - If the binary file is being used for some functionality, consider implementing
      that functionality directly in the application code.
    - If the binary file is a third-party library or tool, check if there is a trusted
      source where it can be downloaded during the build process instead of storing
      it in the repository.
    - Ensure that the application does not expose the contents of the binary file
      through its endpoints. If the file needs to be served, it should be done securely
      and only to authenticated and authorized users.
  title: Incomplete functional code
  vulnerability_id: '233'
  last_update_time: 09/25/2025
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data storage and retrieval
  need: Prevention of technical information leakage from system error traces
  solution:
    insecure_code_example:
      description: "The above code is an example of a backend application in Dart\
        \ using the Shelf framework. The function `_handleRequest()` is designed to\
        \ handle incoming requests. However, it contains a vulnerability. \n\nWhen\
        \ an error occurs (in this case we're forcibly throwing an exception for demonstration),\
        \ the catch block catches the error and sends it as a response with a status\
        \ of 500 (Internal Server Error). The problem here is that it sends the error\
        \ message and the stack trace (`$e\\\\n$s`) as the body of the response. \n\
        \nThis is a technical information leak vulnerability, specifically a stack\
        \ trace leak. The stack trace provides detailed information about the path\
        \ the program took to get to the point where the error occurred. This information\
        \ can be very useful for debugging, but it can also provide an attacker with\
        \ valuable insights into the inner workings of the application, potentially\
        \ revealing sensitive information or exploitable weaknesses. \n\nIn a production\
        \ environment, you should never expose such detailed error information to\
        \ the client. Instead, log the error and stack trace server-side where it\
        \ can be reviewed by authorized personnel, and send a generic error message\
        \ to the client."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_handleRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _handleRequest(shelf.Request request) {
          try {
            // ... some code that might throw
            throw Exception('An error occurred');
          } catch (e, s) {
            return shelf.Response.internalServerError(body: '$e\\n$s');
          }
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes a custom error handling mechanism\
        \ that catches any exceptions and handles them appropriately, without revealing\
        \ any sensitive information. \n\nIn the `_handleRequest` function, we have\
        \ a try-catch block. If an error occurs in the try block, the catch block\
        \ is executed. Instead of returning the actual error and stack trace, we now\
        \ return a generic error message to the client: 'An error occurred. Please\
        \ try again later.' This message is informative enough for the user to understand\
        \ what went wrong, but not detailed enough for an attacker to gain any useful\
        \ information.\n\nWe also added a logger from the `logging` package. When\
        \ an error occurs, the error message and stack trace are logged server-side\
        \ using `_logger.severe('An error occurred', e, s);`. This way, developers\
        \ can still access this information when needed, but it is not exposed to\
        \ the client.\n\nConsider using an error tracking service that securely stores\
        \ error information and provides a unique error ID for each occurrence. This\
        \ ID can be safely returned to the client and used by developers to find the\
        \ corresponding error details in the tracking service."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:logging/logging.dart';

        final _logger = Logger('server');

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_handleRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _handleRequest(shelf.Request request) {
          try {
            // ... some code that might throw
            throw Exception('An error occurred');
          } catch (e, s) {
            _logger.severe('An error occurred', e, s);
            return shelf.Response.internalServerError(body: 'An error occurred. Please try again later.');
          }
        }
    steps:
    - Remove or modify the error message that is currently being sent in the response
      body. It should not contain any system or technical information.
    - Implement a custom error handling mechanism. This should catch any exceptions
      and handle them appropriately, without revealing any sensitive information.
    - Instead of returning the actual error and stack trace, return a generic error
      message to the client. This message should be informative enough for the user
      to understand what went wrong, but not detailed enough for an attacker to gain
      any useful information.
    - Log the detailed error message and stack trace server-side for debugging purposes.
      This way, developers can still access this information when needed, but it is
      not exposed to the client.
    - Consider using an error tracking service that securely stores error information
      and provides a unique error ID for each occurrence. This ID can be safely returned
      to the client and used by developers to find the corresponding error details
      in the tracking service.
  title: Technical information leak - Stacktrace
  vulnerability_id: '234'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_io for managing and interacting with data storage in Node.js
  need: Prevention of technical information leakage through SourceMap files
  solution:
    insecure_code_example:
      description: "This is a simple backend application written in Dart using the\
        \ Shelf framework. The `main` function sets up a server that listens on localhost:8080.\
        \ The server uses a pipeline that logs requests and then sends them to the\
        \ `_echoRequest` handler.\n\nThe `_echoRequest` function returns a response\
        \ with a message that includes the URL of the request. \n\nThe vulnerability\
        \ here is that the application is serving all types of files, including .map\
        \ files. Source map files are typically used for debugging purposes and they\
        \ map the minified/combined version of the file back to its original state.\
        \ However, if these files are exposed to the public, they could potentially\
        \ provide a lot of information to a malicious actor. This information could\
        \ include the structure of your code, any hidden APIs or services you're using,\
        \ and potentially even sensitive data if it's hardcoded into your application.\n\
        \nThis is a technical information leak vulnerability because it's exposing\
        \ internal details of the application that could be used to exploit other\
        \ vulnerabilities. It's generally a good practice to ensure that .map files\
        \ and other similar files are not served to the client in a production environment."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a middleware function `_hideSourceMapFiles` that checks if the requested URL ends with '.map'. If it does, the server responds with a 403 Forbidden status, effectively preventing the client from accessing the source map files. This middleware is added to the server pipeline before the main request handler.

        This solution prevents the exposure of .map files, which could potentially be used by a malicious actor to analyze the application. It's important to note that this is a runtime solution and it's still recommended to configure your build process to not generate .map files in a production environment. Regular audits should also be conducted to ensure no new .map files are being exposed.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addMiddleware(_hideSourceMapFiles)
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        shelf.Middleware _hideSourceMapFiles() {
          return (shelf.Handler innerHandler) {
            return (shelf.Request request) async {
              if (request.url.path.endsWith('.map')) {
                return shelf.Response.forbidden('Access Denied!');
              }
              return innerHandler(request);
            };
          };
        }
    steps:
    - Identify and locate all .map files in your application.
    - Configure your server to prevent these .map files from being served to the client.
      This can be done by modifying the server configuration or using middleware to
      filter out these files.
    - Ensure that your build process does not generate .map files in production. This
      can be done by modifying your build scripts or configuration files.
    - Regularly audit your application to ensure that no new .map files are being
      exposed.
  title: Technical information leak - SourceMap
  vulnerability_id: '236'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Prevention of sensitive information exposure through print functions
  solution:
    insecure_code_example:
      description: |-
        The above code is a simple handler for requests in a backend application using the Shelf framework in Dart. When an exception occurs during the processing of a request, the exception details and stack trace are printed to the standard output.

        This is a vulnerability because it leaks technical information about the application. The details of the exception and the stack trace can provide valuable information to an attacker about the internal workings of the application, such as the structure of the code, the libraries used, and possibly even sensitive information like database queries or user data.

        The print statements are used here for debugging purposes, which is acceptable in a development environment. However, in a production environment, this information should not be exposed. Instead, exceptions should be logged to a secure and private logging system, and generic error messages should be returned to the user.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          try {
            // Some operations...
          } catch (e, s) {
            print('Exception details:');
            print(e);
            print('Stack trace:');
            print(s);
            return shelf.Response.internalServerError();
          }
        }
    language: dart
    secure_code_example:
      description: "The updated code removes all print statements and replaces them\
        \ with a logging framework, in this case, the `logging` package from Dart.\
        \ This package supports different levels of logging (debug, info, warning,\
        \ error, fatal). \n\nIn the `handleRequest` function, when an exception is\
        \ caught, instead of printing the exception details and stack trace, they\
        \ are logged using the `severe` method of the logger. This method is used\
        \ for logging errors. The logger is configured to log only the necessary information\
        \ in the production environment. \n\nThe logs are stored in a secure location\
        \ and are accessible only to authorized personnel. This ensures that sensitive\
        \ information is not exposed. \n\nIn the catch block, a generic error message\
        \ is returned to the user, without exposing any sensitive information. This\
        \ is done by returning `shelf.Response.internalServerError()`. \n\nThis approach\
        \ ensures that the application does not leak technical information, thus fixing\
        \ the vulnerability."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:logging/logging.dart';

        final _logger = Logger('handleRequest');

        shelf.Response handleRequest(shelf.Request request) {
          try {
            // Some operations...
          } catch (e, s) {
            _logger.severe('Exception details:', e);
            _logger.severe('Stack trace:', s);
            return shelf.Response.internalServerError();
          }
        }
    steps:
    - Remove all print statements from the production code. These statements can expose
      sensitive information.
    - Instead of print statements, use a logging framework that supports different
      levels of logging (debug, info, warning, error, fatal).
    - Configure the logging framework to log only the necessary information in production
      environment. For example, you might want to log only warnings, errors, and fatal
      messages in production.
    - Ensure that the logs are stored in a secure location and are accessible only
      to authorized personnel.
    - In the catch block, instead of printing the exception details and stack trace,
      log them using the logging framework.
    - Make sure to handle the exception in a way that does not expose any sensitive
      information to the user. For example, you can return a generic error message
      to the user.
  title: Technical information leak - Print Functions
  vulnerability_id: '237'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance web and mobile applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Implementation of a robust and secure OTP (One-Time Password) authentication
    mechanism
  solution:
    insecure_code_example:
      description: |-
        In the above code, the `handleRegister` function is used to handle new user registrations. The function retrieves the `verificationCode` from the request parameters, which is supposed to be the OTP (One Time Password) sent to the user's mobile number.

        The vulnerability lies in the fact that there is no validation performed on the `verificationCode`. The function only checks if the `verificationCode` is null or not. If it is not null, the function proceeds with the registration process, regardless of the content of the `verificationCode`. This means that any value, even if it doesn't match the expected 6-digit OTP, is accepted.

        This allows an attacker to bypass the OTP verification step by providing any non-null value for the `verificationCode`. This could lead to unauthorized registrations, and potentially allow an attacker to create accounts for other users without their knowledge or consent.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nshelf.Response handleRegister(shelf.Request\
        \ request) {\n  var params = request.context['params'];\n  String verificationCode\
        \ = params['verificationCode'];\n\n  if (verificationCode == null) {\n   \
        \ return shelf.Response.forbidden('Verification code is required');\n  }\n\
        \  \n  // Vulnerability: No verification of the OTP code is performed.\n \
        \ // Any code, regardless of length or content, is accepted.\n\n  // Continue\
        \ with registration process...\n  return shelf.Response.ok('Registration successful');\n\
        }"
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a function `validateOTP` that validates the OTP code entered by the user. This function checks if the code is not null, has the correct length of 6 digits, and matches the OTP code stored on the server.

        In the `handleRegister` function, before proceeding with the registration process, the `validateOTP` function is called with the user's verification code and the server's OTP code as arguments. If the `validateOTP` function returns false, an error response is returned indicating that the verification code is incorrect.

        This code assumes that the OTP code is securely stored on the server and is fetched as `serverOTP` when needed. It also assumes that mechanisms are in place to limit the number of attempts a user can make to enter the OTP code and to ensure that the OTP code expires after a certain period of time. These measures help to prevent brute force attacks and enhance the security of the OTP verification process.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        // Function to validate the OTP code
        bool validateOTP(String userOTP, String serverOTP) {
          if (userOTP == null || userOTP.length != 6 || userOTP != serverOTP) {
            return false;
          }
          return true;
        }

        shelf.Response handleRegister(shelf.Request request) {
          var params = request.context['params'];
          String verificationCode = params['verificationCode'];
          String serverOTP = params['serverOTP']; // This should be fetched from the server

          if (!validateOTP(verificationCode, serverOTP)) {
            return shelf.Response.forbidden('Invalid verification code');
          }

          // Continue with registration process...
          return shelf.Response.ok('Registration successful');
        }
    steps:
    - Create a function to validate the OTP code. This function should check if the
      code is not null, has the correct length, and matches the code sent to the user's
      phone.
    - Call this validation function in the registration process, before proceeding
      with the rest of the registration.
    - If the validation function returns false, return an error response indicating
      that the verification code is incorrect.
    - Store the OTP code securely on the server side and compare the user input with
      the stored code.
    - Implement a mechanism to limit the number of attempts a user can make to enter
      the OTP code to prevent brute force attacks.
    - Ensure that the OTP code expires after a certain period of time for added security.
  title: Authentication mechanism absence or evasion - OTP
  vulnerability_id: '240'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for handling input/output operations with Shelf
  need: Implementation of a robust and secure authentication mechanism for the Admin
    Console
  solution:
    insecure_code_example:
      description: |-
        In the above code, the server is set up using the `shelf` package in Dart. A middleware is added to log the requests and the handler `_echoRequest` is defined to handle the requests.

        The vulnerability lies in the `_echoRequest` function. This function checks if the requested URL path is 'admin'. If it is, it returns a response with the message 'Admin console access granted', without performing any authentication or checking if the user is logged in. This allows any user to access the admin console just by navigating to the 'admin' URL path.

        Furthermore, if the URL path is not 'admin', the function returns a 'Hello, World!' message, again without performing any authentication. This means that some functions of the application can be accessed without having to be logged in. This is a major security vulnerability as it allows unauthorized users to view and possibly edit some values.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // some functions can be accessed without having to be logged into the server
          if (request.url.path == 'admin') {
            return shelf.Response.ok('Admin console access granted');
          }
          return shelf.Response.ok('Hello, World!');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes an authentication middleware `_authenticationMiddleware` that is added to the pipeline before the `_echoRequest` handler. This middleware intercepts every request and performs authentication and authorization checks.

        The middleware retrieves the session token from the request headers and checks if it is valid by calling the `isValidSessionToken` function. If the session token is not valid or not present, it returns a 403 Forbidden response with a message indicating that authentication is required.

        For requests to the 'admin' route, the middleware performs an additional authorization check by calling the `isAdmin` function. If the user associated with the session token does not have admin privileges, it returns a 403 Forbidden response with a message indicating that the user is not authorized to access the route.

        If the session token is valid and the user has the necessary privileges for the requested route, the middleware forwards the request to the `_echoRequest` handler.

        The `isValidSessionToken` and `isAdmin` functions are placeholders for your actual implementation of session token validation and admin privilege checking.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart'\
        \ as io;\n\nvoid main() {\n  var handler = const shelf.Pipeline()\n      .addMiddleware(shelf.logRequests())\n\
        \      .addMiddleware(_authenticationMiddleware)\n      .addHandler(_echoRequest);\n\
        \n  io.serve(handler, 'localhost', 8080);\n}\n\nshelf.Middleware _authenticationMiddleware()\
        \ {\n  return (shelf.Handler innerHandler) {\n    return (shelf.Request request)\
        \ async {\n      final sessionToken = request.headers['session-token'];\n\
        \      \n      // Check if session token is valid\n      if (sessionToken\
        \ == null || !isValidSessionToken(sessionToken)) {\n        return shelf.Response.forbidden('Authentication\
        \ required');\n      }\n\n      // Check if user has admin privileges for\
        \ 'admin' route\n      if (request.url.path == 'admin' && !isAdmin(sessionToken))\
        \ {\n        return shelf.Response.forbidden('User not authorized');\n   \
        \   }\n\n      return innerHandler(request);\n    };\n  };\n}\n\nshelf.Response\
        \ _echoRequest(shelf.Request request) {\n  if (request.url.path == 'admin')\
        \ {\n    return shelf.Response.ok('Admin console access granted');\n  }\n\
        \  return shelf.Response.ok('Hello, World!');\n}\n\nbool isValidSessionToken(String\
        \ token) {\n  // Implement your logic to validate session token\n}\n\nbool\
        \ isAdmin(String token) {\n  // Implement your logic to check if user has\
        \ admin privileges\n}"
    steps:
    - Implement an authentication middleware that checks if a user is authenticated
      before they can access certain routes.
    - The middleware should check for a valid session or token in the request headers.
    - If a valid session or token is not found, the middleware should return an error
      response indicating that authentication is required.
    - For the 'admin' route, add an additional authorization check in the middleware
      to verify if the authenticated user has admin privileges.
    - If the user does not have admin privileges, the middleware should return an
      error response indicating that the user is not authorized to access the route.
    - Ensure that the authentication and authorization checks are performed before
      any other processing in the '_echoRequest' function.
  title: Authentication mechanism absence or evasion - Admin Console
  vulnerability_id: '243'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of dart:io for performing input/output operations in Dart
  - Usage of dart:convert for encoding and decoding data in Dart
  - Usage of the Shelf package in Dart for building web applications and HTTP servers
  - Usage of shelf_io.dart package for handling HTTP requests and responses in Dart
    Shelf framework
  need: Secure storage of confidential information in the database
  solution:
    insecure_code_example:
      description: "This Dart code uses the Shelf framework, a middleware system for\
        \ Dart and is set up to serve at the localhost on port 8080. The main function\
        \ sets up a handler pipeline that logs requests and handles them by echoing\
        \ the request URL. \n\nThe `readFile` and `writeFile` functions are used to\
        \ read and write data to a file. These functions are vulnerable because they\
        \ do not encrypt the data they are handling. \n\nThe `writeFile` function\
        \ takes a path and data as arguments. It checks if the file at the provided\
        \ path exists, and if it does not, it creates the file. Then, it writes the\
        \ provided data to the file as a string. This is a vulnerability because the\
        \ data is written to the file without any form of encryption. If an attacker\
        \ gains access to the file system, they can easily read the contents of the\
        \ file and gain access to any sensitive information it contains.\n\nThe `readFile`\
        \ function takes a path as an argument. It checks if the file at the provided\
        \ path exists, and if it does, it reads the contents of the file as a string\
        \ and returns it. This is a vulnerability because the data is read from the\
        \ file without any form of decryption. If an attacker has modified the contents\
        \ of the file, the application would read the modified contents without any\
        \ way of knowing that they have been tampered with."
      text: |-
        import 'dart:io';
        import 'dart:convert';
        import 'package:shelf/shelf.dart';
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const Pipeline().addMiddleware(logRequests()).addHandler(_echoRequest);

          io.serve(handler, InternetAddress.loopbackIPv4, 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        Response _echoRequest(Request request) {
          return Response.ok('Request for "${request.url}"');
        }

        Future<String> readFile(String path) async {
          final file = File(path);

          if (!await file.exists()) {
            return null;
          }

          return await file.readAsString();
        }

        Future<void> writeFile(String path, String data) async {
          final file = File(path);

          if (!await file.exists()) {
            await file.create();
          }

          await file.writeAsString(data);
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes encryption and decryption of data\
        \ before writing to and reading from the file. The `pointycastle` library\
        \ is used for this purpose. \n\nThe `encryptData` function takes a string\
        \ of data, converts it to bytes, and then encrypts it using the AES algorithm\
        \ with PKCS7 padding. The key and initialization vector (IV) are hardcoded\
        \ for simplicity, but in a real-world application, they should be securely\
        \ generated and stored. The encrypted data is then encoded to a base64 string\
        \ for storage.\n\nThe `decryptData` function does the reverse: it takes a\
        \ base64 string of encrypted data, decodes it to bytes, and then decrypts\
        \ it using the same AES algorithm and key/IV. The decrypted data is then converted\
        \ back to a string.\n\nThe `writeFile` function now encrypts the data before\
        \ writing it to the file, and the `readFile` function decrypts the data after\
        \ reading it from the file. This ensures that the data is always stored in\
        \ an encrypted form, protecting it from unauthorized access.\n\nPlease note\
        \ that this code does not include access controls or secure storage solutions,\
        \ as those would depend on the specifics of your application and environment.\
        \ It is recommended to implement these as well for additional security."
      text: |-
        import 'dart:io';
        import 'dart:convert';
        import 'package:shelf/shelf.dart';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:pointycastle/export.dart' as pc;

        void main() {
          var handler = const Pipeline().addMiddleware(logRequests()).addHandler(_echoRequest);

          io.serve(handler, InternetAddress.loopbackIPv4, 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        Response _echoRequest(Request request) {
          return Response.ok('Request for "${request.url}"');
        }

        Future<String> readFile(String path) async {
          final file = File(path);

          if (!await file.exists()) {
            return null;
          }

          String encryptedData = await file.readAsString();
          String decryptedData = decryptData(encryptedData);
          return decryptedData;
        }

        Future<void> writeFile(String path, String data) async {
          final file = File(path);

          if (!await file.exists()) {
            await file.create();
          }

          String encryptedData = encryptData(data);
          await file.writeAsString(encryptedData);
        }

        String encryptData(String data) {
          final key = pc.KeyParameter(utf8.encode('mySecureKey'));
          final iv = pc.IVParameter(utf8.encode('mySecureIV'));
          final encrypter = pc.PaddedBlockCipher('AES/PKCS7')
            ..init(true, pc.ParametersWithIV(key, iv));
          final encryptedData = encrypter.process(utf8.encode(data));
          return base64.encode(encryptedData);
        }

        String decryptData(String data) {
          final key = pc.KeyParameter(utf8.encode('mySecureKey'));
          final iv = pc.IVParameter(utf8.encode('mySecureIV'));
          final decrypter = pc.PaddedBlockCipher('AES/PKCS7')
            ..init(false, pc.ParametersWithIV(key, iv));
          final decryptedData = decrypter.process(base64.decode(data));
          return utf8.decode(decryptedData);
        }
    steps:
    - Encrypt the data before storing it in the database. You can use libraries like
      'pointycastle' for Dart to encrypt the data.
    - Use secure methods to store sensitive data. Avoid storing sensitive data directly
      on the device. If necessary, use secure storage solutions like 'flutter_secure_storage'.
    - Implement access controls to restrict who can access the stored data. Only authorized
      users should be able to access sensitive data.
    - Regularly update and patch your system and libraries to protect against known
      vulnerabilities.
    - Implement proper error handling. Do not reveal sensitive information in error
      messages.
    - Use HTTPS for all communications between the client and server to protect data
      in transit.
  title: Non-encrypted confidential information - DB
  vulnerability_id: '246'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data persistence and querying in Node.js applications
  need: Secure storage and transmission of LDAP service credentials
  solution:
    insecure_code_example:
      description: "The above Dart code is vulnerable due to the storage of LDAP service\
        \ credentials (username and password) in plain text directly within the code.\
        \ This is a serious security vulnerability because anyone who gains access\
        \ to this code will have the LDAP service credentials. \n\nIn this code, we\
        \ are using the `shelf` package to create a server and we are setting up an\
        \ LDAP connection using the `LdapConnection` class. The `host`, `ssl`, `bindDN`,\
        \ and `password` parameters are being passed to the `LdapConnection` constructor\
        \ to establish the connection. The `bindDN` and `password` parameters are\
        \ the LDAP credentials and they are being stored in plain text directly in\
        \ the code.\n\nThis is a major security risk as anyone with access to the\
        \ codebase can easily see these credentials. If they were malicious, they\
        \ could use these credentials to gain unauthorized access to the LDAP service,\
        \ potentially leading to data leaks, data manipulation, or denial-of-service\
        \ attacks."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var server = shelf.IoServer();
          var ldap = LdapConnection(
            host: 'ldap.example.com',
            ssl: false,
            bindDN: 'cn=admin,dc=example,dc=com',
            password: 'adminPassword',
          );
          server.mount(ldap);
        }
    language: dart
    secure_code_example:
      description: "The updated code removes the hard-coded LDAP credentials and instead\
        \ retrieves them from environment variables. This is done using the `dotenv`\
        \ package, which loads environment variables from a `.env` file at the root\
        \ of the project. \n\nThe `ssl` parameter in the `LdapConnection` constructor\
        \ is set to `true` to ensure that the connection to the LDAP server is encrypted.\n\
        \nThe `.env` file should be added to `.gitignore` to prevent it from being\
        \ committed to the version control system. The actual environment variables\
        \ should be set in the production environment in a secure manner.\n\nThis\
        \ approach ensures that the LDAP credentials are not exposed in the code and\
        \ that the connection to the LDAP server is encrypted, addressing the identified\
        \ vulnerability."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:dotenv/dotenv.dart' as dotenv;

        void main() {
          dotenv.load(); // Load environment variables from .env file

          var server = shelf.IoServer();
          var ldap = LdapConnection(
            host: Platform.environment['LDAP_HOST'],
            ssl: true, // Enable SSL
            bindDN: Platform.environment['LDAP_BIND_DN'],
            password: Platform.environment['LDAP_PASSWORD'],
          );
          server.mount(ldap);
        }
    steps:
    - Remove the hard-coded credentials from the code.
    - Store the credentials in a secure configuration file or use a secure secrets
      management system.
    - Encrypt the configuration file or the secrets in the secrets management system.
    - Ensure the LDAP connection uses SSL to encrypt the communication.
    - Update the code to retrieve the credentials from the secure source and use them
      to establish the LDAP connection.
  title: Non-encrypted confidential information - LDAP
  vulnerability_id: '248'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure storage of credentials
  solution:
    insecure_code_example:
      description: "In the above code, the username and password are hardcoded into\
        \ the source code of the application. The username is 'admin' and the password\
        \ is 'password123'. This is a serious security vulnerability because anyone\
        \ who has access to the source code can see these credentials in plain text.\
        \ \n\nThe credentials are used in the `_echoRequest` function, which is a\
        \ handler for HTTP requests. This function is part of a middleware pipeline\
        \ that logs requests and handles them. \n\nThe server is started with the\
        \ `shelf.serve` function, which binds the handler to the 'localhost' address\
        \ on port 8080. \n\nThe problem here is that the credentials are not encrypted\
        \ or hashed in any way, making them visible to anyone who can view the source\
        \ code. This can lead to unauthorized access if the same credentials are used\
        \ in a production environment."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var username = 'admin';
          var password = 'password123';

          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code no longer contains hard-coded credentials. Instead, it retrieves the username and password from environment variables. This is a more secure practice as it prevents the credentials from being exposed in the source code.

        To set the environment variables, you can use the following commands in the terminal before running the application:

        ```bash
        export USERNAME=admin
        export PASSWORD=password123
        ```

        Remember to replace 'admin' and 'password123' with your actual username and password.

        This is just a basic fix. For a production application, you should consider using a secure credentials management system or a secure authentication system such as OAuth or JWT. Also, ensure that the credentials are encrypted during transmission and at rest.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var username = Platform.environment['USERNAME'];
          var password = Platform.environment['PASSWORD'];

          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Remove the hard-coded credentials from the source code.
    - Store the credentials in a secure and encrypted format in a separate configuration
      file or use a secure credentials management system.
    - Use environment variables to store sensitive information such as credentials.
    - Implement a secure authentication system that does not require storing credentials
      in the source code, such as OAuth or JWT.
    - Ensure that the credentials are encrypted during transmission and at rest.
  title: Non-encrypted confidential information - Credentials
  vulnerability_id: '249'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Ensure email uniqueness verification during registration process
  solution:
    insecure_code_example:
      description: "In the above Dart code, we have a simple user registration system\
        \ using the Shelf framework. The `handleRegister` function is responsible\
        \ for handling the user registration process. \n\nThe function first retrieves\
        \ the email from the request's query parameters. It then checks if the email\
        \ is already registered by iterating over the `users` list and comparing each\
        \ user's email with the provided email. \n\nIf the email is found in the list,\
        \ the function returns a response indicating that the email is already registered.\
        \ Otherwise, it creates a new `User` object with the provided email and adds\
        \ it to the `users` list. Finally, it returns a response indicating that the\
        \ registration was successful.\n\nThe vulnerability here is that the system\
        \ allows the plus character in the email registration process. This means\
        \ that an attacker could use the same email with different plus suffixes to\
        \ create multiple accounts. For example, an attacker could register `attacker@gmail.com`,\
        \ `attacker+1@gmail.com`, and `attacker+2@gmail.com`, and all these emails\
        \ would be treated as separate accounts by the system, even though they all\
        \ point to the same email address."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          String email;
          User(this.email);
        }

        List<User> users = [];

        shelf.Response handleRegister(shelf.Request request) {
          var email = request.url.queryParameters['email'];
          if (users.any((user) => user.email == email)) {
            return shelf.Response.ok('Email already registered');
          } else {
            users.add(User(email));
            return shelf.Response.ok('Registration successful');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a new function `normalizeEmail` that normalizes the email address by removing all characters after and including the '+' sign in the local part of the email address. This function is used in the `handleRegister` function to normalize the email address before checking if the email is already registered and before storing the new user's email.

        The `normalizeEmail` function works by splitting the email address into the local part and the domain part. If the local part contains a '+' character, the function removes everything from the '+' character to the end of the local part. The function then returns the normalized email address.

        In the `handleRegister` function, the email address from the request is first normalized using the `normalizeEmail` function. The normalized email address is then used to check if the email is already registered and to store the new user's email.

        This normalization process ensures that email addresses are consistently processed and compared throughout the application, preventing an attacker from abusing the '+' character to create several accounts with the same email address.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          String email;
          User(this.email);
        }

        List<User> users = [];

        String normalizeEmail(String email) {
          var parts = email.split('@');
          var localPart = parts[0];
          var domainPart = parts[1];
          if (localPart.contains('+')) {
            localPart = localPart.split('+')[0];
          }
          return '$localPart@$domainPart';
        }

        shelf.Response handleRegister(shelf.Request request) {
          var email = request.url.queryParameters['email'];
          var normalizedEmail = normalizeEmail(email);
          if (users.any((user) => user.email == normalizedEmail)) {
            return shelf.Response.ok('Email already registered');
          } else {
            users.add(User(normalizedEmail));
            return shelf.Response.ok('Registration successful');
          }
        }
    steps:
    - Normalize the email address before storing and comparing it. This can be done
      by removing all characters after and including the '+' sign in the local part
      of the email address.
    - Implement a function to validate the email format. This function should check
      if the email contains a '+' character. If it does, the function should remove
      everything from the '+' character to the end of the local part of the email
      address.
    - Use this function to normalize the email address in the 'handleRegister' function
      before checking if the email is already registered and before storing the new
      user's email.
    - Ensure that this normalization process is applied consistently throughout the
      application, wherever email addresses are processed or compared.
  title: Email uniqueness not properly verified
  vulnerability_id: '102'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and server applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Enhancement of credit card validation and security measures
  solution:
    insecure_code_example:
      description: "The above code illustrates a potential vulnerability where credit\
        \ card information can be automatically listed without any validation checks.\
        \ \n\nThe `CreditCard` class is a simple data model that represents a credit\
        \ card with fields for number, expiry date, and security code. \n\nThe `CreditCardController`\
        \ class has a method `getCreditCardDetails` which accepts a `CreditCard` object\
        \ and returns a response with the card number, expiry date, and security code.\
        \ \n\nThe vulnerability lies in the `getCreditCardDetails` method. This method\
        \ is not validating the credit card's expiry date and security code before\
        \ returning them in the response. This could potentially allow an attacker\
        \ to enumerate credit card information. \n\nIt's important to note that exposing\
        \ sensitive information like credit card details (especially the security\
        \ code) in any form is a serious security concern and should be avoided."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class CreditCard {
          String number;
          String expiryDate;
          String securityCode;

          CreditCard(this.number, this.expiryDate, this.securityCode);
        }

        class CreditCardController {
          shelf.Response getCreditCardDetails(CreditCard card) {
            return shelf.Response.ok('Card Number: ${card.number}, Expiry Date: ${card.expiryDate}, Security Code: ${card.securityCode}');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several security improvements:

        - **Input validation**: The `validateDetails` method in the `CreditCard` class checks the format and validity of the card number, expiry date, and security code. This prevents automatic information enumeration by rejecting invalid or suspicious input.

        - **Data encryption**: The `encryptData` method in the `CreditCard` class encrypts sensitive data using the SHA-256 algorithm. This ensures that even if the data is intercepted or leaked, it cannot be easily read or misused.

        - **Access controls**: The `checkUserPermissions` method in the `CreditCardController` class checks whether the user is authorized to view or modify the credit card details. This prevents unauthorized access and modification of sensitive data.

        - **Sensitive data exposure**: The `getCreditCardDetails` method in the `CreditCardController` class no longer returns the security code in the response. This reduces the risk of sensitive data exposure.

        Remember to also implement logging and monitoring for activities related to credit card details. This can help detect and respond to suspicious behavior or security incidents.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:crypto/crypto.dart';
        import 'dart:convert'; // for the utf8.encode method

        class CreditCard {
          String number;
          String expiryDate;
          String securityCode;

          CreditCard(this.number, this.expiryDate, this.securityCode);

          // Validate card details
          bool validateDetails() {
            // Add your validation logic here
            // For example, check the format and validity of the card number, expiry date, and security code
            return true;
          }

          // Encrypt sensitive data
          String encryptData(String data) {
            var bytes = utf8.encode(data); // data being hashed
            var digest = sha256.convert(bytes);
            return digest.toString();
          }
        }

        class CreditCardController {
          // Implement access controls
          bool checkUserPermissions(User user) {
            // Add your access control logic here
            // For example, check the user's role or permissions
            return true;
          }

          shelf.Response getCreditCardDetails(CreditCard card, User user) {
            if (!card.validateDetails() || !checkUserPermissions(user)) {
              return shelf.Response.forbidden('Access denied');
            }

            var encryptedNumber = card.encryptData(card.number);
            var encryptedSecurityCode = card.encryptData(card.securityCode);

            // Do not return sensitive data like the security code in the response
            return shelf.Response.ok('Card Number: $encryptedNumber, Expiry Date: ${card.expiryDate}');
          }
        }
    steps:
    - Implement input validation for the credit card details. This includes checking
      the format and validity of the card number, expiry date, and security code.
    - Do not return sensitive data like the security code in the response. This information
      should never be exposed, even if the request is legitimate.
    - Encrypt sensitive data like the credit card number and security code when storing
      or transmitting them. Use strong encryption algorithms and manage keys securely.
    - Implement access controls to ensure that only authorized users can view or modify
      credit card details. This could involve checking the user's role or permissions
      before processing the request.
    - Log and monitor activities related to credit card details. This can help detect
      and respond to suspicious behavior or security incidents.
  title: Automatic information enumeration - Credit Cards
  vulnerability_id: '254'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of cipher for encrypting and decrypting data
  need: Secure encryption algorithm for protecting sensitive information
  solution:
    insecure_code_example:
      description: "The above Dart code is a simple example of using the Blowfish\
        \ encryption algorithm to encrypt some data. Blowfish is a symmetric-key block\
        \ cipher, which means that the same key is used for both encryption and decryption.\
        \ \n\nIn the code, we first import the necessary packages. Then we initialize\
        \ the cipher and define the key and the parameters for the cipher. The key\
        \ is a 16-byte array, and the parameters include the key and an 8-byte initialization\
        \ vector (IV). \n\nWe then create a new instance of the Blowfish cipher and\
        \ initialize it with the parameters. After that, we define some data that\
        \ we want to encrypt, which is an 8-byte array in this case. Finally, we use\
        \ the cipher to encrypt the data.\n\nHowever, this code is vulnerable because\
        \ it uses the insecure Blowfish encryption algorithm. Blowfish has a block\
        \ size of 64 bits, which is considered too small by today's standards. It\
        \ is susceptible to birthday attacks, which can be used to find collisions\
        \ in the encryption. Also, the keys used in the example are static and hard-coded,\
        \ which is a bad practice as it makes the encryption easier to break."
      text: "import 'package:cipher/cipher.dart';\nimport 'package:cipher/impl/base.dart';\n\
        \nvoid main() {\n  initCipher();\n\n  final key = new KeyParameter(new Uint8Array.fromList([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]));\n\
        \  final params = new ParametersWithIV(key, new Uint8Array.fromList([1,2,3,4,5,6,7,8]));\n\
        \  \n  final cipher = new BlockCipher('Blowfish');\n  cipher.init(true, params);\n\
        \n  // assuming binary data\n  Uint8List data = Uint8List.fromList([1,2,3,4,5,6,7,8]);\n\
        \  Uint8List encryptedData = cipher.process(data);\n}"
    language: dart
    secure_code_example:
      description: "The above code replaces the insecure Blowfish encryption algorithm\
        \ with the more secure AES (Advanced Encryption Standard) algorithm. \n\n\
        The `secureRandom()` function is used to generate a secure random number generator,\
        \ which is used to generate the encryption key and the Initialization Vector\
        \ (IV). The key is 256 bits long, and the IV is 128 bits long, which are both\
        \ suitable lengths for AES encryption.\n\nThe `randomBytes()` function is\
        \ used to generate a random byte array of a specified length using the secure\
        \ random number generator.\n\nThe `KeyParameter` and `ParametersWithIV` classes\
        \ are used to create the parameters for the AES encryption, including the\
        \ key and the IV.\n\nThe `PaddedBlockCipher` class is used to perform the\
        \ AES encryption in CBC mode with PKCS7 padding. The `init()` method is used\
        \ to initialize the cipher for encryption with the specified parameters, and\
        \ the `process()` method is used to encrypt the data.\n\nThis code should\
        \ be more secure than the original code, as it uses a more secure encryption\
        \ algorithm and secure methods to generate the key and IV. However, it should\
        \ still be tested thoroughly to ensure that it works as expected and does\
        \ not introduce new vulnerabilities."
      text: |-
        import 'package:pointycastle/pointycastle.dart';
        import 'dart:typed_data';
        import 'dart:math';
        import 'dart:convert';

        void main() {
          final secureRandom = _secureRandom();

          // Generate 256-bit random key
          final key = _randomBytes(32, secureRandom);

          // Generate 128-bit random IV
          final iv = _randomBytes(16, secureRandom);

          final params = ParametersWithIV(KeyParameter(key), iv);

          // Use AES encryption
          final cipher = PaddedBlockCipher("AES/CBC/PKCS7");
          cipher.init(true, params);

          // Assuming binary data
          Uint8List data = Uint8List.fromList([1,2,3,4,5,6,7,8]);
          Uint8List encryptedData = cipher.process(data);
        }

        Uint8List _randomBytes(int length, SecureRandom secureRandom) {
          final key = Uint8List(length);
          for (var i = 0; i < length; i++) {
            key[i] = secureRandom.nextUint8();
          }
          return key;
        }

        SecureRandom _secureRandom() {
          final secureRandom = FortunaRandom();

          final random = Random.secure();
          final seeds = <int>[];
          for (var i = 0; i < 32; i++) {
            seeds.add(random.nextInt(255));
          }
          secureRandom.seed(KeyParameter(Uint8List.fromList(seeds)));

          return secureRandom;
        }
    steps:
    - Replace the Blowfish encryption algorithm with a more secure one, such as AES
      (Advanced Encryption Standard).
    - Ensure that the new encryption algorithm is properly implemented in the code,
      replacing all instances of Blowfish.
    - Use a secure method to generate and store the encryption key. The key should
      be long and complex enough to prevent brute force attacks.
    - Use a secure method to generate the Initialization Vector (IV). The IV should
      be random and unique for each encryption operation.
    - Test the new encryption implementation to ensure it works as expected and does
      not introduce new vulnerabilities.
  title: Insecure encryption algorithm - Blowfish
  vulnerability_id: '269'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure and enforce server-side restrictions on file creation functionality
  solution:
    insecure_code_example:
      description: "The code above represents a simple server using the Shelf framework\
        \ in Dart. It has a single endpoint that creates a file with a name specified\
        \ in the query parameters of the request. \n\nThe vulnerability lies in the\
        \ `createFileHandler` function. This function takes a request, extracts the\
        \ filename from the query parameters, and creates a file with that name. The\
        \ problem is that there is no check for user permissions before creating the\
        \ file. This means that even if a user's profile restricts file creation,\
        \ they can still create a file by sending a request to this endpoint.\n\n\
        In the `main` function, this handler is added to the server pipeline without\
        \ any middleware that would check for user permissions. This means that any\
        \ request that reaches the `createFileHandler` can create a file, regardless\
        \ of the user's permissions.\n\nThis is an example of insecure functionality\
        \ where the restriction (in this case, the restriction on file creation) is\
        \ only enforced on the front end by disabling a button. A malicious user can\
        \ bypass this front-end restriction by manually sending a request to the server.\
        \ Because the server does not check for user permissions before processing\
        \ the request, the file creation will be successful even if the user's profile\
        \ restricts this function."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        Future<shelf.Response> createFileHandler(shelf.Request request) async {
          var fileName = request.url.queryParameters['fileName'];

          // Create the file without checking user permissions
          var file = File(fileName);
          await file.create();

          return shelf.Response.ok('File created successfully');
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(createFileHandler);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code introduces an authentication middleware using the `shelf_auth` package. This middleware authenticates the user before any request is processed. The `JwtAuthenticator` is used in this case, which authenticates users based on JSON Web Tokens (JWT). The 'sharedSecret' is the secret key used to sign the JWTs.

        In the `createFileHandler` function, we first retrieve the authenticated user from the request context. If the user is not authenticated or does not have the necessary permissions to create files (checked using a hypothetical `canCreateFiles` property on the `User` model), a 403 Forbidden response is returned.

        If the user is authenticated and has the necessary permissions, the file creation process proceeds as before.

        This ensures that only authenticated users with the necessary permissions can create files, addressing the vulnerability in the original code. The server-side checks for user permissions ensure that the function cannot be bypassed by manipulating the front-end.

        Please note that this code assumes the existence of a `User` model with a `canCreateFiles` property. You will need to replace this with your actual user model and permission checking logic.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_auth/shelf_auth.dart';

        Future<shelf.Response> createFileHandler(shelf.Request request) async {
          var user = request.context['user'] as User;
          if (user == null || !user.canCreateFiles) {
            return shelf.Response.forbidden('You do not have permission to create files');
          }

          var fileName = request.url.queryParameters['fileName'];

          // Create the file after checking user permissions
          var file = File(fileName);
          await file.create();

          return shelf.Response.ok('File created successfully');
        }

        void main() {
          var authMiddleware = authenticate([new JwtAuthenticator('sharedSecret')]);

          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(authMiddleware)
              .addHandler(createFileHandler);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    steps:
    - Introduce an authentication middleware to verify the user's identity before
      processing the request.
    - Implement an authorization check in the 'createFileHandler' function to verify
      if the authenticated user has the necessary permissions to create a file.
    - Do not rely solely on the front-end to disable certain functions based on user
      profiles. Always perform server-side checks to validate user permissions.
    - Consider using role-based access control (RBAC) or similar access control mechanisms
      to manage user permissions effectively.
    - Ensure that the file creation process is secure and does not allow for arbitrary
      file creation which could lead to security issues.
  title: Insecure functionality - File Creation
  vulnerability_id: '270'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Secure password management
  solution:
    insecure_code_example:
      description: "The above Dart code represents a simple backend application using\
        \ the Shelf framework. The application stores a list of users, with each user\
        \ having a username and password. \n\nThe `handleRequest` function is the\
        \ main point of vulnerability in this code. It takes in a `shelf.Request`\
        \ object, which contains the new password and the username for which the password\
        \ is to be changed in the url query parameters. The function then iterates\
        \ over the list of users and if it finds a user with the given username, it\
        \ changes that user's password to the new password provided in the request.\n\
        \nThe main vulnerability here is that there is no session management or authentication\
        \ mechanism in place to verify whether the request to change the password\
        \ is coming from the user who owns the account. This means that if a malicious\
        \ user knows the username of another user, they can easily change their password\
        \ and gain access to their account. This is a serious security flaw as it\
        \ can lead to unauthorized access and potential data breaches."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class User {
          String username;
          String password;
          User(this.username, this.password);
        }

        var users = <User>[
          User('user1', 'password1'),
          User('user2', 'password2'),
        ];

        shelf.Response handleRequest(shelf.Request request) {
          var newPass = request.url.queryParameters['newPass'];
          var username = request.url.queryParameters['username'];

          for (var user in users) {
            if (user.username == username) {
              user.password = newPass;
              break;
            }
          }

          return shelf.Response.ok('Password changed successfully');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a session management system. This system checks if the session ID provided in the request headers is valid and belongs to the user who is trying to change the password. If the session is invalid or belongs to a different user, the server responds with a 403 Forbidden status.

        Before changing the password, the server also checks if the current password provided in the request is correct. This is done by hashing the provided password and comparing it with the stored hash. If the hashes don't match, the server responds with a 403 Forbidden status.

        The password is stored as a hash instead of plain text. This is done by using the SHA-256 algorithm from the `crypto` package. Storing passwords as hashes increases security because even if someone gains access to the database, they won't be able to see the actual passwords.

        The code does not yet include rate limiting to prevent brute force attacks. This would be a good next step to further increase the security of the password change functionality.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:crypto/crypto.dart';
        import 'dart:convert'; // for the utf8.encode method

        class User {
          String username;
          String password;
          User(this.username, this.password);
        }

        var users = <User>[
          User('user1', 'password1'),
          User('user2', 'password2'),
        ];

        // Add a session management system
        var sessions = <String, User>{};

        shelf.Response handleRequest(shelf.Request request) {
          var newPass = request.url.queryParameters['newPass'];
          var username = request.url.queryParameters['username'];
          var sessionId = request.headers['session-id'];

          // Check if the session is valid and belongs to the user
          if (sessions[sessionId]?.username != username) {
            return shelf.Response.forbidden('Invalid session');
          }

          // Check if the current password is correct
          var currentPass = request.url.queryParameters['currentPass'];
          var currentPassHash = sha256.convert(utf8.encode(currentPass)).toString();
          if (users.firstWhere((user) => user.username == username).password != currentPassHash) {
            return shelf.Response.forbidden('Invalid current password');
          }

          // Change the password
          var newPassHash = sha256.convert(utf8.encode(newPass)).toString();
          users.firstWhere((user) => user.username == username).password = newPassHash;

          return shelf.Response.ok('Password changed successfully');
        }
    steps:
    - Authenticate the user before allowing them to change the password. This can
      be done by checking if the current session belongs to the user whose password
      is being changed.
    - Implement a secure session management system that prevents one user from accessing
      another user's session.
    - Use secure methods to change passwords, such as requiring the current password
      before allowing a new one to be set.
    - Encrypt the password before storing it in the database. This way, even if someone
      gains access to the database, they won't be able to see the actual passwords.
    - Implement rate limiting to prevent brute force attacks on the password change
      functionality.
  title: Insecure functionality - Password management
  vulnerability_id: '271'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Secure data masking
  solution:
    insecure_code_example:
      description: "In the above code, the `handleRequest` function is handling the\
        \ incoming request. It retrieves the 'user' and 'password' from the request\
        \ headers and then processes them. This is a security vulnerability because\
        \ the sensitive information like 'user' and 'password' are being transferred\
        \ in plain text format within the headers of the request. \n\nThis is an insecure\
        \ functionality as the sensitive data is not being masked or encrypted in\
        \ any way. Anyone who is able to intercept this request would be able to see\
        \ this information. This could potentially lead to unauthorized access to\
        \ the system if the intercepted credentials are valid. \n\nMoreover, the server\
        \ logs all the requests including their headers using `shelf.logRequests()`\
        \ middleware. This means that the sensitive data (user and password) are being\
        \ stored in the server logs in plain text format. Again, this is a security\
        \ vulnerability as anyone with access to these logs would be able to retrieve\
        \ this sensitive information. \n\nTo fix this vulnerability, the sensitive\
        \ data should be masked or encrypted before being sent in the request and/or\
        \ response. The server should also be configured to not log sensitive information."
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  var user = request.headers['user'];\n  var password = request.headers['password'];\n\
        \  \n  // Do something with user and password\n\n  return shelf.Response.ok('Request\
        \ handled.');\n}\n\nvoid main() {\n  var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);\n\
        \n  shelf.serve(handler, 'localhost', 8080).then((server) {\n    print('Serving\
        \ at http://${server.address.host}:${server.port}');\n  });\n}"
    language: dart
    secure_code_example:
      description: |-
        The updated code now uses the POST method to receive sensitive data such as username and password. This is a more secure method than passing such data in the request headers. The data is read from the request body and then parsed as JSON.

        The password is then hashed using the SHA-256 algorithm from the `crypto` package. This ensures that the password is not stored or handled in plain text, which is a major security vulnerability. Instead, a hashed version of the password is used, which can't be reversed to get the original password.

        The code also checks if the request method is POST, and if it's not, it returns a 403 Forbidden response. This is a simple form of access control, ensuring that only requests with the correct method can proceed.

        Please note that this code does not include SSL/TLS implementation, session management, error handling, and system patching. These are important security measures that should be implemented in a real-world application, but they are beyond the scope of this code snippet.
      text: |-
        import 'dart:convert';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:crypto/crypto.dart';

        shelf.Response handleRequest(shelf.Request request) async {
          if (request.method != 'POST') {
            return shelf.Response.forbidden('Forbidden');
          }

          var body = await request.readAsString();
          var data = jsonDecode(body);
          var user = data['user'];
          var password = data['password'];

          // Hash the password
          var bytes = utf8.encode(password);
          var digest = sha256.convert(bytes);

          // Do something with user and hashed password

          return shelf.Response.ok('Request handled.');
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    steps:
    - Avoid passing sensitive information like username and password in the request
      headers. Use secure methods like POST for sending such data.
    - Implement SSL/TLS to encrypt the data during transmission. This will ensure
      that even if someone intercepts the data, they won't be able to understand it.
    - Use a secure method for storing passwords. Never store passwords in plain text.
      Use hashing algorithms like bcrypt to store passwords.
    - Implement proper access controls to ensure that only authorized users can access
      sensitive data.
    - Use a secure session management system. This will ensure that even if a user's
      session is hijacked, the attacker won't be able to access sensitive data.
    - Implement proper error handling. Never reveal sensitive information in error
      messages.
    - Regularly update and patch your systems to protect against known vulnerabilities.
  title: Insecure functionality - Masking
  vulnerability_id: '272'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_router for creating a router in a Shelf application
  - Usage of dart:convert for encoding and decoding data in Dart
  need: Secure and controlled user data updates
  solution:
    insecure_code_example:
      description: "The above code represents a simple Dart backend application using\
        \ the `shelf` framework. \n\nThe vulnerability lies within the `UserController`\
        \ class, specifically the `_updateUser` method. This method is responsible\
        \ for handling POST requests to the `/updateUser` endpoint. \n\nWhen a POST\
        \ request is made to this endpoint, the method reads the request body, which\
        \ is expected to be a JSON object containing a `userId` and `userData`. It\
        \ then directly uses these values to update the user data in the database\
        \ with the `updateUserInDatabase` function.\n\nThe problem here is that there\
        \ is no authentication or authorization process in place to verify the identity\
        \ of the user making the request. This means that any user, even if they're\
        \ not the owner of the account, can send a POST request to this endpoint with\
        \ any `userId` and `userData` they want, and the server will update the user\
        \ data in the database without question.\n\nThis is a serious security flaw,\
        \ as it could allow malicious users to change other users' data, leading to\
        \ potential data corruption, privacy violations, and other issues."
      text: |
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'dart:convert';

        class UserController {
          final Router _router;

          UserController(this._router) {
            _router.post('/updateUser', _updateUser);
          }

          shelf.Response _updateUser(shelf.Request request) async {
            final body = jsonDecode(await request.readAsString()) as Map<String, dynamic>;

            String userId = body['userId'];
            String userData = body['userData'];

            // update user data in database
            updateUserInDatabase(userId, userData);

            return shelf.Response.ok('User data updated');
          }

          void updateUserInDatabase(String userId, String userData) {
            // This function updates the user data in the database
          }
        }

        void main() {
          final router = Router();
          UserController(router);

          // start server
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several middleware functions that are executed before the `_updateUser` function. These middleware functions are used to authenticate the user, authorize the user, validate the input data, and implement rate limiting.

        The `_authenticate` function is used to verify the user's identity. This can be done by checking the user's credentials against a database or another trusted source.

        The `_authorize` function is used to check if the user has the necessary permissions to update the data. This can be done by checking the user's role or permissions in the system.

        The `_validateInput` function is used to ensure that the input data is in the correct format and does not contain any malicious content. This can be done by using a schema validation library or writing custom validation logic.

        The `_rateLimit` function is used to prevent brute force attacks by limiting the number of requests a user can make within a certain time period.

        The `_updateUser` function now also includes a call to the `logUpdateAttempt` function, which logs all attempts to update user data. This can be useful for auditing purposes and for identifying potential security threats.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'dart:convert';

        class UserController {
          final Router _router;

          UserController(this._router) {
            _router.post('/updateUser', _authenticate, _authorize, _validateInput, _rateLimit, _updateUser);
          }

          shelf.Middleware _authenticate(shelf.Request request) {
            // Implement authentication logic here
          }

          shelf.Middleware _authorize(shelf.Request request) {
            // Implement authorization logic here
          }

          shelf.Middleware _validateInput(shelf.Request request) {
            // Implement input validation logic here
          }

          shelf.Middleware _rateLimit(shelf.Request request) {
            // Implement rate limiting logic here
          }

          shelf.Response _updateUser(shelf.Request request) async {
            final body = jsonDecode(await request.readAsString()) as Map<String, dynamic>;

            String userId = body['userId'];
            String userData = body['userData'];

            // update user data in database
            updateUserInDatabase(userId, userData);

            // Log the update attempt
            logUpdateAttempt(userId, userData);

            return shelf.Response.ok('User data updated');
          }

          void updateUserInDatabase(String userId, String userData) {
            // This function updates the user data in the database
          }

          void logUpdateAttempt(String userId, String userData) {
            // This function logs the update attempt
          }
        }

        void main() {
          final router = Router();
          UserController(router);

          // start server
        }
    steps:
    - Authenticate the user before allowing them to update data. This can be done
      by implementing an authentication middleware that verifies the user's identity
      before processing the request.
    - Authorize the user to ensure they have the necessary permissions to update the
      data. This can be done by checking the user's role or permissions in the system.
    - Validate the input data to ensure it is in the correct format and does not contain
      any malicious content. This can be done by using a schema validation library
      or writing custom validation logic.
    - Implement rate limiting to prevent brute force attacks. This can be done by
      tracking the number of requests from a user within a certain time period and
      blocking them if they exceed the limit.
    - Log all attempts to update user data for auditing purposes. This can be done
      by using a logging library or service.
  title: Insecure functionality - Fingerprint
  vulnerability_id: '273'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance web and mobile applications
  - Usage of dart:io for handling input and output operations in Dart programming
  - Usage of the shelf package in Dart for building web applications and HTTP middleware
  need: Secure storage of confidential information on local devices
  solution:
    insecure_code_example:
      description: "In the above Dart code, we are using the Shelf framework to create\
        \ a backend server. The server is set up to listen to requests on `localhost`\
        \ at port `8080`. \n\nThe function `_echoRequest` is designed to handle incoming\
        \ requests. It takes a `shelf.Request` as a parameter and returns a `shelf.Response`.\n\
        \nThe vulnerability lies in the way we are handling the confidential Firebase\
        \ data. We are storing this data in a local file named `local.txt` using the\
        \ `writeAsString` method. This method writes a string to a file, creating\
        \ the file if it doesn't already exist. \n\nHowever, the data is being written\
        \ as plain text, without any form of encryption. This means that anyone who\
        \ gains access to the device and bypasses its security mechanisms can easily\
        \ read the confidential Firebase data. This is a serious security concern\
        \ as it can lead to data breaches and unauthorized access to sensitive information.\
        \ \n\nIn the case of theft or loss of the device, the attacker can easily\
        \ access and exploit this confidential information. Therefore, it is crucial\
        \ to encrypt any sensitive data before storing it in the device's local storage."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var firebaseData = 'Confidential Firebase Data';
          File('local.txt').writeAsString(firebaseData);
          return shelf.Response.ok('Data Saved!');
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes the 'encrypt' library, which is\
        \ used to encrypt the confidential Firebase data before it is stored in the\
        \ local file. \n\nAn encryption key and an initialization vector are generated\
        \ using the `Key.fromLength` and `IV.fromLength` methods respectively. These\
        \ are used to create an `Encrypter` object, which is then used to encrypt\
        \ the Firebase data.\n\nThe encrypted data is then written to the local file.\
        \ This ensures that even if an attacker gains access to the physical device\
        \ and bypasses the device security mechanism, they will not be able to view\
        \ the confidential data without the encryption key and initialization vector.\n\
        \nPlease note that the encryption key and initialization vector should be\
        \ securely generated and stored, not hardcoded in the application as shown\
        \ in this example. This is to prevent an attacker from easily obtaining these\
        \ values and decrypting the data.\n\nAlso, when reading the data from the\
        \ file, it should be decrypted using the same key and initialization vector.\
        \ This ensures that the data is not exposed in its plain form at any point."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:encrypt/encrypt.dart' as encrypt;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var firebaseData = 'Confidential Firebase Data';

          // Create an encryption key and an initialization vector
          final key = encrypt.Key.fromLength(32); // example of generating a secure random key
          final iv = encrypt.IV.fromLength(16); // example of generating a secure random initialization vector

          // Create an encrypter
          final encrypter = encrypt.Encrypter(encrypt.AES(key));

          // Encrypt the data
          final encryptedData = encrypter.encrypt(firebaseData, iv: iv);

          // Write the encrypted data to the file
          File('local.txt').writeAsString(encryptedData.base64);

          return shelf.Response.ok('Data Saved!');
        }
    steps:
    - Import a library that provides encryption functionality such as 'encrypt' in
      Dart.
    - Create an encryption key and an initialization vector. The key should be securely
      generated and stored, not hardcoded in the application.
    - Before writing the firebase data to the file, encrypt it using the encryption
      key and initialization vector.
    - When reading the data from the file, decrypt it using the same key and initialization
      vector.
    - Ensure that the encryption and decryption processes are correctly implemented
      and that the data is not exposed in its plain form at any point.
  title: Non-encrypted confidential information - Local data
  vulnerability_id: '275'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Secure transmission of sensitive information in session tokens
  solution:
    insecure_code_example:
      description: |-
        In the code above, we are using the Shelf framework to handle HTTP requests in a Dart backend application.

        The `handleRequest` function is designed to handle incoming requests. It extracts the session token (JWT) from the URL query parameters using `request.url.queryParameters['sessionToken']`.

        The problem with this approach is that the session token is being sent via the URL. URLs are often logged by web servers and can also be stored in the user's browser history. This exposes the session token to potential attackers who gain access to these logs or the user's machine.

        This is a significant security vulnerability because the session token is sensitive information that should be kept secret. If an attacker gets hold of a user's session token, they can impersonate that user and potentially perform malicious actions on their behalf.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var sessionToken = request.url.queryParameters['sessionToken'];

          // Do something with the sessionToken

          return shelf.Response.ok('Request handled');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now retrieves the JWT session token from the 'Authorization' HTTP header field instead of the URL parameters. This is done by calling `request.headers['authorization']`.

        The code then checks if the 'Authorization' header is null or if it does not start with 'Bearer '. If either of these conditions is true, the server responds with a 403 Forbidden status code and a message indicating that the 'Authorization' header is missing or invalid. This is done using `shelf.Response.forbidden('Missing or invalid Authorization header')`.

        If the 'Authorization' header is present and correctly formatted, the code extracts the JWT session token from it by calling `authHeader.substring(7)`. This removes the 'Bearer ' prefix from the header value, leaving only the session token.

        The session token can then be used as before, but it is now transmitted in a way that prevents it from being cached in the browsing history.

        Remember to update the client-side code to send the session token in the 'Authorization' header field instead of the URL parameters. Also, ensure that the server is configured to accept and parse the 'Authorization' header field from incoming requests.

        Finally, test the updated code to ensure that it works as expected and the session token is no longer exposed in the URL.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var authHeader = request.headers['authorization'];
          if (authHeader == null || !authHeader.startsWith('Bearer ')) {
            return shelf.Response.forbidden('Missing or invalid Authorization header');
          }

          var sessionToken = authHeader.substring(7);

          // Do something with the sessionToken

          return shelf.Response.ok('Request handled');
        }
    steps:
    - Instead of sending the JWT session token via URL parameters, send it in the
      HTTP header. This prevents the token from being cached in the browsing history.
    - Use the 'Authorization' header field to transmit the session token. The value
      of this field should be 'Bearer ' followed by the JWT session token.
    - Ensure that the server is configured to accept and parse the 'Authorization'
      header field from incoming requests.
    - Update the client-side code to send the session token in the 'Authorization'
      header field instead of the URL parameters.
    - Finally, test the updated code to ensure that it works as expected and the session
      token is no longer exposed in the URL.
  title: Sensitive information sent via URL parameters - Session
  vulnerability_id: '276'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Prevention of unexpected behavior caused by NullPointer exceptions
  solution:
    insecure_code_example:
      description: "The above Dart code is using the Shelf framework to create a server.\
        \ The server handles requests using the `_handleRequest` function. \n\nIn\
        \ this function, there is a try-catch block. The catch block is designed to\
        \ handle any exceptions that occur in the try block. However, it's not specific\
        \ about which exceptions it's handling. This means that if a `NullPointerException`\
        \ is thrown, it will be caught by this catch block and the server will simply\
        \ print the exception and continue to operate as if nothing happened. \n\n\
        This is a problem because `NullPointerExceptions` are often indicative of\
        \ serious issues in the code, such as trying to access a property or method\
        \ of a null object. If these exceptions are simply caught and ignored, it\
        \ can lead to unpredictable behavior in the application, as well as make it\
        \ much more difficult to debug and fix the underlying issue. \n\nThe code\
        \ is vulnerable because it's not properly handling `NullPointerExceptions`.\
        \ Instead of simply catching and ignoring these exceptions, the code should\
        \ be written in such a way as to prevent them from occurring in the first\
        \ place. If they do occur, they should be properly logged and the server should\
        \ respond with an appropriate error message or error code."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_handleRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _handleRequest(shelf.Request request) {
          try {
            // Some code here that might throw a NullPointerException
          } catch (e) {
            print("An exception occurred: $e");
            return shelf.Response.ok('Hello, World!\\n');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now handles `NullPointerException` specifically. This is done by adding an `if` condition inside the `catch` block to check if the exception is a `NullPointerException`. If it is, a specific message is printed to the console and the exception can be handled in a specific way. This could be by returning a default value, logging the error, or rethrowing the exception to be handled at a higher level.

        The rest of the exceptions are caught by the `else` block, which prints a generic message to the console. This ensures that only expected exceptions are caught and handled, reducing the risk of unexpected behavior in the system.

        Finally, it's important to ensure that all objects are properly initialized before they are used. This can help prevent `NullPointerExceptions` from occurring in the first place.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_handleRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _handleRequest(shelf.Request request) {
          try {
            // Some code here that might throw a NullPointerException
          } catch (e) {
            if (e is NullPointerException) {
              print("A null pointer exception occurred: $e");
              // Handle NullPointerException specifically here
              // You can return a default value, log the error, or rethrow the exception
            } else {
              print("An exception occurred: $e");
            }
            return shelf.Response.ok('Hello, World!\\n');
          }
        }
    steps:
    - Firstly, avoid catching generic exceptions. Instead, catch specific exceptions
      that you expect might be thrown in the try block.
    - Secondly, handle the NullPointerException specifically. This can be done by
      adding another catch block for NullPointerException.
    - Thirdly, in the catch block for NullPointerException, handle the exception in
      a way that does not disrupt the flow of the program. This could be by returning
      a default value, logging the error, or rethrowing the exception to be handled
      at a higher level.
    - Finally, always ensure that all objects are properly initialized before they
      are used. This can help prevent NullPointerExceptions from occurring in the
      first place.
  title: Insecure exceptions - NullPointerException
  vulnerability_id: '278'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of crypto for cryptographic operations
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Implementation of secure encryption algorithms
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is an example of a backend application that uses the Shelf framework and has a middleware for handling encryption. The encryption process is done using the ECB (Electronic Codebook) mode of operation for a block cipher, which is insecure.

        The `handleEncryption` function is a middleware function that reads the request content, encrypts it using the `_encrypt` function, and then passes the request with the encrypted content to the next middleware.

        The `_encrypt` function takes a string, converts it to bytes, encrypts the bytes using the ECB mode with a secret key, and then encodes the encrypted bytes to a base64 string.

        The main issue with this code is that it uses the ECB mode for encryption, which is insecure because it encrypts identical plaintext blocks into identical ciphertext blocks, making it vulnerable to various attacks, such as replay and block swapping attacks. This mode of operation does not provide serious message confidentiality, and it is not recommended for use in cryptographic protocols at all.
      text: |-
        import 'dart:convert';
        import 'dart:typed_data';
        import 'package:crypto/crypto.dart';
        import 'package:shelf/shelf.dart';

        var key = utf8.encode('my_secret_key');

        Middleware handleEncryption() {
          return (Handler innerHandler) {
            return (Request request) async {
              var content = await request.readAsString();
              var encryptedData = _encrypt(content);
              return innerHandler(Request(request.method, request.requestedUri,
                  body: encryptedData, headers: request.headers));
            };
          };
        }

        String _encrypt(String data) {
          var bytes = utf8.encode(data);
          var encrypted = BlockCipher(Modes.ecb, key).process(bytes);
          return base64.encode(encrypted);
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was using the ECB (Electronic Codebook) mode for encryption, which is insecure because it does not use an initialization vector (IV) and thus the same plaintext block will always encrypt to the same ciphertext block. This makes it vulnerable to pattern analysis.

        The updated code uses the CBC (Cipher Block Chaining) mode for encryption, which is more secure because it uses an IV to add randomness to the encryption. This means that the same plaintext block will encrypt to different ciphertext blocks each time, making pattern analysis much more difficult.

        The key and IV are generated from a secret key string. In a real application, this secret key should be securely generated and stored, not hard-coded into the application as it is here.

        The `encrypt` library is used to provide higher-level encryption features. This can help to avoid common mistakes and vulnerabilities. The `encrypt.AES` class is used to create an AES (Advanced Encryption Standard) encrypter, and the `encrypter.encrypt` method is used to encrypt the data.

        The encrypted data is then base64-encoded to create a string that can be safely transmitted or stored. The IV is prepended to the encrypted data, so it can be used for decryption.
      text: |-
        import 'dart:convert';
        import 'dart:typed_data';
        import 'package:crypto/crypto.dart';
        import 'package:shelf/shelf.dart';
        import 'package:encrypt/encrypt.dart' as encrypt;

        var key = encrypt.Key.fromUtf8('my_secret_key');
        var iv = encrypt.IV.fromLength(16);

        Middleware handleEncryption() {
          return (Handler innerHandler) {
            return (Request request) async {
              var content = await request.readAsString();
              var encryptedData = _encrypt(content);
              return innerHandler(Request(request.method, request.requestedUri,
                  body: encryptedData, headers: request.headers));
            };
          };
        }

        String _encrypt(String data) {
          final encrypter = encrypt.Encrypter(encrypt.AES(key, mode: encrypt.AESMode.cbc));
          final encrypted = encrypter.encrypt(data, iv: iv);
          return encrypted.base64;
        }
    steps:
    - Replace the ECB mode with a more secure mode such as CBC, CFB, or GCM. These
      modes use an initialization vector (IV) to add randomness to the encryption,
      making it more secure.
    - Generate a random IV for each encryption operation and prepend it to the encrypted
      data. This IV will be needed for decryption, so it must be stored or transmitted
      with the encrypted data.
    - Ensure that the key and IV are kept secret and secure. They should not be hard-coded
      into the application, but instead should be securely generated and stored.
    - Consider using a library or framework that provides higher-level encryption
      features. These can help to avoid common mistakes and vulnerabilities.
  title: Insecure encryption algorithm - ECB
  vulnerability_id: '282'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing database queries and data modeling
  - Usage of shelf_io for managing input/output operations in a Shelf application
  need: Prevention of unauthorized access to personal information
  solution:
    insecure_code_example:
      description: "The above code represents a Dart backend application using the\
        \ Shelf framework. The `main` function sets up a server that listens on localhost\
        \ at port 8080. The server is configured to log all requests and handle them\
        \ using the `_echoRequest` function.\n\nThe `_echoRequest` function is where\
        \ the vulnerability lies. This function takes the incoming request and extracts\
        \ the 'user' parameter from the URL query parameters. It then returns this\
        \ information in the response. \n\nThis is vulnerable to Automatic Information\
        \ Enumeration, as it allows anyone to view the user data by simply sending\
        \ a request with the appropriate 'user' parameter. Since there is no token\
        \ or authentication mechanism in place to verify the identity of the requestor,\
        \ this can lead to unauthorized access to other users' data."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var user = request.url.queryParameters['user'];
          return new shelf.Response.ok('User: $user');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes an authentication middleware that uses JWT (JSON Web Tokens) for user authentication. The `authenticate` function is a middleware that checks if the request has a valid JWT in the `Authorization` header. If the JWT is valid, it adds the user's ID to the request context and passes the request to the next middleware or handler. If the JWT is not valid or not present, it returns a 403 Forbidden response.

        The `JwtAuthMiddleware` class is an `Authenticator` that verifies the JWT and extracts the user's ID from it. The `authenticate` method of this class is called for each request. If the `Authorization` header is present and contains a valid JWT, it verifies the JWT, extracts the user's ID from it, and adds it to the request context. If the JWT is not valid, it returns null, which causes the `authenticate` middleware to return a 403 Forbidden response.

        The `_echoRequest` handler now gets the user's ID from the request context instead of the query parameters. This ensures that the user can only access their own information.

        This code also uses the `shelf_auth` and `jaguar_jwt` packages for JWT authentication. The `shelf_auth` package provides the `Authenticator` interface and the `authenticate` middleware. The `jaguar_jwt` package provides functions for creating and verifying JWTs.

        This code fixes the vulnerability by ensuring that only authenticated users can access user information, and that they can only access their own information. It also provides an extra layer of security by using JWTs, which are encrypted and signed, for authentication.
      text: |-
        import 'dart:convert';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_auth/shelf_auth.dart';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:jaguar_jwt/jaguar_jwt.dart';

        const String secret = 'secret';

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(authenticate([new JwtAuthMiddleware(secret)]))
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var user = request.context['auth'] as Map<String, dynamic>;
          var userId = user['id'];
          return new shelf.Response.ok('User: $userId');
        }

        Middleware authenticate(List<Authenticator> authenticators) {
          return (shelf.Handler innerHandler) {
            return (shelf.Request request) async {
              for (var authenticator in authenticators) {
                var authedRequest = await authenticator.authenticate(request);
                if (authedRequest != null) {
                  return innerHandler(authedRequest);
                }
              }
              return new shelf.Response.forbidden('Forbidden');
            };
          };
        }

        class JwtAuthMiddleware extends Authenticator {
          final String secret;

          JwtAuthMiddleware(this.secret);

          @override
          Future<shelf.Request> authenticate(shelf.Request request) async {
            var authHeader = request.headers['authorization'];
            if (authHeader != null && authHeader.startsWith('Bearer ')) {
              var jwtToken = authHeader.substring(7);
              var claimSet = verifyJwtHS256Signature(jwtToken, secret);
              var userId = claimSet.subject;
              return request.change(context: {'auth': {'id': userId}});
            }
            return null;
          }
        }
    steps:
    - Implement authentication middleware to verify the identity of the user making
      the request.
    - Use tokens (like JWT) to authenticate users. The token should be sent with each
      request and validated on the server.
    - Ensure that the token is associated with the account and is used to consult
      the information.
    - Restrict access to user information based on the authenticated user's permissions.
      Only allow users to access their own information.
    - Encrypt sensitive data to add an extra layer of security.
    - Implement rate limiting to prevent brute force attacks.
  title: Automatic information enumeration - Personal Information
  vulnerability_id: '283'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance web and mobile applications
  - Usage of Shelf for managing data persistence and querying in Node.js
  - Usage of shelf_router for routing and handling HTTP requests in a Shelf application
  need: Secure access control and protection of personal information
  solution:
    insecure_code_example:
      description: |-
        The above code is a simple backend server written in Dart using the Shelf framework. It has two endpoints, one for getting a user's information (`/user/<id>`) and another for updating a user's information (`/user/<id>`).

        The vulnerability lies in the fact that the unique identifier (`id`) used to distinguish each user can be manipulated by the client. This `id` is directly passed to the `_getUser` and `_updateUser` functions without any form of authentication or authorization.

        In the `_getUser` function, the `id` is used to fetch a user's information from the database. This means a malicious client could potentially retrieve any user's information by simply changing the `id` in the request URL.

        Similarly, in the `_updateUser` function, the `id` is used to update a user's information in the database. This allows a malicious client to modify any user's information by simply changing the `id` in the request URL and sending a POST request with the new user information.

        This is a classic example of an Insecure Direct Object References (IDOR) vulnerability, where the application exposes a reference to an internal implementation object, such as a file, directory, or database key without any proper validation or authorization.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class UserController {
          final Router _router;

          UserController(this._router) {
            _router.add('GET', '/user/<id>', _getUser);
            _router.add('POST', '/user/<id>', _updateUser);
          }

          shelf.Response _getUser(shelf.Request request, String id) {
            // Fetch user with id from database
            var user = getUserFromDB(id);
            return shelf.Response.ok(user.toJson());
          }

          shelf.Response _updateUser(shelf.Request request, String id) {
            // Get body of request
            var body = jsonDecode(await request.readAsString());
            // Update user with id in database
            updateUserInDB(id, body);
            return shelf.Response.ok('User updated');
          }
        }

        void main() {
          final router = Router();

          UserController(router);

          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(router);

          io.serve(handler, 'localhost', 8080);
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes an authentication middleware that uses JWT (JSON Web Tokens) for user authentication. The `shelf_auth` package is used to provide this functionality. The `JwtAuthenticator` is configured with a shared secret key and is set to verify the JWT on every request.

        In the `getUser` and `updateUser` methods, we now check if the authenticated user's ID matches the ID in the request. If they do not match, a 403 Forbidden response is returned, indicating that the user is not authorized to access or update the requested data.

        This ensures that only authenticated users can access and update their own data, thereby fixing the insecure direct object reference vulnerability. The user ID is no longer directly exposed to the user, and sensitive data is encrypted in transit using JWT.

        Remember to keep the shared secret key for the `JwtAuthenticator` secure and regularly update and patch your systems to protect against known vulnerabilities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:shelf_auth/shelf_auth.dart';

        class UserController {
          final Router _router;

          UserController(this._router) {
            _router.add('GET', '/user/<id>', _getUser);
            _router.add('POST', '/user/<id>', _updateUser);
          }

          shelf.Response _getUser(shelf.Request request, String id) {
            // Fetch user with id from database
            var user = getUserFromDB(id);
            // Check if the user is authenticated and authorized to access this data
            if (request.context['authedUserId'] != id) {
              return shelf.Response.forbidden('You are not authorized to access this data');
            }
            return shelf.Response.ok(user.toJson());
          }

          shelf.Response _updateUser(shelf.Request request, String id) async {
            // Get body of request
            var body = jsonDecode(await request.readAsString());
            // Check if the user is authenticated and authorized to update this data
            if (request.context['authedUserId'] != id) {
              return shelf.Response.forbidden('You are not authorized to update this data');
            }
            // Update user with id in database
            updateUserInDB(id, body);
            return shelf.Response.ok('User updated');
          }
        }

        void main() {
          final router = Router();

          var authMiddleware = authenticate([new JwtAuthenticator('sharedSecret', verify: JwtVerify.onDemand)]);

          UserController(router);

          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(authMiddleware)
              .addHandler(router);

          io.serve(handler, 'localhost', 8080);
        }
    steps:
    - Implement an authentication mechanism to verify the identity of the user making
      the request. This could be in the form of a token-based system where the user
      is given a token upon login, and this token is used to authenticate subsequent
      requests.
    - Implement an authorization mechanism to ensure that the authenticated user has
      the necessary permissions to perform the requested action. In this case, the
      user should only be able to update their own information, not that of other
      users.
    - Validate the user ID in the request against the authenticated user's ID. If
      they do not match, reject the request.
    - Ensure that the user ID is not directly exposed to the user. Instead, use a
      session ID or similar mechanism that is mapped to the user ID on the server
      side.
    - Encrypt sensitive data in transit and at rest. This includes the user ID and
      any personal information.
    - Regularly update and patch your systems to protect against known vulnerabilities.
  title: Insecure object reference - Personal information
  vulnerability_id: '286'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_io for managing and organizing data storage in Node.js applications
  - Usage of shelf_router for routing and handling HTTP requests in a Shelf application
  need: Secure access to financial information
  solution:
    insecure_code_example:
      description: "The above Dart code is a simple server application that uses the\
        \ Shelf framework. It has a vulnerability related to insecure object reference.\
        \ \n\nThe application has a list of `Account` objects, each with an associated\
        \ list of `CreditCard` objects. The server has a single GET endpoint `/account/<accountId>/creditcard/<cardNumber>`\
        \ which takes an account ID and a credit card number as parameters. \n\nThe\
        \ vulnerability lies in the fact that the server does not check if the credit\
        \ card number belongs to the account ID specified in the request. This means\
        \ that a user can access the credit card information of another user by simply\
        \ changing the `accountId` and `cardNumber` parameters in the URL. \n\nFor\
        \ example, if a user with account ID '1' knows the credit card number '5678'\
        \ of a user with account ID '2', they can access the credit card information\
        \ of the latter by sending a GET request to `/account/1/creditcard/5678`.\
        \ This could lead to unauthorized access to sensitive information, which is\
        \ a serious security concern."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_router/shelf_router.dart';

        class CreditCard {
          final String number;
          final String accountID;
          CreditCard(this.number, this.accountID);
        }

        class Account {
          final String id;
          final List<CreditCard> creditCards;
          Account(this.id, this.creditCards);
        }

        final accounts = <Account>[
          Account('1', [CreditCard('1234', '1')]),
          Account('2', [CreditCard('5678', '2')]),
        ];

        void main() async {
          final app = Router();

          app.get('/account/<accountId>/creditcard/<cardNumber>', (shelf.Request request, String accountId, String cardNumber) {
            final account = accounts.firstWhere((a) => a.id == accountId);
            final card = account.creditCards.firstWhere((c) => c.number == cardNumber);
            return shelf.Response.ok('Card: ${card.number}, Account: ${card.accountID}');
          });

          final server = await io.serve(app, 'localhost', 8080);
          print('Serving at http://${server.address.host}:${server.port}');
        }
    language: dart
    secure_code_example:
      description: The updated code includes an authorization check in the '/account/\<accountId\>/creditcard/\<cardNumber\>'
        endpoint. This check verifies if the account making the request is the same
        as the account associated with the credit card. If the account making the
        request is not the same as the account associated with the credit card, the
        server returns a 403 Forbidden response with an error message indicating that
        the user does not have permission to access the data. This prevents users
        from accessing credit card information associated with other accounts, thereby
        fixing the insecure object reference vulnerability.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_router/shelf_router.dart';

        class CreditCard {
          final String number;
          final String accountID;
          CreditCard(this.number, this.accountID);
        }

        class Account {
          final String id;
          final List<CreditCard> creditCards;
          Account(this.id, this.creditCards);
        }

        final accounts = <Account>[
          Account('1', [CreditCard('1234', '1')]),
          Account('2', [CreditCard('5678', '2')]),
        ];

        void main() async {
          final app = Router();

          app.get('/account/<accountId>/creditcard/<cardNumber>', (shelf.Request request, String accountId, String cardNumber) {
            final account = accounts.firstWhere((a) => a.id == accountId);
            final card = account.creditCards.firstWhere((c) => c.number == cardNumber);

            // Check if the account making the request is the same as the account associated with the credit card
            if (card.accountID != accountId) {
              return shelf.Response.forbidden('You do not have permission to access this data');
            }

            return shelf.Response.ok('Card: ${card.number}, Account: ${card.accountID}');
          });

          final server = await io.serve(app, 'localhost', 8080);
          print('Serving at http://${server.address.host}:${server.port}');
        }
    steps:
    - Implement an authorization check to verify if the account making the request
      is the same as the account associated with the credit card.
    - This check should be done before any data is returned in the '/account/\<accountId\>/creditcard/\<cardNumber\>'
      endpoint.
    - If the account making the request is not the same as the account associated
      with the credit card, return an error message indicating that the user does
      not have permission to access the data.
    - Consider using a middleware for authorization checks to avoid repeating the
      same code in different endpoints.
  title: Insecure object reference - Financial information
  vulnerability_id: '288'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and performant applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  - Usage of shelf_io for managing and interacting with data storage in Node.js
  need: Disable OTP mock in the application configuration
  solution:
    insecure_code_example:
      description: |-
        The above code is a simple server application using the Shelf framework in Dart. It includes a middleware that logs requests and a handler that responds to requests.

        The vulnerability lies in the `_echoRequest` function. This function includes a boolean variable, `otpMock`, that is set to `true`. When `otpMock` is true, the function returns a response indicating that the mock OTP (One-Time Password) service is enabled. This mock service is likely less secure than the real OTP service, and could potentially be exploited by attackers.

        In a production environment, it is crucial to ensure that all testing or mock services are disabled to prevent any potential security issues. The mock OTP service should be disabled or removed entirely once testing is complete to ensure the security of the application.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
          print('Serving at http://localhost:8080');
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // Mock OTP service for testing
          var otpMock = true;

          if (otpMock) {
            return shelf.Response.ok('Mock OTP Enabled');
          } else {
            // Real OTP service code
            return shelf.Response.ok('Real OTP Service');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The code has been updated to address the insecure service configuration vulnerability. The OTP mock service is now controlled by an environment variable, `OTP_MOCK`. This allows for easy switching between the mock and real OTP service without having to modify the code.

        In addition, an access control check has been added to the mock OTP service. It checks for a valid authorization token in the request headers. If the token is not present or invalid, the service responds with a 403 Forbidden status, indicating that the client does not have permission to access the resource.

        This solution ensures that the OTP mock service is not accidentally enabled in a production environment and that only authorized users or services can use it. It is recommended to regularly review and update the service configuration to ensure it remains secure.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
          print('Serving at http://localhost:8080');
        }

        shelf.Response _echoRequest(shelf.Request request) {
          // Use environment variable to switch between mock and real OTP service
          var otpMock = Platform.environment['OTP_MOCK'] == 'true';

          if (otpMock) {
            // Ensure only authorized users/services can use the mock OTP service
            if (request.headers['Authorization'] == 'Bearer valid_token') {
              return shelf.Response.ok('Mock OTP Enabled');
            } else {
              return shelf.Response.forbidden('Unauthorized access');
            }
          } else {
            // Real OTP service code
            return shelf.Response.ok('Real OTP Service');
          }
        }
    steps:
    - Remove the OTP mock service from the production code.
    - Use environment variables or a configuration file to switch between the mock
      and the real OTP service.
    - Ensure that the configuration for the production environment does not include
      the OTP mock service.
    - Implement a proper access control for the OTP service, so only authorized users
      or services can use it.
    - Regularly review and update the service configuration to ensure it is secure.
  title: Insecure service configuration - OTP
  vulnerability_id: '294'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing input and output operations in a Node.js application
  need: Secure session management after a password change
  solution:
    insecure_code_example:
      description: |-
        The above code is a simple server that listens for requests and changes a user's password when a `changePassword` request is received. The new password is taken from the `new-password` header of the request.

        The vulnerability lies in the fact that after the password is changed, the existing session remains open. This is insecure because if an attacker has somehow gained access to the user's session (for example, through session hijacking), they can continue to use the session even after the user has changed their password.

        In a secure application, the session should be invalidated after a password change to ensure that any potential attacker is immediately logged out. This can be done by adding a `invalidateSession` function that is called immediately after the password is changed.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          if (request.url.path == 'changePassword') {
            var newPassword = request.headers['new-password'];
            // Assuming we have a function that can change the password
            changePassword(newPassword);
            return new shelf.Response.ok('Password changed successfully');
          }
          return new shelf.Response.notFound('Not Found');
        }

        void changePassword(String newPassword) {
          // Change the password in the database
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a session management system that invalidates the current session after a password change. This is done by calling the `invalidateSession(request)` function after the password has been changed.

        The `invalidateSession(request)` function should contain the logic to invalidate the current session in the session management system. This function is not implemented in this code snippet, as it would depend on the specific session management system used.

        After the session has been invalidated, the user is forced to log in again with the new password, creating a new session. This is communicated to the user by changing the response message to 'Password changed successfully. Please log in again.'.

        This change fixes the insecure session management vulnerability by ensuring that an old session cannot be used after a password change.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          if (request.url.path == 'changePassword') {
            var newPassword = request.headers['new-password'];
            // Assuming we have a function that can change the password
            changePassword(newPassword);
            // Invalidate the current session
            invalidateSession(request);
            return new shelf.Response.ok('Password changed successfully. Please log in again.');
          }
          return new shelf.Response.notFound('Not Found');
        }

        void changePassword(String newPassword) {
          // Change the password in the database
        }

        void invalidateSession(shelf.Request request) {
          // Invalidate the current session in the session management system
        }
    steps:
    - Create a session management system that can handle session invalidation.
    - After the password change, invalidate the current session.
    - Force the user to log in again with the new password, creating a new session.
  title: Insecure session management - Change Password
  vulnerability_id: '295'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of a robust and secure authentication mechanism
  solution:
    insecure_code_example:
      description: |-
        In the above code, we have a `handleRequest` function that handles incoming requests. It checks if the `username` query parameter is present in the request URL. If it is, it redirects the user to the '/dashboard' route, otherwise, it redirects the user to the '/login' route.

        The vulnerability here is that the server does not validate the authenticity of the user before redirecting them to the dashboard. An attacker can simply add a username query parameter to the request URL and be redirected to the dashboard without having to authenticate. This can lead to unauthorized access to the application, compromising user data and application integrity.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  var response;\n  var username = request.url.queryParameters['username'];\n\
        \  \n  if(username != null) {\n    response = shelf.Response.found('/dashboard');\n\
        \  } else {\n    response = shelf.Response.found('/login');\n  }\n\n  return\
        \ response;\n}"
    language: dart
    secure_code_example:
      description: |-
        The code above fixes the vulnerability by implementing an authentication mechanism using the `shelf_auth` package. This package provides middleware for authenticating requests in a Shelf application.

        The `authenticate` function is used to create an authentication middleware. This middleware uses a `BasicAuthenticator` which authenticates requests based on a username and password. The `myBasicAuthFunction` function is used to validate the username and password. This function should be replaced with your own function that validates the username and password.

        The `sessionHandler` parameter is set to an `InMemorySessionHandler`. This handler stores session data in memory.

        The `allowHttp` parameter is set to `false` to prevent the transmission of sensitive data over an unencrypted connection.

        Before redirecting to the dashboard, the code checks if the username and password are not null and if the authentication is successful. If the authentication is not successful, the user is redirected to the login page.

        This code does not rely solely on the username for authentication. It also requires a password. This makes it harder for an attacker to gain access to the application by guessing or knowing a valid username.

        Please note that this code is a basic example and may need to be adjusted to fit your specific needs. For example, you may want to encrypt the username and password during transmission and at rest, use secure and updated libraries for handling user authentication, implement rate limiting to prevent brute force attacks, and log and monitor authentication attempts to detect any suspicious activities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_auth/shelf_auth.dart';

        shelf.Response handleRequest(shelf.Request request) {
          var response;
          var username = request.url.queryParameters['username'];
          var password = request.url.queryParameters['password'];

          // Implement an authentication mechanism
          var authMiddleware = authenticate(
            [new BasicAuthenticator(myBasicAuthFunction)],
            sessionHandler: new InMemorySessionHandler(),
            allowHttp: false,
          );

          // Check the authentication status of the user before redirecting
          if(username != null && password != null && authMiddleware.authenticate(username, password)) {
            response = shelf.Response.found('/dashboard');
          } else {
            response = shelf.Response.found('/login');
          }

          return response;
        }

        // This function should be replaced with your own function that validates the username and password
        bool myBasicAuthFunction(String username, String password) {
          // Validate the username and password
          // This is just a placeholder function
          return true;
        }
    steps:
    - Implement an authentication mechanism to verify the identity of the user. This
      could be a password, a token, or a two-factor authentication system.
    - Check the authentication status of the user before redirecting to the dashboard.
      If the user is not authenticated, redirect them to the login page.
    - Do not rely solely on the username for authentication. An attacker could easily
      guess or know a valid username.
    - Encrypt sensitive data like usernames and passwords during transmission and
      at rest.
    - Use secure and updated libraries for handling user authentication.
    - Implement rate limiting to prevent brute force attacks.
    - Log and monitor authentication attempts to detect any suspicious activities.
  title: Authentication mechanism absence or evasion - Redirect
  vulnerability_id: '298'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and efficient web applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure session management
  solution:
    insecure_code_example:
      description: |-
        The above code is a simple Dart server using the Shelf framework. It uses a basic session management mechanism where sessions are stored in a map and retrieved using a session ID from the request headers.

        The vulnerability lies in the session validation within the `handleRequest` function. The function checks if the session exists and if it hasn't expired yet. If both conditions are met, it handles the request as an authenticated request.

        However, the `expirationTime` of a session is stored in the session object itself, which is stored in a map on the server. This means that if an attacker can somehow gain access to the server's memory or the session map, they can modify the `expirationTime` of an expired session to a future time, thus making the session valid again.

        This is an insecure session management vulnerability because it allows an attacker to prolong a session indefinitely by simply modifying the session's expiration time.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nclass Session {\n  String\
        \ id;\n  DateTime expirationTime;\n\n  Session(this.id, this.expirationTime);\n\
        }\n\nfinal sessionMap = <String, Session>{};\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  final sessionId = request.headers['sessionId'];\n  final session\
        \ = sessionMap[sessionId];\n  \n  if (session != null && DateTime.now().isBefore(session.expirationTime))\
        \ {\n    // Handle authenticated request\n    return shelf.Response.ok('Authenticated\
        \ request');\n  } else {\n    // Handle unauthenticated request\n    return\
        \ shelf.Response.forbidden('Unauthenticated request');\n  }\n}\n\nvoid main()\
        \ {\n  var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);\n\
        \  shelf.serve(handler, 'localhost', 8080);\n}"
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a mechanism to invalidate the session token once it has expired. This is done by removing the expired session from the `sessionMap` in the `handleRequest` function. This ensures that once a session has expired, it cannot be reactivated by modifying the expiration time.

        The `Session` class has also been updated to make the `id` and `expirationTime` fields final. This means that once a `Session` object has been created, its `id` and `expirationTime` cannot be changed. This helps to ensure that the session expiration time is managed server-side and cannot be modified by the client.

        These changes help to mitigate the risk of session token manipulation by ensuring that expired session tokens cannot be reactivated and that the session expiration time cannot be modified after the session has been created.

        For further security, consider using a secure session management library that handles these issues automatically, regularly rotating session tokens to limit the potential damage if a token is compromised, and implementing additional security measures such as re-authentication for sensitive operations.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nclass Session {\n  final\
        \ String id;\n  final DateTime expirationTime;\n\n  Session(this.id, this.expirationTime);\n\
        }\n\nfinal sessionMap = <String, Session>{};\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  final sessionId = request.headers['sessionId'];\n  final session\
        \ = sessionMap[sessionId];\n  \n  if (session != null && DateTime.now().isBefore(session.expirationTime))\
        \ {\n    // Handle authenticated request\n    return shelf.Response.ok('Authenticated\
        \ request');\n  } else {\n    // Handle unauthenticated request\n    // Remove\
        \ the expired session from the sessionMap\n    sessionMap.remove(sessionId);\n\
        \    return shelf.Response.forbidden('Unauthenticated request');\n  }\n}\n\
        \nvoid main() {\n  var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);\n\
        \  shelf.serve(handler, 'localhost', 8080);\n}"
    steps:
    - Ensure that the session expiration time is managed server-side and cannot be
      modified by the client.
    - Implement a mechanism to invalidate the session token once it has expired, and
      do not allow it to be reactivated.
    - Consider using a secure session management library that handles these issues
      automatically.
    - Regularly rotate session tokens to limit the potential damage if a token is
      compromised.
    - Consider implementing additional security measures, such as re-authentication
      for sensitive operations.
  title: Insecure functionality - Session management
  vulnerability_id: '302'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in Node.js
  need: Enforcement of proper security controls for data creation
  solution:
    insecure_code_example:
      description: "The above code is a simplified representation of the vulnerability.\
        \ Here, we are using the `shelf` framework to handle HTTP requests in a Dart\
        \ backend application.\n\nIn the `Policy` class, we have a list of `beneficiaries`.\
        \ The `addBeneficiary` method is used to add a beneficiary to this list. \n\
        \nIn the `handleRequest` function, we are creating a new `Policy` object and\
        \ adding beneficiaries from the request parameters to it. The vulnerability\
        \ lies in the fact that there is no restriction on the number of beneficiaries\
        \ that can be added to a policy. This allows a user to bypass the intended\
        \ limit of four beneficiaries and add as many as they want.\n\nThis vulnerability\
        \ affects the integrity of the data sent because it allows the creation of\
        \ policies with an arbitrary number of beneficiaries. This could lead to unexpected\
        \ behavior in other parts of the application that assume a maximum of four\
        \ beneficiaries per policy."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class Policy {
          List<String> beneficiaries = [];

          void addBeneficiary(String beneficiary) {
            beneficiaries.add(beneficiary);
          }
        }

        shelf.Response handleRequest(shelf.Request request) {
          var policy = Policy();

          var beneficiaries = request.url.queryParametersAll['beneficiaries'];
          for (var beneficiary in beneficiaries) {
            policy.addBeneficiary(beneficiary);
          }

          // ... rest of the code
        }
    language: dart
    secure_code_example:
      description: |-
        The code above fixes the vulnerability by adding a check in the `addBeneficiary` method of the `Policy` class. This check ensures that the number of beneficiaries does not exceed four. If the number of beneficiaries is already four, the method does not add any more beneficiaries and instead returns an error message.

        This check is done before a new beneficiary is added to the list. If the `addBeneficiary` method returns an error message, the `handleRequest` method handles this by returning a `shelf.Response` with a status code of 400 (Bad Request) and the error message as the body. This informs the client that their request to add another beneficiary was unsuccessful because the maximum number of beneficiaries has already been reached.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class Policy {
          List<String> beneficiaries = [];

          String addBeneficiary(String beneficiary) {
            if (beneficiaries.length >= 4) {
              return 'Error: Maximum number of beneficiaries is 4';
            }
            beneficiaries.add(beneficiary);
            return 'Beneficiary added successfully';
          }
        }

        shelf.Response handleRequest(shelf.Request request) {
          var policy = Policy();

          var beneficiaries = request.url.queryParametersAll['beneficiaries'];
          for (var beneficiary in beneficiaries) {
            String result = policy.addBeneficiary(beneficiary);
            if (result.startsWith('Error')) {
              return shelf.Response(400, body: result);
            }
          }

          // ... rest of the code
        }
    steps:
    - Add a check in the 'addBeneficiary' method to ensure that the number of beneficiaries
      does not exceed four.
    - If the number of beneficiaries is already four, the method should not add any
      more beneficiaries and should return an error message.
    - This check should be done before adding a new beneficiary to the list.
    - In the 'handleRequest' method, handle the error message returned by the 'addBeneficiary'
      method and send an appropriate response to the client.
  title: Security controls bypass or absence - Data creation
  vulnerability_id: '305'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and interacting with data storage in Node.js
  need: Secure and controlled access to user files
  solution:
    insecure_code_example:
      description: "In the above code, we are creating a simple server using the Shelf\
        \ framework in Dart. The `_echoRequest` function is handling all incoming\
        \ requests. It is extracting the 'id' from the request's URL query parameters\
        \ and directly fetching the file related to this 'id' from the database. \n\
        \nThe vulnerability here is the insecure direct object reference (IDOR). The\
        \ application is using the direct object id from the user's request to fetch\
        \ the file. An attacker can change the 'id' in the URL to any other valid\
        \ 'id' and get unauthorized access to other user's files. \n\nThe application\
        \ is not checking if the user making the request has the necessary permissions\
        \ to access the file related to the 'id' from the URL. This could lead to\
        \ information disclosure as an attacker can potentially access any file just\
        \ by knowing its 'id'. \n\nTo fix this vulnerability, we need to implement\
        \ an access control check before fetching the file from the database. The\
        \ access control check should verify if the user making the request has the\
        \ necessary permissions to access the file related to the 'id' from the URL."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var id = request.url.queryParameters['id'];
          // Fetching file based on the id without any validation
          var file = fetchFile(id);
          return shelf.Response.ok('File: $file');
        }

        fetchFile(id){
          // Fetches the file based on the id from the database
          // This function is just for representation and does not contain actual implementation
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes an authentication middleware that checks if the request contains a valid session id in the headers. If the session id is not present or is invalid, the middleware returns a 403 Forbidden response. If the session id is valid, it is added to the request context and passed to the next handler.

        In the `_echoRequest` handler, the session id is retrieved from the request context and used along with the file id to fetch the file. This ensures that the file is only fetched if the user associated with the session id has the necessary permissions to access it.

        The `isValidSession` function is a placeholder for the actual session validation logic. This function should check if the session id is valid, i.e., if it corresponds to a logged-in user and has not expired.

        The `fetchFile` function is also a placeholder for the actual file fetching logic. This function should fetch the file with the given id from the database, but only if the user associated with the session id has the necessary permissions to access it.

        This approach ensures that only authenticated and authorized users can access files, thereby fixing the insecure object reference vulnerability.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addMiddleware(_authenticationMiddleware)
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Middleware _authenticationMiddleware() {
          return (shelf.Handler innerHandler) {
            return (shelf.Request request) async {
              var sessionId = request.headers['session-id'];
              if (sessionId == null || !isValidSession(sessionId)) {
                return shelf.Response.forbidden('Invalid session');
              }
              return innerHandler(request.change(context: {'session-id': sessionId}));
            };
          };
        }

        bool isValidSession(String sessionId) {
          // Validate the session id
          // This function is just for representation and does not contain actual implementation
          return true;
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var sessionId = request.context['session-id'];
          var id = request.url.queryParameters['id'];
          // Fetching file based on the id and session id
          var file = fetchFile(id, sessionId);
          return shelf.Response.ok('File: $file');
        }

        fetchFile(id, sessionId){
          // Fetches the file based on the id and session id from the database
          // This function is just for representation and does not contain actual implementation
        }
    steps:
    - Implement an authentication mechanism to ensure that the user is logged in before
      they can access any files.
    - After authentication, implement an authorization check to ensure that the logged-in
      user has the necessary permissions to access the requested file.
    - Instead of directly using the 'id' from the request to fetch the file, use the
      user's session information to determine which files they should have access
      to.
    - Consider using a server-side session management system to store and manage user
      session information securely.
    - Ensure that the session management system is secure against session hijacking
      and session fixation attacks.
    - Consider using an indirect object reference map, where the application uses
      a map that points from a list of random or hashed values to the actual file
      references. This way, even if an attacker guesses a file's identifier, they
      cannot access it without the correct mapping value.
  title: Insecure object reference - Files
  vulnerability_id: '306'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing data storage and retrieval
  need: Secure access control and validation of user permissions
  solution:
    insecure_code_example:
      description: "The above code is an example of a Dart application using the Shelf\
        \ framework, which is vulnerable to Insecure Direct Object References (IDOR).\
        \ \n\nThe `handleRequest` function is supposed to handle incoming requests\
        \ and return information about a member of a store. It does this by taking\
        \ the first path segment of the URL as the store ID and the second path segment\
        \ as the member ID. Then, it looks up the store in the `stores` map and finds\
        \ the member in the `members` list of the store.\n\nThe vulnerability lies\
        \ in the fact that no authorization checks are performed. Any user that knows\
        \ the store ID and member ID can access the member's information, even if\
        \ they don't have the necessary permissions. \n\nThis could potentially allow\
        \ an attacker to access sensitive information, modify members or add new members\
        \ to stores that they should not have access to. \n\nIn a real-world application,\
        \ the `stores` map and `Member` class would likely be replaced with a database\
        \ or other persistent storage, and the `handleRequest` function would be part\
        \ of a larger routing system. However, the core vulnerability would remain\
        \ the same."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class Store {
          final String id;
          final List<Member> members;

          Store(this.id, this.members);
        }

        class Member {
          final String id;
          final String name;

          Member(this.id, this.name);
        }

        Map<String, Store> stores = {
          'store1': Store('store1', [Member('1', 'John Doe'), Member('2', 'Jane Doe')]),
          'store2': Store('store2', [Member('3', 'Jimmy Doe'), Member('4', 'Jenny Doe')]),
        };

        shelf.Response handleRequest(shelf.Request request) {
          var storeId = request.url.pathSegments.first;
          var memberId = request.url.pathSegments[1];

          var store = stores[storeId];
          var member = store.members.firstWhere((m) => m.id == memberId);

          return shelf.Response.ok('Member: ${member.name}');
        }
    language: dart
    secure_code_example:
      description: "The updated code introduces an authentication and authorization\
        \ mechanism to prevent insecure object reference. \n\nFirstly, a new `User`\
        \ class is introduced. Each user has an `id` and a list of `storePermissions`\
        \ which are the IDs of the stores that the user has access to.\n\nThe `handleRequest`\
        \ function now first checks the `user-id` from the request headers. If the\
        \ `user-id` is not found in the `users` map, a 403 Forbidden response is returned.\n\
        \nNext, the function checks if the user has permission to access the requested\
        \ store by checking if the `storeId` is in the user's `storePermissions`.\
        \ If the user does not have permission, a 403 Forbidden response is returned.\n\
        \nFinally, the function checks if the requested member exists in the store.\
        \ If the member does not exist, a 404 Not Found response is returned.\n\n\
        This way, the application ensures that only authenticated users with the necessary\
        \ permissions can access the store and member data, thus fixing the insecure\
        \ object reference vulnerability."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class Store {
          final String id;
          final List<Member> members;

          Store(this.id, this.members);
        }

        class Member {
          final String id;
          final String name;

          Member(this.id, this.name);
        }

        class User {
          final String id;
          final List<String> storePermissions;

          User(this.id, this.storePermissions);
        }

        Map<String, Store> stores = {
          'store1': Store('store1', [Member('1', 'John Doe'), Member('2', 'Jane Doe')]),
          'store2': Store('store2', [Member('3', 'Jimmy Doe'), Member('4', 'Jenny Doe')]),
        };

        Map<String, User> users = {
          'user1': User('user1', ['store1']),
          'user2': User('user2', ['store2']),
        };

        shelf.Response handleRequest(shelf.Request request) {
          var userId = request.headers['user-id'];
          var user = users[userId];

          if (user == null) {
            return shelf.Response.forbidden('Invalid user');
          }

          var storeId = request.url.pathSegments.first;
          if (!user.storePermissions.contains(storeId)) {
            return shelf.Response.forbidden('Access denied to this store');
          }

          var store = stores[storeId];
          var memberId = request.url.pathSegments[1];
          var member = store.members.firstWhere((m) => m.id == memberId, orElse: () => null);

          if (member == null) {
            return shelf.Response.notFound('Member not found');
          }

          return shelf.Response.ok('Member: ${member.name}');
        }
    steps:
    - Introduce an authentication mechanism to verify the identity of the user making
      the request.
    - Implement an authorization mechanism to check if the authenticated user has
      the necessary permissions to access the requested store and member.
    - Ensure that the authorization mechanism checks both the store ID and the member
      ID against the authenticated user's permissions.
    - If the user does not have the necessary permissions, the request should be denied
      and an appropriate error message should be returned.
    - Consider using role-based access control (RBAC) or attribute-based access control
      (ABAC) for implementing the authorization mechanism.
    - Ensure that the authorization checks are performed at every point where sensitive
      data is accessed, not just at the initial point of entry.
  title: Insecure object reference - Data
  vulnerability_id: '307'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for handling input/output operations in a Shelf application
  need: Secure default configuration
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is a simple server application using the Shelf framework. The server listens on `localhost` at port `8080` and responds with `Hello, World!` to all incoming requests.

        The vulnerability here is the enabled default configuration. The server has a default page (`Hello, World!`) that is enabled and accessible to anyone who sends a request to the server. This default page can reveal technical information about the server to an attacker.

        An attacker can send a request to the server and, by analyzing the response, can gain insights into the server's configuration, the technologies used (in this case, Dart and Shelf), and potentially other sensitive information. This information can be used for further attacks on the server.

        The vulnerability can be fixed by disabling the default page and implementing proper request handling that does not reveal unnecessary information about the server.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Hello, World!\\n');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable because it was serving a default page that could potentially reveal technical information about the server. This could be exploited by an attacker to gain insights about the server and find potential vulnerabilities.

        The updated code now serves a custom page instead of the default one. This custom page does not reveal any technical information about the server, thus mitigating the risk of an attacker gaining insights about the server.

        In addition to this, it's important to regularly update and patch the server to prevent any known vulnerabilities. Access controls should also be implemented to restrict who can access the server information. This is not shown in the code, but it's a crucial part of securing the server.

        Remember, security is not a one-time task but a continuous process. Always keep your server and its dependencies up-to-date, and regularly audit your server for any potential vulnerabilities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_customPage);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _customPage(shelf.Request request) {
          return shelf.Response.ok('This is a custom page. No technical details here.\\n');
        }
    steps:
    - Disable the default page or replace it with a custom page.
    - Configure the server to not reveal any technical information about itself.
    - Ensure that the server only serves the necessary resources and nothing more.
    - Regularly update and patch the server to prevent any known vulnerabilities.
    - Implement access controls to restrict who can access the server information.
  title: Enabled default configuration
  vulnerability_id: '308'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance, cross-platform applications
  - Usage of jaguar_jwt for JSON Web Token (JWT) authentication and authorization
  need: Secure token generation for user creation service
  solution:
    insecure_code_example:
      description: "This Dart code is a simple example of a JWT token generation using\
        \ the `jaguar_jwt` package. The `main` function creates a `JwtClaim` object\
        \ with some claims such as issuer, subject, and expiry. Then, it generates\
        \ a token by calling the `issueJwtHS256` function with the claim set and a\
        \ secret key.\n\nThe `issueJwtHS256` function creates another `JwtClaim` object\
        \ with the same claims as the input claim set. It then returns the compact\
        \ form of the JWT, which is a string that includes the header, payload, and\
        \ signature.\n\nThe vulnerability lies in the use of a weak secret key, 'weak_key',\
        \ for signing the token. This key is easy to guess or crack, which means an\
        \ attacker could potentially forge a token with any claims they want, including\
        \ changing the expiry date to create a token that never expires. This would\
        \ allow them to consume the user creation service indefinitely, and potentially\
        \ perform other unauthorized actions in the application. \n\nTo mitigate this\
        \ vulnerability, it is recommended to use a stronger, more complex secret\
        \ key that is not easily guessable or crackable. This could be achieved, for\
        \ example, by generating a random key of sufficient length and complexity,\
        \ and storing it securely. Additionally, it may be beneficial to implement\
        \ other security measures, such as token invalidation after a certain period\
        \ of time or after certain events (e.g., user logout), to further reduce the\
        \ risk of token misuse."
      text: |-
        import 'package:jaguar_jwt/jaguar_jwt.dart';

        void main() {
          final claimSet = JwtClaim(
            issuer: 'DartAPI',
            subject: 'userID',
            expiry: DateTime.now().add(const Duration(minutes: 5)),
          );

          String token = issueJwtHS256(claimSet, 'weak_key');
          print('Token: $token');
        }

        String issueJwtHS256(JwtClaim claimSet, String secret) {
          final jwt = JwtClaim(
            issuer: claimSet.issuer,
            subject: claimSet.subject,
            expiry: claimSet.expiry,
          );

          return 'Bearer ${jwt.compact(secret)}';
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes a function `generateSecretKey()`\
        \ that generates a strong, random secret key using Dart's `Random.secure()`\
        \ function. This key is then used to sign the JWT token. \n\nThe `generateSecretKey()`\
        \ function generates a list of 32 random integers (each between 0 and 255),\
        \ and then encodes this list as a base64 URL string. This results in a 44-character\
        \ long string that is suitable for use as a secret key for JWT.\n\nPlease\
        \ note that this is a basic implementation and in a real-world scenario, the\
        \ secret key should not be generated each time a token is issued. Instead,\
        \ it should be generated once and stored securely, for example in an encrypted\
        \ configuration file or a secure key management system. \n\nAlso, consider\
        \ implementing a key rotation policy, where the secret key is changed regularly.\
        \ This can limit the damage if an old key is compromised.\n\nFinally, remember\
        \ to validate the token's expiration date on the server side. Even if an attacker\
        \ modifies the token's expiration date, the server should reject tokens that\
        \ have expired according to its own clock."
      text: |-
        import 'dart:convert';
        import 'dart:math';
        import 'package:jaguar_jwt/jaguar_jwt.dart';
        import 'package:crypto/crypto.dart';

        void main() {
          final claimSet = JwtClaim(
            issuer: 'DartAPI',
            subject: 'userID',
            expiry: DateTime.now().add(const Duration(minutes: 5)),
          );

          String secret = generateSecretKey();
          String token = issueJwtHS256(claimSet, secret);
          print('Token: $token');
        }

        String generateSecretKey() {
          var random = Random.secure();
          var values = List<int>.generate(32, (i) => random.nextInt(256));
          return base64Url.encode(values);
        }

        String issueJwtHS256(JwtClaim claimSet, String secret) {
          final jwt = JwtClaim(
            issuer: claimSet.issuer,
            subject: claimSet.subject,
            expiry: claimSet.expiry,
          );

          return 'Bearer ${jwt.compact(secret)}';
        }
    steps:
    - Replace the weak key with a strong, randomly generated key. The key should be
      long and complex enough to resist brute-force attacks.
    - Store the key securely. It should not be hard-coded into the application, but
      instead stored in a secure and encrypted configuration file or a secure key
      management system.
    - Implement a key rotation policy. Regularly changing the key can limit the damage
      if an old key is compromised.
    - Consider using asymmetric encryption for the JWT. This way, even if an attacker
      gets the public key, they cannot generate valid tokens without the private key.
    - Validate the token's expiration date on the server side. Even if an attacker
      modifies the token's expiration date, the server should reject tokens that have
      expired according to its own clock.
  title: Insecurely generated token - JWT
  vulnerability_id: '309'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of dart:io for input/output operations in Dart programming
  - Usage of the shelf_io package for handling HTTP requests and responses in Dart's
    Shelf framework
  - Usage of the shelf package in Dart for building web applications and HTTP middleware.
  need: Secure service configuration - Proper certificate validation and verification
  solution:
    insecure_code_example:
      description: "The above code is a simple Dart server using the Shelf framework.\
        \ It is set up to use HTTPS and has a certificate and private key. However,\
        \ the server has been configured insecurely, as it does not request or validate\
        \ client certificates.\n\nThe line `requestClientCertificate: false,` indicates\
        \ that the server does not request a client certificate. This means that any\
        \ client can connect to the server, even if they do not have a valid certificate.\
        \ \n\nThis misconfiguration can lead to Man-in-the-Middle (MitM) attacks.\
        \ In a MitM attack, the attacker intercepts and possibly alters the communication\
        \ between two parties who believe they are directly communicating with each\
        \ other. \n\nIn this case, an attacker could present an invalid certificate\
        \ to the server, and because the server does not validate client certificates,\
        \ the attacker could potentially intercept and alter the communication between\
        \ the client and the server."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          // Create an HTTPS server with an insecure certificate.
          var server = HttpServer.bindSecure(
            InternetAddress.loopbackIPv4,
            8443,
            SecurityContext()
              ..useCertificateChain('path_to_certificate.pem')
              ..usePrivateKey('path_to_key.pem'),
            requestClientCertificate: false,
          );

          io.serveRequests(server, handler);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a secure configuration for the X.509 certificates. The `SecurityContext` now includes a method `setTrustedCertificates` which is used to set the trusted certificates that the server will use to validate the client's certificate. This ensures that the server only accepts certificates signed by a trusted Certificate Authority (CA).

        The `requestClientCertificate` parameter in the `bindSecure` method is now set to `true`. This forces the server to request a certificate from the client, adding an extra layer of security.

        Please note that this code assumes that you have a valid certificate chain file, private key file, and trusted certificates file. Make sure to replace `'path_to_certificate.pem'`, `'path_to_key.pem'`, and `'path_to_trusted_certificates.pem'` with the actual paths to your files.

        Remember to regularly update and renew your certificates and keys to prevent them from being outdated or compromised. Also, consider using a certificate revocation list (CRL) or an Online Certificate Status Protocol (OCSP) to check the revocation status of a certificate.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          // Create an HTTPS server with a secure certificate.
          var server = HttpServer.bindSecure(
            InternetAddress.loopbackIPv4,
            8443,
            SecurityContext()
              ..useCertificateChain('path_to_certificate.pem')
              ..usePrivateKey('path_to_key.pem')
              ..setTrustedCertificates('path_to_trusted_certificates.pem'), // Add trusted certificates
            requestClientCertificate: true, // Request client certificate
          );

          io.serveRequests(server, handler);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Validate the certificate chain by checking if it's signed by a trusted Certificate
      Authority (CA).
    - Enable the 'requestClientCertificate' parameter in the 'bindSecure' method to
      true. This will force the server to request a certificate from the client, adding
      an extra layer of security.
    - Implement certificate pinning to ensure that the server only accepts specific
      certificates.
    - Regularly update and renew your certificates and keys to prevent them from being
      outdated or compromised.
    - Consider using a certificate revocation list (CRL) or an Online Certificate
      Status Protocol (OCSP) to check the revocation status of a certificate.
  title: Insecure service configuration - Certificates
  vulnerability_id: '313'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data models and database operations
  need: Proper resource management and deallocation
  solution:
    insecure_code_example:
      description: "In the above code snippet, we have a function `inboundOutboundFlowHandler`\
        \ which is a request handler for a certain route in a backend application\
        \ using the `shelf` framework in Dart. \n\nThe handler opens a connection,\
        \ gets the inbound and outbound flows, processes them, and then sends a response\
        \ back to the client. \n\nThe vulnerability lies in the fact that the opened\
        \ connection and the obtained inbound and outbound flows are not closed after\
        \ they have been processed. This can lead to a memory leak as the resources\
        \ allocated for these flows are not released back to the system. \n\nIn a\
        \ high traffic scenario, this can quickly exhaust the available system resources\
        \ leading to degraded performance or even system crashes. This is a typical\
        \ example of improper resource allocation or management, a common vulnerability\
        \ in software applications."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        Future<shelf.Response> inboundOutboundFlowHandler(shelf.Request request) async {
          var connection = await Connection.open();

          var inboundFlow = await connection.getInboundFlow();
          var outboundFlow = await connection.getOutboundFlow();

          // processing inbound and outbound flows...

          // Missing closing connections

          return shelf.Response.ok('Processed successfully');
        }
    language: dart
    secure_code_example:
      description: "The updated code now includes a `try/finally` block. This ensures\
        \ that the resources are always released, regardless of whether an exception\
        \ was thrown or not. \n\nIn the `try` block, we open the connection and get\
        \ the inbound and outbound flows. These operations might throw exceptions,\
        \ but since they are inside a `try` block, any exception will cause the control\
        \ to immediately move to the `finally` block.\n\nIn the `finally` block, we\
        \ close the `inboundFlow`, `outboundFlow`, and `connection` in the reverse\
        \ order of their acquisition. This is a good practice to follow when releasing\
        \ resources. \n\nBefore closing each resource, we check if it is `null`. This\
        \ is because if an exception was thrown before a resource was initialized,\
        \ it will be `null`, and calling `close` on a `null` object will throw a `NullPointerException`.\n\
        \nThis updated code ensures that all resources are properly released, thus\
        \ fixing the memory leak vulnerability."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        Future<shelf.Response> inboundOutboundFlowHandler(shelf.Request request) async {
          Connection connection;
          InboundFlow inboundFlow;
          OutboundFlow outboundFlow;

          try {
            connection = await Connection.open();

            inboundFlow = await connection.getInboundFlow();
            outboundFlow = await connection.getOutboundFlow();

            // processing inbound and outbound flows...

          } finally {
            // Close the resources in the reverse order of their acquisition
            if (inboundFlow != null) {
              await inboundFlow.close();
            }

            if (outboundFlow != null) {
              await outboundFlow.close();
            }

            if (connection != null) {
              await connection.close();
            }
          }

          return shelf.Response.ok('Processed successfully');
        }
    steps:
    - Identify the resources that need to be released. In this case, it's the 'connection',
      'inboundFlow', and 'outboundFlow'.
    - Ensure that these resources are closed after their use. This can be done by
      calling the 'close' method on these objects.
    - Implement a 'finally' block in your code. This block will always be executed,
      regardless of whether an exception was thrown or not. This is the ideal place
      to release resources.
    - In the 'finally' block, close the 'inboundFlow', 'outboundFlow', and 'connection'.
    - Ensure that the 'close' methods are called in the correct order. Resources should
      be released in the reverse order of their acquisition. In this case, first close
      'inboundFlow', then 'outboundFlow', and finally 'connection'.
    - Test your code to ensure that resources are being released properly. Monitor
      your system's resource usage before and after the fix to confirm that the memory
      leak has been resolved.
  title: Improper resource allocation - Memory leak
  vulnerability_id: '317'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing input/output operations with Shelf
  - Usage of dart:convert for encoding and decoding JSON data in Dart
  - Usage of dart:io for performing input/output operations in Dart
  - Usage of jaguar_jwt for JSON Web Token (JWT) authentication and authorization
  need: Secure token generation and validation
  solution:
    insecure_code_example:
      description: |-
        The above code is a simple server application using the Shelf framework in Dart. It listens for requests on localhost at port 8080.

        In the `_echoRequest` function, it tries to retrieve the 'authorization' header from the request which is supposed to contain a JWT token. If the token is not present, it responds with a 401 status code.

        The vulnerability lies in the way it handles the token. It directly decodes the token using `B64urlEncRfc7515.decodeUtf8(token)`. This means that it does not validate the signature of the token. Hence, an attacker can modify the token, change the algorithm in the header to 'none', and the server would still accept it as a valid token.

        Moreover, it retrieves the 'user_id' from the decoded token and if it is present, it sends an OK response with a message 'Hello, user_id!'. This means an attacker can impersonate any user by simply creating a token with the user's id.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart'\
        \ as io;\nimport 'dart:convert';\nimport 'dart:io';\nimport 'package:jaguar_jwt/jaguar_jwt.dart';\n\
        \nvoid main() {\n  var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);\n\
        \n  io.serve(handler, 'localhost', 8080);\n}\n\nshelf.Response _echoRequest(shelf.Request\
        \ request) {\n  var token = request.headers['authorization'];\n  \n  if (token\
        \ == null) {\n    return new shelf.Response(401);\n  }\n  \n  var decodedToken\
        \ = B64urlEncRfc7515.decodeUtf8(token);\n\n  var jsonToken = jsonDecode(decodedToken);\n\
        \n  var userId = jsonToken['user_id'];\n\n  if (userId == null) {\n    return\
        \ new shelf.Response(401);\n  }\n  \n  return new shelf.Response.ok('Hello,\
        \ $userId!');\n}"
    language: dart
    secure_code_example:
      description: |-
        The updated code introduces a secret key to sign the JWT token. This key is stored securely and not exposed. The `verifyJwtHS256Signature` function from the `jaguar_jwt` library is used to validate the JWT token. This function verifies the signature of the token using the secret key.

        The algorithm used to sign the token is HS256, which is a secure algorithm. The 'none' algorithm is not used, preventing the vulnerability where the token could be unsigned.

        The claims of the JWT token are checked by the `verifyJwtHS256Signature` function. In this case, it makes sure that the 'user_id' claim is present and valid. The 'user_id' claim is accessed through the `uniqueId` property of the decoded claim set.

        If the token is invalid or tampered with, an exception is thrown and caught in the `catch` block. In this case, a 401 Unauthorized response is returned, appropriately handling the error case.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart'\
        \ as io;\nimport 'dart:convert';\nimport 'dart:io';\nimport 'package:jaguar_jwt/jaguar_jwt.dart';\n\
        \nconst String secretKey = 'your-secure-secret-key'; // Store this securely\n\
        \nvoid main() {\n  var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);\n\
        \n  io.serve(handler, 'localhost', 8080);\n}\n\nshelf.Response _echoRequest(shelf.Request\
        \ request) {\n  var token = request.headers['authorization'];\n  \n  if (token\
        \ == null) {\n    return new shelf.Response(401);\n  }\n  \n  try {\n    var\
        \ decClaimSet = verifyJwtHS256Signature(token, secretKey);\n    var userId\
        \ = decClaimSet.uniqueId;\n\n    if (userId == null) {\n      return new shelf.Response(401);\n\
        \    }\n    \n    return new shelf.Response.ok('Hello, $userId!');\n  } catch(e)\
        \ {\n    return new shelf.Response(401);\n  }\n}"
    steps:
    - Introduce a secret key to sign the JWT token. This key should be stored securely
      and not exposed.
    - Use a library or function to validate the JWT token. This function should verify
      the signature of the token using the secret key.
    - Ensure that the algorithm used to sign the token is secure and not 'none'.
    - Check the claims of the JWT token. In this case, make sure that the 'user_id'
      claim is present and valid.
    - Handle the case where the token is invalid or tampered with by returning an
      appropriate error response.
  title: Insecurely generated token - Validation
  vulnerability_id: '318'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Proper configuration and management of roles to ensure accurate representation
    of security responsibilities
  solution:
    insecure_code_example:
      description: |-
        In the above code, we have a `User` class that takes a `role` as a parameter. This role is then used in the `handleRequest` function to determine the level of access the user has.

        The vulnerability here is in the insecure service configuration of roles. The roles are not correctly representing the different aspects of responsibilities for the security levels of the organization. In this case, there are only two roles: 'admin' and 'user'. This is a simplistic representation and does not cover the various roles that might exist in a real-world organization.

        Moreover, the role is directly assigned to the user without any checks or validation. This means that anyone can claim to be an 'admin' and gain admin privileges. This is a major security vulnerability as it can lead to unauthorized access and potential data breaches.

        Ideally, the roles should be more granular and accurately represent the different levels of access required by different users. Furthermore, there should be checks and validation in place to ensure that a user can only claim the role that they are authorized for.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nclass User {\n  String\
        \ role;\n  User(this.role);\n}\n\nvoid handleRequest(shelf.Request request)\
        \ {\n  var user = User('admin');\n  \n  if (user.role == 'admin') {\n    print('Admin\
        \ privileges granted.');\n  } else {\n    print('User privileges granted.');\n\
        \  }\n}"
    language: dart
    secure_code_example:
      description: |-
        The code above defines a `User` class with a `role` property. The `role` property is of type `UserRole`, which is an enumeration of the different user roles in the system. This is a more secure way of handling user roles as it avoids the use of hardcoded strings.

        The `handleRequest` function now takes an additional `User` parameter. This function checks the role of the user and grants privileges accordingly. This ensures that role checks are performed at every point where privileged operations are performed.

        This code is just a basic example and in a real-world application, the user roles and their permissions would likely be stored in a secure database or configuration file. The roles would be assigned to users dynamically, either during user registration or by an admin.

        The use of a middleware for role checks could also be considered to centralize the role checking logic and reduce the chances of missing a check.

        Finally, it's important to ensure that the default role for new users is the least privileged role. Admin or other high privileged roles should only be assigned as necessary. Regularly review and update the role definitions as the responsibilities and security levels of the organization change.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        enum UserRole { admin, user }

        class User {
          UserRole role;
          User(this.role);
        }

        void handleRequest(shelf.Request request, User user) {
          if (user.role == UserRole.admin) {
            print('Admin privileges granted.');
          } else {
            print('User privileges granted.');
          }
        }
    steps:
    - Define a clear role-based access control (RBAC) system. This should include
      a clear definition of roles and their respective permissions.
    - Avoid hardcoding roles within the code. Instead, roles should be stored in a
      secure database or configuration file.
    - Implement a mechanism to assign roles to users dynamically. This could be done
      during user registration or by an admin.
    - Ensure that role checks are performed at every point where privileged operations
      are performed. This should be done before granting access to any resources or
      operations.
    - Consider using a middleware for role checks. This can help to centralize the
      role checking logic and reduce the chances of missing a check.
    - Ensure that the default role for new users is the least privileged role. Admin
      or other high privileged roles should only be assigned as necessary.
    - Regularly review and update the role definitions as the responsibilities and
      security levels of the organization change.
  title: Insecure service configuration - Roles
  vulnerability_id: '319'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Ensure proper data validation and sanitization to prevent HTML code injection
  solution:
    insecure_code_example:
      description: "In the above Dart code, we have a simple server that uses the\
        \ Shelf framework. The server receives a request and directly sends the content\
        \ of the request back as a response. This is a very basic echo server.\n\n\
        The vulnerability lies in the `handleRequest` function. This function reads\
        \ the body of the request as a string and directly sends it back as the response\
        \ without performing any form of data validation or sanitization. \n\nThis\
        \ means if a user sends a request with HTML code in the body, the server will\
        \ return that HTML code back in the response. If this response is interpreted\
        \ by a web browser, then the HTML code will be executed. This is a form of\
        \ Cross-Site Scripting (XSS) attack, where an attacker can inject malicious\
        \ scripts to be executed by the user's browser. \n\nThe server should not\
        \ trust user input blindly and should always sanitize and validate it before\
        \ using it."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var body = request.readAsString();
          return shelf.Response.ok(body);
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable to HTML injection because it directly used the body of the request as the body of the response without any validation or sanitization. This means that if the request body contained any HTML code, it would be included in the response and could potentially be interpreted by the client, leading to various types of attacks such as Cross-Site Scripting (XSS).

        The fixed code introduces a data validation layer before sending the response. It uses the `HtmlEscape` class from the `html_escape` package to sanitize the input and remove or escape any HTML tags. This ensures that the sanitized data is the data that gets sent in the response, not the original, potentially malicious data.

        In addition to this code-level fix, it is also recommended to use a Content Security Policy (CSP) to add an extra layer of security and prevent any injected code from running. This would be configured at the server level, not in the Dart code itself.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:html_escape/html_escape.dart';

        shelf.Response handleRequest(shelf.Request request) {
          var body = request.readAsString();
          var sanitizedBody = HtmlEscape().convert(body);
          return shelf.Response.ok(sanitizedBody);
        }
    steps:
    - Introduce a data validation layer before sending the response.
    - Use a library or built-in function to sanitize the input and remove or escape
      any HTML tags.
    - Ensure that the sanitized data is the data that gets sent in the response, not
      the original, potentially malicious data.
    - Consider using a Content Security Policy (CSP) to add an extra layer of security
      and prevent any injected code from running.
  title: Lack of data validation - HTML code
  vulnerability_id: '321'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.12.0 for building cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_cookie for managing cookies in a Shelf application
  need: Securely generate and manage session tokens with appropriate lifespan
  solution:
    insecure_code_example:
      description: "In the above code, we have a function `handleRequest` that handles\
        \ incoming requests. Inside this function, a session token is generated using\
        \ the `generateToken` function. \n\nThis session token is then stored in a\
        \ cookie named 'session'. The cookie is set to expire after 5 days from the\
        \ current date and time. This is done using `DateTime.now().add(Duration(days:\
        \ 5))`. \n\nThe cookie with the session token is then added to the response\
        \ headers and sent back to the client.\n\nThe vulnerability here is that the\
        \ session token has a lifespan of 5 days. This is an insecure practice, as\
        \ it increases the window in which an attacker can use a stolen session token\
        \ to impersonate a user. A shorter session token lifespan reduces the time\
        \ an attacker has to use a stolen token."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_cookie/shelf_cookie.dart';

        shelf.Response handleRequest(shelf.Request request) {
          final sessionToken = generateToken();
          final cookie = Cookie('session', sessionToken)..expires = DateTime.now().add(Duration(days: 5));
          return shelf.Response.ok('Hello, World!')
              .change(headers: {'set-cookie': cookie.toString()});
        }

        String generateToken() {
          // Token generation logic
          return 'token';
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code reduces the lifespan of the session token to a more secure duration of 2 hours. This is a more secure practice as it limits the time window in which an attacker can use a stolen token.

        However, this is just one part of the solution. To further enhance the security, consider implementing the following:

        - **Token Refresh Mechanism**: Issue a new token each time the user interacts with the application. This keeps the session active while the user is active, and invalidates the token when the user is inactive.

        - **Sliding Sessions**: Reset the expiration time after each request. This way, the session will only expire if the user is inactive for the specified duration.

        - **Token Invalidation**: Implement a mechanism to invalidate the session token on the server side when the user logs out or after a certain period of inactivity. This ensures that even if a token is stolen, it cannot be used indefinitely by an attacker.

        Remember, security is not a one-time thing but a continuous process. Always keep your application updated with the latest security practices and patches.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_cookie/shelf_cookie.dart';

        shelf.Response handleRequest(shelf.Request request) {
          final sessionToken = generateToken();
          final cookie = Cookie('session', sessionToken)..expires = DateTime.now().add(Duration(hours: 2));
          return shelf.Response.ok('Hello, World!')
              .change(headers: {'set-cookie': cookie.toString()});
        }

        String generateToken() {
          // Token generation logic
          return 'token';
        }
    steps:
    - Reduce the lifespan of the session token to a more secure duration. This could
      be a few hours or even less depending on the sensitivity of the application.
    - Implement a mechanism to refresh the token. This could be done by issuing a
      new token each time the user interacts with the application, thus keeping the
      session active while the user is active.
    - Consider using a sliding session, where the expiration time is reset after each
      request. This way, the session will only expire if the user is inactive for
      the specified duration.
    - Implement a mechanism to invalidate the session token on the server side when
      the user logs out or after a certain period of inactivity.
  title: Insecurely generated token - Lifespan
  vulnerability_id: '322'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure user management and access control
  solution:
    insecure_code_example:
      description: |-
        The code above is an example of a user management system where it is possible to assign non-users as treatment managers of vulnerabilities. The `UserManagement` class maintains a list of users and a list of treatment managers. The `assignTreatmentManager` function allows any email to be assigned as a treatment manager, without checking if the email is registered as a user. This function also sends an email to the treatment manager with the details of the vulnerabilities.

        The `main` function sets up a server that listens for POST requests. If a POST request is received, the server retrieves the email from the request headers and assigns it as a treatment manager, regardless of whether the email is registered as a user.

        This code is vulnerable because it allows non-users to be assigned as treatment managers and receive sensitive information about vulnerabilities. In addition, even if a user is removed from the system, they can still receive vulnerability details because their email remains in the treatment managers list.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class UserManagement {
          List<String> users = [];
          List<String> treatmentManagers = [];

          void addUser(String email) {
            users.add(email);
          }

          void removeUser(String email) {
            users.remove(email);
          }

          void assignTreatmentManager(String email) {
            treatmentManagers.add(email);
            sendEmail(email);
          }

          void sendEmail(String email) {
            // code to send email with vulnerability details
          }
        }

        void main() {
          var userManagement = UserManagement();

          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler((shelf.Request request) {
            if (request.method == 'POST') {
              var email = request.headers['email'];
              userManagement.assignTreatmentManager(email);
            }
            return shelf.Response.ok('Request processed');
          });

          shelf.serve(handler, 'localhost', 8080);
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a check to ensure that the email being assigned as a treatment manager is in the list of users. This is done in the `assignTreatmentManager` method of the `UserManagement` class. If the email is not found in the list of users, an error message is printed and the email is not added to the treatment managers list.

        When a user is removed using the `removeUser` method, the code now also checks if the user is in the treatment managers list. If they are, they are removed from this list as well. This ensures that a user who has been removed from the system no longer has access to vulnerability information.

        In the `main` function, before assigning the treatment manager, the code now checks if the email is in the list of users. This is an additional safeguard to ensure that only valid users can be assigned as treatment managers.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class UserManagement {
          List<String> users = [];
          List<String> treatmentManagers = [];

          void addUser(String email) {
            users.add(email);
          }

          void removeUser(String email) {
            users.remove(email);
            if (treatmentManagers.contains(email)) {
              treatmentManagers.remove(email);
            }
          }

          void assignTreatmentManager(String email) {
            if (users.contains(email)) {
              treatmentManagers.add(email);
              sendEmail(email);
            } else {
              print('Error: User not found');
            }
          }

          void sendEmail(String email) {
            // code to send email with vulnerability details
          }
        }

        void main() {
          var userManagement = UserManagement();

          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler((shelf.Request request) {
            if (request.method == 'POST') {
              var email = request.headers['email'];
              if (userManagement.users.contains(email)) {
                userManagement.assignTreatmentManager(email);
              }
            }
            return shelf.Response.ok('Request processed');
          });

          shelf.serve(handler, 'localhost', 8080);
        }
    steps:
    - Validate the email before assigning it as a treatment manager. Check if the
      email is in the list of users.
    - When removing a user, also remove them from the treatmentManagers list if they
      are present there.
    - Implement a mechanism to revoke access to vulnerability information for users
      who have been removed.
  title: Insecure functionality - User management
  vulnerability_id: '324'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and efficient web applications
  - Usage of Shelf for managing and organizing data in Node.js applications
  need: Secure storage of sensitive information in separate protected environments
  solution:
    insecure_code_example:
      description: "The above code represents a basic server setup using the shelf\
        \ framework in Dart. The problem lies in the declaration and usage of the\
        \ `PRIVATE_KEY` constant. This constant is storing sensitive information,\
        \ in this case a private key, directly in the source code. \n\nThis is a serious\
        \ security vulnerability because anyone who has access to the source code\
        \ will also have access to this private key. This can lead to unauthorized\
        \ access, data breaches and other security issues. \n\nIn addition, storing\
        \ sensitive information in the source code makes it difficult to manage and\
        \ rotate keys. If you need to change the private key, you will need to change\
        \ the source code and redeploy the application. \n\nThe secure way to handle\
        \ sensitive information like private keys, API keys, passwords etc. is to\
        \ store them in a secure and encrypted environment variables or in a secure\
        \ key management system. This way, the sensitive information is not exposed\
        \ in the source code and can be managed separately from the application code."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var app = shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          shelf.serve(app, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        const String PRIVATE_KEY = '5d6321f42795c';
    language: dart
    secure_code_example:
      description: |-
        The private key was removed from the source code and stored in an environment variable. This is a more secure way to handle sensitive information, as it is not directly embedded in the code, which could be exposed if the source code is compromised.

        The `Platform.environment` is a built-in Dart function that allows you to access environment variables. In this case, it is used to access the 'PRIVATE_KEY' environment variable.

        To set the environment variable, you can use the following command in the terminal before running your Dart program:

        ```bash
        export PRIVATE_KEY=your_private_key
        ```

        Remember to replace `your_private_key` with your actual private key.

        This environment variable is only set for the current session. To make it permanent, you can add the export command to your shell's profile script.

        Also, ensure that the environment where you store the key is secure and access is restricted. Rotate your keys regularly to minimize the impact if they are compromised. Never expose your private key in logs, error messages, or other outward-facing information.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var app = shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          shelf.serve(app, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        final String PRIVATE_KEY = Platform.environment['PRIVATE_KEY'];
    steps:
    - Remove the private key from the source code.
    - Store the private key in a secure and encrypted storage.
    - Use environment variables to access the private key in your application.
    - Ensure that the environment where you store the key is secure and access is
      restricted.
    - Rotate your keys regularly to minimize the impact if they are compromised.
    - Never expose your private key in logs, error messages, or other outward-facing
      information.
  title: Sensitive information in source code - Dependencies
  vulnerability_id: '326'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Enhanced data authenticity validation for profile images
  solution:
    insecure_code_example:
      description: "In the above code, the `handleRequest` function is responsible\
        \ for handling incoming requests. This function fetches the `imageUrl` from\
        \ the request headers and sends it back in the response without any validation.\
        \ \n\nThis is problematic as it does not validate whether the `imageUrl` is\
        \ a valid image URL. An attacker could potentially use partial paths or URLs\
        \ to craft complex attack vectors such as controlled redirects or CSRF (Cross-Site\
        \ Request Forgery). \n\nFor example, an attacker could send a request with\
        \ a malicious URL in the `imageUrl` header. Since the system does not validate\
        \ the `imageUrl`, it would accept the malicious URL and potentially expose\
        \ the system to a security risk.\n\nIn essence, the vulnerability lies in\
        \ the lack of authenticity validation for the `imageUrl` data."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var imageUrl = request.headers['imageUrl'];
          var response = shelf.Response.ok('Image URL: $imageUrl');
          return response;
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes several security measures to validate the image URL and prevent CSRF attacks.

        Firstly, the `isURL` function from the `valid_url` package is used to validate that the `imageUrl` is a valid URL. If it's not, a 400 response is returned with a message indicating that the URL is invalid.

        Next, a HEAD request is sent to the `imageUrl` using Dart's `HttpClient`. The 'Content-Type' header in the response is checked to ensure it starts with 'image/'. If it doesn't, a 400 response is returned with a message indicating that the URL does not point to an image.

        The domain of the `imageUrl` is then checked against a whitelist of trusted domains. If the domain is not in the whitelist, a 403 response is returned with a message indicating that the image URL is not from a trusted domain.

        Finally, CSRF protection is implemented using the `shelf_csrf` package. A CSRF middleware is created and added to the router. The `allowOrigin` function is used to restrict the origins that are allowed to send requests to the server to those in the whitelist.

        The response is then returned as before, but now with the added security measures.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';
        import 'package:shelf_csrf/shelf_csrf.dart';
        import 'package:valid_url/valid_url.dart';

        final _whitelist = ['trusteddomain1.com', 'trusteddomain2.com'];

        shelf.Response handleRequest(shelf.Request request) {
          var imageUrl = request.headers['imageUrl'];

          // Validate the imageUrl
          if (!isURL(imageUrl)) {
            return shelf.Response(400, body: 'Invalid image URL');
          }

          // Check that the URL points to an actual image
          var httpClient = HttpClient();
          httpClient.headUrl(Uri.parse(imageUrl)).then((request) {
            return request.close();
          }).then((response) {
            if (!response.headers.value('content-type').startsWith('image/')) {
              return shelf.Response(400, body: 'URL does not point to an image');
            }
          });

          // Check the domain against a whitelist
          var uri = Uri.parse(imageUrl);
          if (!_whitelist.contains(uri.host)) {
            return shelf.Response(403, body: 'Image URL not from a trusted domain');
          }

          // Implement CSRF protection
          var csrfMiddleware = createCsrfMiddleware(
            randomString: generateRandomString,
            allowOrigin: (origin) => _whitelist.contains(Uri.parse(origin).host),
          );
          var router = Router();
          router.all('/<ignored|.*>', csrfMiddleware);

          var response = shelf.Response.ok('Image URL: $imageUrl');
          return response;
        }
    steps:
    - Validate the imageUrl header to ensure it's a valid URL. You can use a regular
      expression or a URL parsing library to do this.
    - Check that the URL points to an actual image. You can do this by sending a HEAD
      request to the URL and checking the 'Content-Type' header in the response. It
      should start with 'image/'.
    - Consider using a whitelist of trusted domains to prevent the use of URLs from
      potentially malicious sources.
    - Implement a mechanism to prevent CSRF attacks. This could be a CSRF token that
      is sent with every request and validated on the server.
    - Consider using a Content Security Policy (CSP) to restrict the sources from
      which images can be loaded.
  title: Insufficient data authenticity validation - Images
  vulnerability_id: '327'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure session management
  solution:
    insecure_code_example:
      description: "The above code is a simple representation of how an insecure object\
        \ reference vulnerability could be introduced in a Dart backend application\
        \ using the Shelf framework. \n\nThe `handleRequest` function is designed\
        \ to handle incoming HTTP requests. It extracts an 'email' and 'action' from\
        \ the request headers. If the 'action' is 'close', it removes the active session\
        \ for the user with the provided email.\n\nThe vulnerability lies in the fact\
        \ that the function does not check if the request is coming from the user\
        \ whose session is to be closed. As a result, if an attacker knows the email\
        \ of another user, they can send a request with that user's email and the\
        \ action 'close' to close the other user's active session.\n\nThis is an insecure\
        \ direct object reference (IDOR) vulnerability because direct references to\
        \ internal objects (in this case, active user sessions) are exposed to users\
        \ without proper authorization checks. In this case, the 'email' header is\
        \ a direct reference to the user session object."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        Map<String, String> activeSessions = {};

        shelf.Response handleRequest(shelf.Request request) {
          var email = request.headers['email'];
          var action = request.headers['action'];

          if(action == 'close') {
            activeSessions.remove(email);
            return shelf.Response.ok('Session closed for $email');
          } else {
            return shelf.Response.ok('Invalid action');
          }
        }
    language: dart
    secure_code_example:
      description: "The updated code now uses a session ID instead of an email to\
        \ manage sessions. This session ID should be unique and hard to guess, which\
        \ makes it more secure than using an email address. \n\nThe `handleRequest`\
        \ function now checks if the session ID exists in the `activeSessions` map\
        \ before performing any action. This is a form of authentication, as it verifies\
        \ that the session is active.\n\nIf the session ID exists and the action is\
        \ 'close', the session is removed from the `activeSessions` map and a response\
        \ is returned indicating that the session has been closed. If the action is\
        \ not 'close', a response is returned indicating that the action is invalid.\n\
        \nIf the session ID does not exist in the `activeSessions` map, a response\
        \ is returned indicating that the session is invalid. This is a form of authorization,\
        \ as it prevents users from performing actions on sessions that do not belong\
        \ to them.\n\nThis code should be used in conjunction with secure methods\
        \ of storing and transmitting the session ID, such as secure HTTP cookies\
        \ and secure connections, to further enhance security. Additionally, a mechanism\
        \ should be implemented to invalidate the session ID after the user logs out\
        \ or after a certain period of inactivity."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        Map<String, String> activeSessions = {};

        shelf.Response handleRequest(shelf.Request request) {
          var sessionId = request.headers['sessionId'];
          var action = request.headers['action'];

          if(activeSessions.containsKey(sessionId)) {
            if(action == 'close') {
              activeSessions.remove(sessionId);
              return shelf.Response.ok('Session closed');
            } else {
              return shelf.Response.ok('Invalid action');
            }
          } else {
            return shelf.Response.forbidden('Invalid session');
          }
        }
    steps:
    - Authenticate the user before allowing them to perform any action. This can be
      done by checking if the session associated with the user is active.
    - Implement a mechanism to verify if the user has the necessary permissions to
      perform the action. In this case, the user should only be able to close their
      own session.
    - Instead of using the email as a parameter to close the session, use the session
      ID. This ID should be unique and hard to guess.
    - Store the session ID in a secure way, such as in a secure HTTP cookie, and ensure
      it is sent over a secure connection to prevent interception.
    - Implement a mechanism to invalidate the session ID after the user logs out or
      after a certain period of inactivity.
  title: Insecure object reference - Session management
  vulnerability_id: '328'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0+ for developing scalable and efficient applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Enforce secure and properly defined Content-Type headers in server responses
  solution:
    insecure_code_example:
      description: |-
        In the above code, a server response is being created using the `shelf.Response.ok` method, which creates a successful HTTP response with a 200 status code. The response body is set to 'Hello, World!', but no headers are defined.

        This is a problem because the server does not specify the `Content-Type` header in its response. The `Content-Type` HTTP header is important because it tells the client what the content type of the returned content actually is. Browsers use this information to process the content correctly. If this header is not set, the client has to guess the content type, which can lead to security issues.

        For example, an attacker might be able to trick the client into interpreting the content as something malicious, like a script, instead of the intended type. Therefore, it's always recommended to explicitly set the `Content-Type` header in server responses.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          return shelf.Response.ok('Hello, World!');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable because it did not specify the `Content-Type` HTTP header in the server response. This could potentially lead to security issues such as MIME type confusion attacks.

        The fixed code addresses this vulnerability by explicitly setting the `Content-Type` header in the server response. In this case, since the server is returning a plain text message ('Hello, World!'), the `Content-Type` is set to 'text/plain'.

        This ensures that the client receiving the response knows how to correctly interpret the data. It's important to note that the `Content-Type` should be set to the appropriate value depending on the type of data being returned. For example, if the server was returning a JSON object, the `Content-Type` would be set to 'application/json'.

        By always setting the `Content-Type` header in your server responses, you can help protect your application from certain types of security vulnerabilities.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          return shelf.Response.ok(
            'Hello, World!',
            headers: {'Content-Type': 'text/plain'},
          );
        }
    steps:
    - Identify where the server response is being created.
    - Add the 'Content-Type' header to the response.
    - Set the 'Content-Type' header to the appropriate value for the data being returned.
      For example, if you're returning HTML, you would set it to 'text/html'. If you're
      returning JSON, you would set it to 'application/json'.
    - Ensure that the 'Content-Type' header is set for all server responses, not just
      some of them.
  title: Insecure or unset HTTP headers - Content-Type
  vulnerability_id: '329'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of strong and effective protection against brute force attacks
    on credentials
  solution:
    insecure_code_example:
      description: |-
        In the above code, we are using the `shelf` framework in Dart to handle HTTP requests. The `PromoCodeController` class has a method `checkPromoCode` which is used to check if a promo code is valid or not.

        This method takes a `shelf.Request` object as a parameter and reads the `promoCode` query parameter from the request URL. It then checks if this promo code is in the list of valid promo codes. If it is, it returns a 200 OK response with a message saying that the promo code is valid. If the promo code is not in the list, it returns a 400 Bad Request response with a message saying that the promo code is invalid.

        The vulnerability in this code is that it does not have any protection against brute force attacks. An attacker could potentially send a large number of requests with different promo codes in an attempt to guess a valid one. Since there is no rate limiting or other protection mechanism in place, the application could be overwhelmed by these requests, leading to a denial of service. Furthermore, if the attacker is able to guess a valid promo code, they could potentially gain unauthorized access to whatever the promo code provides.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class PromoCodeController {
          static const List<String> validPromoCodes = ['PROMO1', 'PROMO2', 'PROMO3'];

          shelf.Response checkPromoCode(shelf.Request request) {
            final promoCode = request.url.queryParameters['promoCode'];
            if (validPromoCodes.contains(promoCode)) {
              return shelf.Response.ok('Promo code is valid!');
            } else {
              return shelf.Response(400, body: 'Invalid promo code.');
            }
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a rate limiting mechanism to protect against brute force attacks. The `shelf_rate_limiter` package is used to limit the number of requests a user can make within a certain time period. In this case, the limit is set to 10 requests per minute.

        The `checkPromoCode` method now also keeps track of the number of invalid promo code attempts from each IP address. If a user makes more than 10 invalid attempts, they will receive a 'Too many requests. Please try again later.' response.

        This solution does not include a CAPTCHA challenge or account lockouts/delays, as these would require significant changes to the application and potentially the user interface. However, these are also effective measures to consider for protecting against brute force attacks.

        The promo codes are still stored and compared in plain text. For a more secure solution, consider hashing the promo codes and comparing the hashes.

        Finally, the application now monitors for suspicious activity by tracking the number of requests from each IP address. If a high number of requests is detected, the application could block or limit such activity. This would require additional logic and potentially a separate service or tool for monitoring and blocking IP addresses.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_rate_limiter/shelf_rate_limiter.dart';
        import 'package:shelf_router/shelf_router.dart';
        import 'dart:io';

        class PromoCodeController {
          static const List<String> validPromoCodes = ['PROMO1', 'PROMO2', 'PROMO3'];
          static final Map<String, int> requestCounts = {};

          shelf.Response checkPromoCode(shelf.Request request) {
            final promoCode = request.url.queryParameters['promoCode'];
            final ipAddress = request.headers['x-forwarded-for'] ?? request.remoteAddress.address;

            if (requestCounts.containsKey(ipAddress) && requestCounts[ipAddress]! > 10) {
              return shelf.Response(429, body: 'Too many requests. Please try again later.');
            }

            if (validPromoCodes.contains(promoCode)) {
              return shelf.Response.ok('Promo code is valid!');
            } else {
              requestCounts.update(ipAddress, (count) => count + 1, ifAbsent: () => 1);
              return shelf.Response(400, body: 'Invalid promo code.');
            }
          }
        }

        void main() {
          var app = Router();

          var rateLimiter = createRateLimiterMiddleware(
            rateLimiter: RateLimiter(
              maxOperationsPerPeriod: 10,
              period: Duration(minutes: 1),
            ),
          );

          app.post('/checkPromoCode', rateLimiter(PromoCodeController().checkPromoCode));

          var server = shelf_io.serve(app, InternetAddress.loopbackIPv4, 8080);
          server.then((value) => print('Server started on port: ${value.port}'));
        }
    steps:
    - Implement a rate limiting mechanism to limit the number of requests a user can
      make within a certain time period.
    - Add a CAPTCHA challenge to the promo code submission process to prevent automated
      submissions.
    - Consider using account lockouts or delays after a certain number of failed attempts
      to deter brute force attacks.
    - Use a more secure method for storing and validating promo codes, such as hashing
      them and comparing the hashes instead of the plain text codes.
    - Monitor for suspicious activity, such as a high number of requests from a single
      IP address, and block or limit such activity.
  title: Lack of protection against brute force attacks - Credentials
  vulnerability_id: '330'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and interacting with data storage in Node.js
  need: Secure transmission of customer information
  solution:
    insecure_code_example:
      description: "The above code represents a simple backend server using the Shelf\
        \ framework in Dart. The server is set up to listen on `localhost` at port\
        \ `8080` and responds to all incoming requests with a simple message containing\
        \ the requested URL. \n\nThe vulnerability in this code lies in the fact that\
        \ it uses an insecure HTTP channel to communicate, which does not provide\
        \ any form of encryption for the transmitted data. This means that any sensitive\
        \ information, such as customer data, that is transmitted over this channel\
        \ can be intercepted and read by malicious third parties. \n\nIn the context\
        \ of this code, the vulnerability is specifically in the `io.serve(handler,\
        \ 'localhost', 8080);` line. This line sets up the server to listen for incoming\
        \ connections, but it does not specify any form of encryption to be used,\
        \ thus creating an insecure channel. \n\nTo exploit this vulnerability, an\
        \ attacker would simply need to intercept the communication between the server\
        \ and a client. Since the data is not encrypted, they would be able to read\
        \ and potentially misuse any information they capture."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: "The updated code now uses the `serveSecure` function from the\
        \ `shelf_io` package instead of the `serve` function. This function enables\
        \ secure communication over the network by using SSL/TLS encryption.\n\nA\
        \ `SecurityContext` object is created, which is used to specify the server\
        \ certificate and private key. The `useCertificateChain` method is used to\
        \ specify the path to the server certificate, and the `usePrivateKey` method\
        \ is used to specify the path to the private key. The password for the private\
        \ key is also provided.\n\nThe `serveSecure` function is then called with\
        \ the handler, the hostname, the port, and the `SecurityContext` object as\
        \ parameters. This ensures that all communication over the network is encrypted\
        \ and secure.\n\nPlease note that the paths to the server certificate and\
        \ private key, as well as the password for the private key, should be stored\
        \ securely and not be accessible to unauthorized users. \n\nAfter implementing\
        \ these changes, test the application to ensure that customer information\
        \ is now transmitted over a secure channel."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          var serverCertificate = new SecurityContext()
            ..useCertificateChain('path/to/certificate.pem')
            ..usePrivateKey('path/to/private_key.pem', password: 'password');

          io.serveSecure(handler, 'localhost', 8080, serverCertificate);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Import the 'shelf' and 'shelf_io' packages from the 'shelf' library.
    - Replace the 'serve' function with the 'serveSecure' function to enable secure
      communication.
    - Provide the necessary parameters for the 'serveSecure' function, including the
      server certificate and private key.
    - Ensure that the server certificate and private key are stored securely and are
      not accessible to unauthorized users.
    - Test the application to ensure that customer information is now transmitted
      over a secure channel.
  title: Use of insecure channel - Source code
  vulnerability_id: '332'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing database queries and data storage
  - Usage of shelf_io for managing and organizing data storage in Node.js
  need: Secure session management and protection against CSRF Fixation
  solution:
    insecure_code_example:
      description: |-
        The above code represents a simple server application written using the `Shelf` framework in Dart. The main function sets up a server listening on `localhost` port `8080` and forwards all requests to the `_echoRequest` function.

        The function `handleTransaction` is intended to handle transaction requests. It reads the `authorization` header from the request, which is used as a public key for the transaction. The transaction data is read from the request body.

        The vulnerability here is that the public key used for authorization is always the same for payment links. This can lead to Cross-Site Request Forgery (CSRF) Fixation attacks. An attacker can create a button with the content of a request and trick a user running a transaction to receive the app push notification and complete the request. Since the public key is always the same, the attacker can easily forge a request to initiate a transaction on behalf of the victim.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        shelf.Response handleTransaction(shelf.Request request) {
          var publicKey = request.headers['authorization']; // public key is used as authorization header
          var transactionData = request.readAsString(); // transaction data is read from the request body
          // transaction is processed here
          return shelf.Response.ok('Transaction Successful');
        }
    language: dart
    secure_code_example:
      description: |-
        The code above implements a secure session management system by generating a unique session ID for each user session. The session ID is generated using a strong random number generator, which ensures that it is secure and unpredictable.

        The session ID is stored on the client side in a secure cookie with the HttpOnly and Secure flags set. This prevents the session ID from being accessed through client-side scripts, which can help to prevent session hijacking attacks.

        The session ID is validated on each request by comparing the session ID sent by the client with the one stored on the server side. If the session ID is not valid, the server responds with a 403 Forbidden status code.

        The code also implements a CSRF token system by generating a unique CSRF token for each session and including it in all state-changing requests. The server validates the CSRF token on each request to ensure that the request is legitimate.

        The CSRF token is rotated after each request to prevent CSRF fixation attacks. This ensures that an attacker cannot fixate the CSRF token and use it to perform a CSRF attack.

        Finally, the code does not use predictable or static values (like a public key) for authorization. Instead, it uses a dynamic value that changes with each session. This makes it more difficult for an attacker to guess the authorization value and perform an unauthorized action.
      text: |-
        import 'dart:math';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        Map<String, String> sessions = {}; // Store sessions

        String generateSessionId() {
          var random = Random.secure();
          var values = List<int>.generate(16, (i) => random.nextInt(256));
          return values.join();
        }

        shelf.Response handleTransaction(shelf.Request request) {
          var sessionId = request.headers['session-id'];
          if (sessionId == null || sessions[sessionId] == null) {
            return shelf.Response.forbidden('Invalid session');
          }
          var transactionData = request.readAsString(); // transaction data is read from the request body
          // transaction is processed here
          return shelf.Response.ok('Transaction Successful');
        }
    steps:
    - Implement a secure session management system. This could be done by generating
      a unique session ID for each user session and invalidating it after a certain
      period of inactivity.
    - Use a secure and unpredictable method for generating session IDs. This could
      be done by using a strong random number generator.
    - Store the session ID securely on the client side. This could be done by storing
      it in a secure cookie with the HttpOnly and Secure flags set.
    - Validate the session ID on each request. This could be done by comparing the
      session ID sent by the client with the one stored on the server side.
    - Implement a CSRF token system. This could be done by generating a unique CSRF
      token for each session and including it in all state-changing requests. The
      server should then validate the CSRF token on each request.
    - Rotate the CSRF token after each request to prevent CSRF fixation attacks.
    - Do not use predictable or static values (like a public key) for authorization.
      Instead, use a dynamic value that changes with each session.
  title: Insecure session management - CSRF Fixation
  vulnerability_id: '337'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of secure service configuration - Request Validation
  solution:
    insecure_code_example:
      description: |-
        The above code represents a simple server setup using the Shelf framework in Dart. This server listens on `localhost` at port `8080` and responds with a simple message for every request it receives.

        However, this code is vulnerable to Cross-Site Scripting (XSS) attacks because it lacks request validation. Specifically, the `_echoRequest` function returns a response that includes the request URL directly without sanitizing or validating it. This means that if an attacker sends a request with a malicious script in the URL, the server will return that script as part of its response, potentially leading to an XSS attack if that response is then rendered in a client-side context.

        For example, an attacker could send a request to `http://localhost:8080/<script>malicious code</script>`, and the server would return that script as part of its response. If this response is then rendered in a browser, the malicious script could be executed, leading to an XSS attack.

        To fix this vulnerability, the server should validate and sanitize all inputs, including the request URL, before using them. This can be done using various input validation and sanitization libraries available in Dart.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable to Cross-Site Scripting (XSS) attacks because it did not validate or sanitize the user input before including it in the response. This could allow an attacker to inject malicious scripts into the response, which would then be executed by the user's browser.

        The fixed code mitigates this vulnerability by using the `html_escape` package to sanitize the user input. The `escapeHtml` function is used to replace any special characters in the user input with their HTML encoded equivalents. This ensures that any input is treated as data by the user's browser, rather than being executed as code.

        In addition to this, it's recommended to use security-focused libraries or frameworks that automatically handle these types of vulnerabilities, regularly update and patch your libraries and frameworks to ensure you have the latest security fixes, and consider using a web application firewall (WAF) to help protect against XSS attacks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:html_escape/html_escape.dart';

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var safeUrl = escapeHtml(request.url.toString());
          return shelf.Response.ok('Request for "$safeUrl"');
        }
    steps:
    - Identify the points in your code where user input is processed or included in
      responses.
    - Implement input validation to ensure only expected types of data are accepted.
      This can be done using regular expressions or built-in validation functions.
    - Encode the output to ensure that it is displayed as data to the user and not
      executed as code. This can be done using functions that convert special characters
      to their HTML encoded equivalents.
    - Use a security-focused library or framework that automatically handles these
      types of vulnerabilities.
    - Regularly update and patch your libraries and frameworks to ensure you have
      the latest security fixes.
    - Consider using a web application firewall (WAF) to help protect against XSS
      attacks.
  title: Insecure service configuration - Request Validation
  vulnerability_id: '339'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of proper data validation to prevent the entry of special characters
    in fields.
  solution:
    insecure_code_example:
      description: |-
        In the above Dart code, we are using the Shelf framework to handle HTTP requests. Specifically, we're looking at a function `handleRequest` that takes a `shelf.Request` as an argument and returns a `shelf.Response`.

        The vulnerability lies in the following lines:

        ```dart
        var params = request.url.queryParameters;
        var name = params['name'];
        ```

        Here, we're extracting query parameters from the URL of the request. We then directly use the 'name' parameter from the request without any validation. This means if a client sends a request with special characters in the 'name' parameter, our system will accept it and proceed with the processing, which could lead to unexpected behavior or security vulnerabilities such as Cross-Site Scripting (XSS) or SQL Injection.

        For instance, a user could send a request with a name parameter like `John<script>alert('Hacked')</script>`, and our system would accept this input and potentially execute the embedded script when the response is rendered in a web page.

        To fix this vulnerability, we need to validate the 'name' parameter to ensure it does not contain any special characters before using it.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var params = request.url.queryParameters;
          var name = params['name'];

          // Process name without validating special characters

          return shelf.Response.ok('Hello, $name!');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a new function `isValid` that checks if a string contains any special characters. This function uses a regular expression to check if the string only contains alphanumeric characters (letters and numbers). If the string contains any special characters, the function returns `false`.

        In the `handleRequest` function, we now call `isValid` to validate the 'name' parameter before processing it. If `isValid` returns `false`, the function immediately returns a response with a 400 status code and an error message indicating that the input is invalid. This prevents the rest of the function from processing the invalid input.

        This change ensures that the system validates all input for special characters before processing it, which can help prevent various types of attacks, such as SQL injection or cross-site scripting (XSS). It's important to always validate input on the server side, even if you also do client-side validation, because attackers can easily bypass client-side validation.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        bool isValid(String input) {
          // Check if the string contains any special characters
          return RegExp(r'^[a-zA-Z0-9]+$').hasMatch(input);
        }

        shelf.Response handleRequest(shelf.Request request) {
          var params = request.url.queryParameters;
          var name = params['name'];

          // Validate name before processing
          if (!isValid(name)) {
            return shelf.Response(400, body: 'Invalid input: name should not contain special characters');
          }

          return shelf.Response.ok('Hello, $name!');
        }
    steps:
    - Introduce a validation function that checks for special characters in the 'name'
      parameter.
    - Use this function to validate the 'name' parameter before processing it.
    - If the validation function detects special characters, the function should handle
      it appropriately, for example by returning an error message or sanitizing the
      input.
    - Ensure that the validation function is used every time the 'name' parameter
      is processed, to maintain consistency and security.
  title: Lack of data validation - Special Characters
  vulnerability_id: '340'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of proper data validation for OTP tokenCode parameter
  solution:
    insecure_code_example:
      description: "The above code represents a handler for a request in a backend\
        \ application using the shelf framework in Dart. The vulnerability lies in\
        \ the `handleRequest` function, where the `tokenCode` parameter is fetched\
        \ from the URL query parameters. \n\nThe `tokenCode` is then passed to the\
        \ `validateToken` function to verify its validity. The issue here is that\
        \ there's no evidence of validation of the values sent in the `tokenCode`\
        \ parameter to complete the request, allowing random values to be used in\
        \ multiple attempts. \n\nThis means an attacker could potentially brute force\
        \ the OTP by sending multiple requests with different `tokenCode` values.\
        \ Since there's no limit or validation on these attempts, the application\
        \ is vulnerable to this type of attack."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var tokenCode = request.url.queryParameters['tokenCode'];

          if (tokenCode == null) {
            return shelf.Response(400, body: 'Missing tokenCode parameter');
          }

          // Here is the vulnerability, no validation of the tokenCode
          // Any random values can be used in multiple attempts
          var isTokenValid = validateToken(tokenCode);

          if (isTokenValid) {
            return shelf.Response.ok('Token is valid');
          } else {
            return shelf.Response(400, body: 'Invalid token');
          }
        }

        bool validateToken(String token) {
          // Simulate token validation
          return token == '123456';
        }
    language: dart
    secure_code_example:
      description: |-
        The code above fixes the vulnerability by implementing several security measures:

        1. **Rate Limiting**: A rate limiting mechanism is implemented using the `rate_limiter` package. This limits the number of attempts a user can make within a certain time period (5 attempts every 15 minutes in this example). If a user exceeds this limit, a 429 (Too Many Requests) response is returned.

        2. **Token Format Validation**: Before validating the token, the code checks if the token is in the correct format and length using a regular expression. This is a simple example and should be replaced with your own validation logic.

        3. **Token Validation**: The `validateToken` function simulates token validation. Consider using a more secure method for generating and validating tokens, such as JWT or a library specifically designed for OTPs.

        Note: This code does not implement a lockout mechanism or logging of failed attempts. These features would require a more complex setup, possibly involving a database or external logging service, and are beyond the scope of this example.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:rate_limiter/rate_limiter.dart';

        // Create a memory store for rate limiting
        final store = MemoryStore();

        // Define the rate limiting rules
        final rateLimiter = RateLimiter(store, points: 5, duration: Duration(minutes: 15));

        shelf.Response handleRequest(shelf.Request request) {
          var tokenCode = request.url.queryParameters['tokenCode'];

          if (tokenCode == null || !isTokenFormatValid(tokenCode)) {
            return shelf.Response(400, body: 'Missing or invalid tokenCode parameter');
          }

          // Check if the user has exceeded the rate limit
          if (!rateLimiter.consume(request.remoteAddress)) {
            return shelf.Response(429, body: 'Too many requests');
          }

          var isTokenValid = validateToken(tokenCode);

          if (isTokenValid) {
            return shelf.Response.ok('Token is valid');
          } else {
            return shelf.Response(400, body: 'Invalid token');
          }
        }

        bool isTokenFormatValid(String token) {
          // Check if the token is in the correct format and length
          // This is a simple example, replace with your own validation logic
          return RegExp(r'^\\d{6}$').hasMatch(token);
        }

        bool validateToken(String token) {
          // Simulate token validation
          // Consider using a more secure method for generating and validating tokens
          return token == '123456';
        }
    steps:
    - Implement a rate limiting mechanism to limit the number of attempts a user can
      make within a certain time period.
    - Add a check to ensure the tokenCode is not only present but also in the correct
      format and length.
    - Consider using a more secure method for generating and validating tokens, such
      as JWT or a library specifically designed for OTPs.
    - Implement a lockout mechanism after a certain number of failed attempts to prevent
      brute force attacks.
    - Log failed attempts and set up alerts for multiple failed attempts from the
      same IP address or for the same user.
  title: Lack of data validation - OTP
  vulnerability_id: '341'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of dart:io for handling input and output operations in Dart
  - Usage of Shelf for building web applications in Dart
  need: Implementation of proper input validation and sanitization
  solution:
    insecure_code_example:
      description: "The above code is an example of a Dart backend application using\
        \ the Shelf framework. The function `_echoRequest` receives a request and\
        \ uses the 'input' query parameter of the request URL to construct a system\
        \ command `Process.run('echo', [input])`. \n\nThe vulnerability lies in the\
        \ fact that the input from the request is directly used without any form of\
        \ sanitization or validation. This means that if a malicious user crafts the\
        \ input in a certain way, they could potentially inject commands that could\
        \ be harmful to the system. \n\nFor example, if the user sends a request with\
        \ the input query parameter as `;rm -rf /`, the constructed command becomes\
        \ `echo;rm -rf /` which would delete all files in the root directory if the\
        \ application has sufficient permissions. This is a classic example of a command\
        \ injection vulnerability due to lack of data validation or sanitization."
      text: "import 'dart:io';\n\nimport 'package:shelf/shelf.dart';\n\nvoid main()\
        \ {\n  var handler = const Pipeline().addMiddleware(logRequests()).addHandler(_echoRequest);\n\
        \n  io.serve(handler, 'localhost', 8080).then((server) {\n    print('Serving\
        \ at http://${server.address.host}:${server.port}');\n  });\n}\n\nResponse\
        \ _echoRequest(Request request) {\n  var input = request.url.queryParameters['input'];\n\
        \  \n  Process.run('echo', [input]).then((ProcessResult results) {\n    print(results.stdout);\n\
        \  });\n\n  return Response.ok('Request for \"${request.url}\"');\n}"
    language: dart
    secure_code_example:
      description: "The updated code includes two new functions: `_isValidInput` and\
        \ `_sanitizeInput`. \n\nThe `_isValidInput` function checks if the input contains\
        \ only alphanumeric characters. This is a basic validation and you might need\
        \ to adjust it based on your specific needs. If the input is not valid, the\
        \ system command is not executed.\n\nThe `_sanitizeInput` function removes\
        \ or escapes any special characters in the input. This is a basic sanitization\
        \ and you might need to adjust it based on your specific needs. The sanitized\
        \ input is then used in the system command.\n\nThese changes help to prevent\
        \ command injection attacks by ensuring that only valid and safe input is\
        \ used in the system command. \n\nPlease note that this is a basic solution\
        \ and might not cover all possible command injection attacks. For a more comprehensive\
        \ solution, consider using a safe API that automatically handles the risks\
        \ associated with command injection, limiting the privileges of the process,\
        \ and using parameterized commands."
      text: "import 'dart:io';\nimport 'package:shelf/shelf.dart';\n\nvoid main()\
        \ {\n  var handler = const Pipeline().addMiddleware(logRequests()).addHandler(_echoRequest);\n\
        \n  io.serve(handler, 'localhost', 8080).then((server) {\n    print('Serving\
        \ at http://${server.address.host}:${server.port}');\n  });\n}\n\nResponse\
        \ _echoRequest(Request request) {\n  var input = request.url.queryParameters['input'];\n\
        \  \n  // Validate and sanitize the input\n  if (_isValidInput(input)) {\n\
        \    Process.run('echo', [_sanitizeInput(input)]).then((ProcessResult results)\
        \ {\n      print(results.stdout);\n    });\n  }\n\n  return Response.ok('Request\
        \ for \"${request.url}\"');\n}\n\nbool _isValidInput(String input) {\n  //\
        \ Add validation logic here\n  // For example, check if the input contains\
        \ only alphanumeric characters\n  return RegExp(r'^[a-zA-Z0-9]+$').hasMatch(input);\n\
        }\n\nString _sanitizeInput(String input) {\n  // Add sanitization logic here\n\
        \  // For example, escape or remove special characters\n  return input.replaceAll(RegExp(r'[^\\\
        \\w\\\\s]'), '');\n}"
    steps:
    - 'Validate the input: Before using the user input in the system command, validate
      it against a set of rules. For example, you can check if the input contains
      only alphanumeric characters.'
    - 'Sanitize the input: Remove or escape any special characters that could modify
      the system command. This can be done using a function that escapes or removes
      special characters.'
    - 'Use parameterized commands: Instead of directly inserting user input into the
      system command, use a parameterized command where you can safely insert the
      user input.'
    - 'Limit the privileges of the process: Run the process with the least privileges
      necessary to perform its task. This can limit the damage if an attacker manages
      to inject malicious code.'
    - 'Use a safe API: If possible, use a safe API that automatically handles the
      risks associated with command injection.'
  title: Lack of data validation - Non Sanitized Variables
  vulnerability_id: '344'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance, cross-platform applications
  - Usage of Shelf for managing data storage and retrieval
  need: Enhancement of security controls for session invalidation
  solution:
    insecure_code_example:
      description: |-
        The `handleRequest` function is supposed to check the validity of a session code provided in the headers of a request. If the session code is missing, it correctly responds with a 403 Forbidden status code.

        However, there is a major security flaw in the code. If the session code contains the string 'auto', the function grants access regardless of whether the session code is valid or not. This is because the `sessionCode.contains('auto')` condition checks if the session code contains 'auto' and returns an OK response if it does.

        This means that an attacker could bypass the session validation by simply including 'auto' in their session code. This is a clear case of security controls bypass, as the session validation is not functioning as intended.

        The vulnerability likely arose due to leftover debug code. During the debugging phase, it's common to use shortcuts or bypasses to make testing easier. However, these shortcuts should always be removed before the code is deployed to production. In this case, the 'auto' bypass was not removed, leading to a significant security vulnerability.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var sessionCode = request.headers['session-code'];

          if (sessionCode == null) {
            return shelf.Response.forbidden('Missing session code.');
          }

          if (sessionCode.contains('auto')) {
            return shelf.Response.ok('Access granted.');
          } else {
            return shelf.Response.forbidden('Invalid session code.');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code removes the security vulnerability by eliminating the condition that checks if the session code contains the word 'auto'. Instead, it introduces a new function `isValidSessionCode()` that should contain the logic for validating session codes. This function is currently a placeholder and should be replaced with actual validation logic, such as checking the session code against a database of valid session codes.

        The `handleRequest()` function now checks if the session code is null, and if it is, it returns a forbidden response. If the session code is not null, it checks if the session code is valid using the `isValidSessionCode()` function. If the session code is valid, it returns an OK response, otherwise it returns a forbidden response.

        This code ensures that only valid session codes are accepted, and that session codes containing 'auto' are not automatically accepted. This greatly improves the security of the application by preventing unauthorized access.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        shelf.Response handleRequest(shelf.Request request) {
          var sessionCode = request.headers['session-code'];

          if (sessionCode == null) {
            return shelf.Response.forbidden('Missing session code.');
          }

          // Implement a proper session validation mechanism here
          // For example, check the session code against a database of valid session codes
          if (!isValidSessionCode(sessionCode)) {
            return shelf.Response.forbidden('Invalid session code.');
          }

          return shelf.Response.ok('Access granted.');
        }

        bool isValidSessionCode(String sessionCode) {
          // Implement your session code validation logic here
          // This is just a placeholder
          return sessionCode != 'auto';
        }
    steps:
    - Remove the condition that checks if the session code contains the word 'auto'.
      This condition is a security risk as it allows anyone with a session code containing
      'auto' to gain access.
    - Implement a proper session validation mechanism. This could involve checking
      the session code against a database of valid session codes, or using a secure
      method to generate and validate session codes.
    - Ensure that session codes are invalidated after a certain period of time or
      after they have been used. This prevents an attacker from reusing a session
      code.
    - Consider using a security framework or library that provides built-in mechanisms
      for session management. This can help to ensure that your session management
      code is secure and reliable.
  title: Security controls bypass or absence - Session Invalidation
  vulnerability_id: '345'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of jaguar_jwt for JSON Web Token (JWT) authentication and authorization
  need: Implementation of robust data validation for JWT access tokens
  solution:
    insecure_code_example:
      description: "This Dart code is a simple server-side implementation using the\
        \ Shelf framework. The `handleRequest` function is a request handler that\
        \ checks if the incoming request has an 'Authorization' header that contains\
        \ a JWT token.\n\nThe `verifyJwtHS256Signature` function from the `jaguar_jwt`\
        \ package is used to decode the JWT token. The `verifyJwtHS256Signature` function\
        \ decodes the token but does not validate the signature of the token. This\
        \ is a security vulnerability because an attacker can modify the token or\
        \ remove the signature, and the server will still accept the request as valid.\n\
        \nThe `handleRequest` function checks if the decoded token is not null and\
        \ if it is not, the server responds with a 200 OK status, indicating that\
        \ the request is authorized. If the token is null or does not exist, the server\
        \ responds with a 403 Forbidden status, indicating that the request is unauthorized.\
        \ \n\nHowever, because the `verifyJwtHS256Signature` function does not validate\
        \ the signature of the token, an attacker can send a request with a modified\
        \ or unsigned token, and the server will respond with a 200 OK status, indicating\
        \ that the request is authorized. This is a security vulnerability because\
        \ it allows an attacker to bypass authentication and authorization checks."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:jaguar_jwt/jaguar_jwt.dart';

        shelf.Response handleRequest(shelf.Request request) {
          final String authHeader = request.headers['Authorization'];
          if (authHeader != null && authHeader.startsWith('Bearer ')) {
            final String token = authHeader.substring(7);
            final decClaimSet = verifyJwtHS256Signature(token, 'yourSecret');
            if (decClaimSet != null) {
              return shelf.Response.ok('Authorized');
            }
          }
          return shelf.Response.forbidden('Unauthorized');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a check to ensure that the JWT token is not null or empty before proceeding with any operations. This is done by adding an if condition `if (token != null && token.isNotEmpty)`.

        Next, the code validates the JWT token's signature by using the `verifyJwtHS256Signature` function. This function uses a secret key that only the server knows to verify the signature of the token. If the signature is invalid, the function will throw a `JwtException`.

        The code now handles the `JwtException` thrown by the `verifyJwtHS256Signature` function. If an exception is thrown, it means that the token is invalid. In this case, the function returns a 'Unauthorized' response by using `return shelf.Response.forbidden('Unauthorized');`.

        If no exception is thrown, it means that the token is valid. The function then proceeds with the request processing and returns a 'Authorized' response.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:jaguar_jwt/jaguar_jwt.dart';

        shelf.Response handleRequest(shelf.Request request) {
          final String authHeader = request.headers['Authorization'];
          if (authHeader != null && authHeader.startsWith('Bearer ')) {
            final String token = authHeader.substring(7);
            if (token != null && token.isNotEmpty) {
              try {
                final decClaimSet = verifyJwtHS256Signature(token, 'yourSecret');
                if (decClaimSet != null) {
                  return shelf.Response.ok('Authorized');
                }
              } on JwtException catch (e) {
                return shelf.Response.forbidden('Unauthorized');
              }
            }
          }
          return shelf.Response.forbidden('Unauthorized');
        }
    steps:
    - First, ensure that the JWT token is not null or empty before proceeding with
      any operations.
    - Next, validate the JWT token's signature. This can be done by using a secret
      key that only the server knows. The 'verifyJwtHS256Signature' function should
      throw an exception if the signature is invalid.
    - Handle the exception thrown by 'verifyJwtHS256Signature' function. If an exception
      is thrown, it means that the token is invalid. In this case, return a 'Unauthorized'
      response.
    - If no exception is thrown, it means that the token is valid. Proceed with the
      request processing.
  title: Lack of data validation - Token
  vulnerability_id: '353'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and interacting with data storage in Node.js applications
  need: Enforce file upload limits and implement proper file management
  solution:
    insecure_code_example:
      description: |-
        In the above Dart code, we have a simple server that is built using the `shelf` framework. The server listens on `localhost` and port `8080`.

        The `_echoRequest` function is used as the handler for all incoming requests. This function checks if the request method is `POST`, and if it is, it returns a `200 OK` response, indicating that the file has been uploaded successfully.

        However, this code is vulnerable to insecure file upload attacks because it does not limit the number of files that can be uploaded to the server. There is no mechanism in place to delete the previous file from the server when a new one is uploaded. This can lead to a server being overwhelmed with files, potentially filling up storage space and causing a denial of service. It could also potentially allow an attacker to upload malicious files to the server.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          if (request.method == 'POST') {
            return shelf.Response.ok('File uploaded');
          }
          return shelf.Response.notFound('Not Found');
        }
    language: dart
    secure_code_example:
      description: |-
        The code above is a Dart server application using the Shelf framework. It includes a middleware function `_checkUploadLimit` that checks if a user has exceeded the upload limit before the request is handled by the `_echoRequest` function.

        The `_checkUploadLimit` middleware function is added to the pipeline before the `_echoRequest` handler. This function checks if the request method is 'POST' (indicating a file upload), and if so, it checks the number of uploads for the user. If the user has reached the upload limit (in this case, 5 uploads), it responds with a 429 status code (Too Many Requests) and a message indicating that the upload limit has been reached. If the user has not reached the upload limit, it increments the number of uploads for the user and sets a timer to decrement the number of uploads after 10 minutes.

        The `_echoRequest` function handles the request after it has passed through the middleware. If the request method is 'POST', it responds with a message indicating that the file has been uploaded. If the request method is not 'POST', it responds with a 404 status code (Not Found).

        This code helps to prevent the server from being overwhelmed by too many file uploads from a single user. It also helps to prevent the server from filling up with old and unnecessary files by automatically decrementing the number of uploads for a user after a certain period of time.
      text: |-
        import 'dart:async';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        // Define a map to store the number of uploads per user
        Map<String, int> userUploads = {};

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(_checkUploadLimit)
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        // Middleware to check the upload limit
        shelf.Middleware _checkUploadLimit() {
          return (shelf.Handler innerHandler) {
            return (shelf.Request request) async {
              if (request.method == 'POST') {
                final user = request.headers['user'];
                if (userUploads[user] >= 5) {
                  return shelf.Response(429, body: 'Upload limit reached');
                }
                userUploads[user] = (userUploads[user] ?? 0) + 1;
                Timer(Duration(minutes: 10), () => userUploads[user]--);
              }
              return innerHandler(request);
            };
          };
        }

        shelf.Response _echoRequest(shelf.Request request) {
          if (request.method == 'POST') {
            return shelf.Response.ok('File uploaded');
          }
          return shelf.Response.notFound('Not Found');
        }
    steps:
    - 'Implement a file upload limit: You need to add a mechanism to limit the number
      of files a user can upload within a certain time frame. This can be done by
      keeping track of the number of files uploaded by each user and when they were
      uploaded.'
    - 'Delete old files: To prevent the server from being filled with old and unnecessary
      files, you should implement a system that automatically deletes files after
      a certain period of time or when a new file is uploaded.'
    - 'Use middleware: Middleware can be used to handle the file upload limit and
      deletion of old files. This can be done in the ''shelf'' package by adding a
      middleware function to the pipeline that handles these tasks before the request
      reaches the handler function.'
    - 'Handle exceptions: Make sure to handle exceptions properly. If a user tries
      to upload more files than allowed, the server should respond with an appropriate
      error message. Similarly, if there''s an error while deleting old files, the
      server should handle it gracefully.'
  title: Insecure file upload - Files Limit
  vulnerability_id: '354'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Ensure proper data authenticity validation and checksum verification
  solution:
    insecure_code_example:
      description: |-
        In the above code snippet, we are making a GET request to an external server to retrieve some data using the `http.Client().get()` method. The data retrieved from the external server is directly used in the application by assigning it to the `data` variable.

        The vulnerability here is that the integrity of the data loaded from the external server is not validated. This means an attacker could potentially modify the data in transit, leading to the application processing incorrect, potentially harmful data. This is because there is no checksum verification in place to ensure the data has not been tampered with during transmission.

        A checksum verification would involve generating a checksum of the original data on the server side and sending this checksum along with the data. On the client side (in this case, our application), the checksum of the received data would be calculated and compared with the received checksum. If they match, the data has not been tampered with. If they do not match, the data integrity is compromised and the data should not be trusted or used.

        The lack of such a checksum verification mechanism in the code makes it vulnerable to attacks that compromise the integrity of the data.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        Future<shelf.Response> handleRequest(shelf.Request request) async {
          var client = http.Client();
          var response = await client.get('https://external-server.com/resource');

          // Load the data from the external server without any checksum verification
          var data = response.body;

          return shelf.Response.ok(data);
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now includes a checksum verification process to validate the integrity of the resources loaded from the external server.

        First, we obtain the original checksum from the server. This is assumed to be provided in the 'checksum' header of the HTTP response.

        Next, we calculate the checksum of the downloaded resource. We use the SHA-256 algorithm for this, which is a common choice for checksum calculations. The `crypto` package's `sha256` function is used to calculate the checksum. The downloaded data is first encoded into a UTF-8 byte array, which is then passed to the `sha256.convert` function. The result is converted to a string to facilitate comparison with the original checksum.

        Finally, we compare the calculated checksum with the original one. If they match, the resource is valid and we return it in the response. If they don't match, we throw an exception. This indicates that the resource may have been tampered with and should not be used.
      text: |-
        import 'dart:convert';
        import 'package:crypto/crypto.dart';
        import 'package:shelf/shelf.dart' as shelf;

        Future<shelf.Response> handleRequest(shelf.Request request) async {
          var client = http.Client();
          var response = await client.get('https://external-server.com/resource');

          // Load the data from the external server
          var data = response.body;

          // Obtain the original checksum from the server
          var originalChecksum = response.headers['checksum'];

          // Calculate the checksum of the downloaded resource
          var calculatedChecksum = sha256.convert(utf8.encode(data)).toString();

          // Compare the calculated checksum with the original one
          if (calculatedChecksum != originalChecksum) {
            throw Exception('Data integrity check failed. The resource may have been tampered with.');
          }

          return shelf.Response.ok(data);
        }
    steps:
    - First, you need to obtain a checksum for the resource you are downloading. This
      could be provided by the server or calculated after the resource is downloaded.
    - Next, you need to implement a function that can calculate the checksum of the
      downloaded resource. This function should use the same algorithm that was used
      to generate the original checksum.
    - After downloading the resource, you should calculate its checksum using the
      function you implemented.
    - Finally, you should compare the calculated checksum with the original one. If
      they match, the resource is valid and you can proceed. If they don't match,
      the resource may have been tampered with and you should not use it.
  title: Insufficient data authenticity validation - Checksum verification
  vulnerability_id: '355'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data persistence and querying in Node.js applications
  need: Protection of sensitive information in source code
  solution:
    insecure_code_example:
      description: "The above Dart code is a simple server application using the Shelf\
        \ framework. It listens for requests on `localhost:8080` and responds with\
        \ a message containing the requested URL.\n\nHowever, the code contains a\
        \ major security vulnerability: it stores sensitive information directly in\
        \ the source code. The username, password, email, and API key are all stored\
        \ as plain text constants. This is a common mistake, but it is a serious security\
        \ risk. \n\nAnyone who has access to the source code can see these credentials.\
        \ This could be a malicious insider, or someone who gains unauthorized access\
        \ to the source code. They could use these credentials to gain unauthorized\
        \ access to systems, carry out actions on behalf of the user, or leak the\
        \ credentials. \n\nFurthermore, storing credentials in the source code makes\
        \ them hard to change. If you need to change the password or API key, you\
        \ have to change the source code and redeploy the application. \n\nThis is\
        \ a clear violation of the principle of least privilege, which states that\
        \ code (and people) should only have the minimum privileges necessary to perform\
        \ their function. In this case, the code has access to credentials that it\
        \ should not have. \n\nThe credentials should be stored securely, for example\
        \ in environment variables or a secure vault, and accessed through a secure\
        \ method."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var app = shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          shelf.serve(app, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        // Sensitive information
        const String username = 'admin';
        const String password = 'password123';
        const String email = 'admin@example.com';
        const String api_key = '123456789abcdef';
    language: dart
    secure_code_example:
      description: |-
        The original code contained sensitive information such as username, password, email, and API key as hard-coded constants. This is a security vulnerability as it exposes these sensitive details in the source code which could be exploited by malicious users.

        The updated code removes these hard-coded values and instead retrieves them from environment variables. This is a more secure practice as it ensures that these details are not exposed in the source code. The `Platform.environment` in Dart is used to access these environment variables.

        To use this updated code, you would need to set the environment variables `USERNAME`, `PASSWORD`, `EMAIL`, and `API_KEY` in the environment where your Dart code is running.

        This change helps to protect the sensitive information from being exposed in the source code. However, it is also recommended to use a secret management system or service for storing and managing sensitive information, and to ensure that the sensitive information is encrypted when at rest and in transit.

        Additionally, proper error handling should be implemented so that no sensitive information is leaked in error messages or logs.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var app = shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

          shelf.serve(app, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }

        // Sensitive information
        final String username = Platform.environment['USERNAME'];
        final String password = Platform.environment['PASSWORD'];
        final String email = Platform.environment['EMAIL'];
        final String api_key = Platform.environment['API_KEY'];
    steps:
    - Remove the hard-coded sensitive information from the source code.
    - Store sensitive information in environment variables or a secure configuration
      file that is not included in the version control system.
    - Use a secure method to access these environment variables or configuration files
      in your code.
    - Consider using a secret management system or service for storing and managing
      sensitive information.
    - Ensure that the sensitive information is encrypted when at rest and in transit.
    - Implement proper error handling so that no sensitive information is leaked in
      error messages or logs.
  title: Sensitive information in source code - Credentials
  vulnerability_id: '359'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Implementation of a secure and robust authentication mechanism
  solution:
    insecure_code_example:
      description: |-
        The `handleRequest` function is a middleware function in the server that handles incoming HTTP requests. It reads the OTP (One-Time Password) from the request headers and verifies it. If the OTP is valid, it sends a response with a success message, otherwise, it sends a forbidden response.

        The vulnerability here is that the function doesn't authenticate the response. This means an attacker can intercept the response and modify it to include the success message, bypassing the OTP validation. This is a type of Response Tampering attack.

        The attacker doesn't need to know the valid OTP. They just need to intercept the response and change the message to 'Success'. The server will then unblock the user, thinking the OTP was valid.

        This vulnerability can lead to unauthorized access and potential data breaches. It's a significant security risk and needs to be fixed.
      text: "import 'package:shelf/shelf.dart' as shelf;\n\nshelf.Response handleRequest(shelf.Request\
        \ request) {\n  var otp = request.headers['otp'];\n  \n  // Assume that verifyOTP\
        \ is a function that checks if the OTP is valid\n  if (verifyOTP(otp)) {\n\
        \    return shelf.Response.ok('Success');\n  } else {\n    return shelf.Response.forbidden('Invalid\
        \ OTP');\n  }\n}"
    language: dart
    secure_code_example:
      description: |-
        The updated code now uses the `shelf_session` package to manage server-side sessions. This package provides middleware for managing sessions using different storage backends. In this case, we're using the in-memory storage backend, which is suitable for development and testing but not for production.

        The server generates a unique session ID for each user after they have been authenticated. The OTP is stored in the server-side session, so it's never exposed to the client-side and cannot be tampered with.

        When the client sends the OTP, the server retrieves the OTP from the session and compares it with the OTP sent by the client. If they match, the server sends a success message and destroys the session, invalidating the OTP. If they don't match, the server sends an error message.

        The communication between the client and the server should be done over HTTPS to ensure that it's encrypted. This will prevent attackers from intercepting and tampering with the messages.

        This solution also implements a mechanism to invalidate the OTP after it has been used, preventing replay attacks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:shelf_session/shelf_session.dart';

        // Assume that verifyOTP is a function that checks if the OTP is valid
        bool verifyOTP(String otp, String sessionOtp) {
          return otp == sessionOtp;
        }

        void main() {
          var sessionMiddleware = sessionMiddlewareMemory();

          var handler = const shelf.Pipeline()
              .addMiddleware(sessionMiddleware)
              .addHandler(_handleRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _handleRequest(shelf.Request request) {
          var session = getSession(request);
          var otp = request.headers['otp'];
          var sessionOtp = session['otp'];

          if (verifyOTP(otp, sessionOtp)) {
            session.destroy();
            return shelf.Response.ok('Success');
          } else {
            return shelf.Response.forbidden('Invalid OTP');
          }
        }
    steps:
    - Implement a secure server-side session management system. The server should
      generate a unique session ID for each user after they have been authenticated.
    - Store the OTP in the server-side session. This way, the OTP is never exposed
      to the client-side and cannot be tampered with.
    - When the client sends the OTP, the server should compare it with the OTP stored
      in the session. If they match, the server should send a success message. If
      they don't match, the server should send an error message.
    - Use HTTPS to ensure that the communication between the client and the server
      is encrypted. This will prevent attackers from intercepting and tampering with
      the messages.
    - Implement a mechanism to invalidate the OTP after a certain period of time or
      after it has been used. This will prevent replay attacks.
  title: Authentication mechanism absence or evasion - Response tampering
  vulnerability_id: '365'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data persistence and querying in Node.js
  need: Secure user deletion process and session management
  solution:
    insecure_code_example:
      description: |-
        In the above code snippet, we have a `UserController` class which has a `deleteUser` method. This method takes a `shelf.Request` object, extracts the `userId` from the request query parameters and removes the user with that id from the `users` map.

        There are two main vulnerabilities in this code:

        1. **Insecure Direct Object References (IDOR)**: The `userId` is directly used from the request without any validation or access control checks. This means any user can delete any other user just by knowing their `userId`. This can lead to unauthorized deletions, making the system inoperative and affecting its integrity to a high degree.

        2. **Session Management**: After the user is deleted, the session is not invalidated. This means the deleted user can still continue to browse the application until their session expires. This is a serious security flaw as it can lead to unauthorized access and actions.

        To fix these vulnerabilities, we need to implement proper access control checks to ensure that only authorized users can delete users. Additionally, we need to invalidate the session of the deleted user to prevent further actions.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class UserController {
          Map<String, User> users = {...};

          shelf.Response deleteUser(shelf.Request request) {
            // Extract the user id from the request
            final userId = request.url.queryParameters['userId'];

            // Delete the user from the map
            users.remove(userId);

            // Return a successful response
            return shelf.Response.ok('User deleted successfully');
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes several security enhancements to address the insecure object reference vulnerability:

        1. **User Existence Check**: Before attempting to delete a user, the code now checks if the user exists in the `users` map. If the user does not exist, the function returns a 404 Not Found response.

        2. **Authorization Check**: The code now checks if the user making the request has the necessary permissions to delete users. This is done by checking the `delete_users` permission on the user object stored in the request context. If the user does not have this permission, the function returns a 403 Forbidden response.

        3. **Session Invalidating**: After deleting a user, the code now invalidates their session by removing it from the `sessions` map. This prevents the deleted user from continuing to browse the application.

        4. **Soft Deletion**: Instead of completely removing the user from the `users` map, the code now implements a soft delete mechanism. The `isDeleted` property of the user object is set to `true`, marking the user as deleted but not actually removing them from the system. This helps maintain system integrity by preserving the user's data and history.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class UserController {
          Map<String, User> users = {...};
          Map<String, Session> sessions = {...};

          shelf.Response deleteUser(shelf.Request request) {
            // Extract the user id from the request
            final userId = request.url.queryParameters['userId'];

            // Check if the user exists
            if (!users.containsKey(userId)) {
              return shelf.Response.notFound('User not found');
            }

            // Check if the user has the necessary permissions to delete users
            if (!request.context['user'].hasPermission('delete_users')) {
              return shelf.Response.forbidden('You do not have permission to delete users');
            }

            // Invalidate the user's session
            sessions.remove(userId);

            // Soft delete the user
            users[userId].isDeleted = true;

            // Return a successful response
            return shelf.Response.ok('User deleted successfully');
          }
        }
    steps:
    - Validate the user ID from the request to ensure it exists in the users map before
      attempting to delete.
    - Implement an authorization check to ensure the user making the request has the
      necessary permissions to delete users.
    - After deleting a user, invalidate their session to prevent them from continuing
      to browse the application.
    - Consider implementing a soft delete mechanism, where users are marked as deleted
      but not actually removed from the system. This can help maintain system integrity.
  title: Insecure object reference - User deletion
  vulnerability_id: '369'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing database models and queries
  - Usage of shelf_io for managing and interacting with data storage in an organized
    manner
  need: Secure transmission of client information
  solution:
    insecure_code_example:
      description: "The above code snippet represents a simple HTTP server set up\
        \ using the Dart `shelf` package. The server listens on `localhost` and on\
        \ port `80`, which is the default port for HTTP. \n\nThe function `_echoRequest`\
        \ is used as the handler for all incoming requests. It simply returns a response\
        \ with the requested URL.\n\nThe vulnerability lies in the use of HTTP protocol\
        \ over port `80`, which does not use encryption. This means that all data\
        \ transmitted between the client and the server is not secured and can be\
        \ intercepted in plain text. This is a serious security risk, especially when\
        \ dealing with sensitive data such as user credentials or confidential information."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 80).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: "The updated code now uses HTTPS instead of HTTP. This is achieved\
        \ by creating a `SecurityContext` and loading the SSL/TLS certificate and\
        \ private key into it. The `SecurityContext` is then passed to the `serve`\
        \ function, which starts the server on port 443, the default port for HTTPS.\n\
        \nThe certificate and private key are loaded from files specified by the paths\
        \ 'path/to/certificate.pem' and 'path/to/private_key.pem'. Replace these with\
        \ the actual paths to your certificate and private key files. If your private\
        \ key is password-protected, replace 'password' with the actual password.\n\
        \nThis change ensures that all communication between the client and the server\
        \ is encrypted, protecting sensitive information from being intercepted in\
        \ transit. \n\nPlease note that you need to obtain a SSL/TLS certificate from\
        \ a Certificate Authority (CA) and install it on your server. The certificate\
        \ not only enables encryption, but also verifies the identity of your website.\
        \ \n\nAfter making these changes, test your implementation to ensure that\
        \ HTTPS is working correctly. You can do this by trying to access your site\
        \ via HTTP and HTTPS. The HTTP version should redirect to HTTPS, and the HTTPS\
        \ version should load without any security warnings."
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          // Load the certificate and private key for the HTTPS server.
          var context = SecurityContext()
            ..useCertificateChain('path/to/certificate.pem')
            ..usePrivateKey('path/to/private_key.pem', password: 'password');

          io.serve(handler, 'localhost', 443, context: context).then((server) {
            print('Serving at https://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Switch from HTTP to HTTPS. HTTPS is a secure version of HTTP. It encrypts all
      communication between your browser and the website, ensuring that all data passed
      between them remains private.
    - To use HTTPS, you need to obtain a SSL/TLS certificate from a Certificate Authority
      (CA). This certificate not only enables encryption, but also verifies the identity
      of your website.
    - Once you have the certificate, install it on your server. The process varies
      depending on your server software.
    - After installing the certificate, modify your server to listen on port 443,
      the default port for HTTPS, instead of port 80.
    - Update your application to redirect HTTP traffic to HTTPS. This ensures that
      even if a user tries to access your site via HTTP, they will be redirected to
      the secure HTTPS version.
    - Finally, test your implementation to ensure that HTTPS is working correctly.
      You can do this by trying to access your site via HTTP and HTTPS. The HTTP version
      should redirect to HTTPS, and the HTTPS version should load without any security
      warnings.
  title: Use of an insecure channel - HTTP
  vulnerability_id: '372'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building scalable and performant applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Encryption of confidential information to ensure data confidentiality
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is a simple server application using the Shelf framework. It defines a single request handler `_echoRequest` which is invoked for every HTTP request received by the server.

        The vulnerability lies in the `_echoRequest` function. This function is converting a string `data` (which is assumed to be confidential information) into a hexadecimal string `hexData` using the `toRadixString(16)` method. This hexadecimal string is then returned in the HTTP response.

        The problem is that this hexadecimal encoding does not provide any form of data protection. Anyone who intercepts this HTTP response can easily decode the hexadecimal string back into the original confidential information. This is because hexadecimal encoding is not a secure method of encryption, it is merely a way of representing binary data in a human-readable format.

        In other words, the server is transmitting confidential information over the network in a format that can be easily decoded by an attacker. This is a clear violation of data confidentiality, one of the key principles of information security.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var data = 'Confidential Information';
          var hexData = data.codeUnits.map((byte) => byte.toRadixString(16)).join();
          return shelf.Response.ok(hexData);
        }
    language: dart
    secure_code_example:
      description: |-
        The code above is a fixed version of the original code that was vulnerable to attacks due to non-encrypted confidential information. The confidential information was being converted to hexadecimal which could be easily decoded to plain text by an attacker.

        To fix this vulnerability, the 'dart:crypto' library was imported to provide encryption functionality. The confidential information is now encrypted using HMAC-SHA256 before being converted to hexadecimal.

        The encryption key is a secure, randomly generated key that is kept secret. In this example, the key is hardcoded as "randomly generated key", but in a real-world application, you should replace this with your own secure key.

        The `Hmac` class from the 'dart:crypto' library is used to create a new HMAC object with the SHA256 hash function and the encryption key. The `convert` method is then used to encrypt the confidential information.

        The encrypted data is then converted to hexadecimal. Now, even if an attacker is able to decode the hexadecimal, they will only see the encrypted data, not the original plain text.

        When the data needs to be read, it should be first converted back from hexadecimal, then decrypted using the same encryption key. This decryption process is not shown in the code above, but would be necessary in a real-world application.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:crypto/crypto.dart';
        import 'dart:convert'; // for the utf8.encode method

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var data = 'Confidential Information';
          var key = utf8.encode("randomly generated key"); // replace with your key
          var bytes = utf8.encode(data);

          var hmacSha256 = new Hmac(sha256, key); // HMAC-SHA256
          var digest = hmacSha256.convert(bytes);

          var hexData = digest.bytes.map((byte) => byte.toRadixString(16)).join();
          return shelf.Response.ok(hexData);
        }
    steps:
    - Import a library that provides encryption functionality, such as 'dart:crypto'.
    - Create an encryption key. This should be a secure, randomly generated key that
      is kept secret.
    - Before converting the confidential information to hexadecimal, encrypt it using
      the encryption key.
    - Now, when the confidential information is converted to hexadecimal, it will
      be the encrypted data that is converted, not the original plain text.
    - When the data needs to be read, it should be first converted back from hexadecimal,
      then decrypted using the same encryption key.
  title: Non-encrypted confidential information - Hexadecimal
  vulnerability_id: '378'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure generation and transmission of OTP tokens
  solution:
    insecure_code_example:
      description: "In the above code, we have a function `handleRequest(shelf.Request\
        \ request)` that handles incoming requests. Inside this function, we extract\
        \ the phone number from the request query parameters and generate an OTP (One-Time\
        \ Password).\n\nThe OTP is generated using the function `generateOTP()`, which\
        \ creates a 6 digit random number. This OTP is then sent back to the client\
        \ in the response.\n\nThe vulnerability lies in the fact that the OTP is generated\
        \ on the server-side and sent to the client-side. This means that if an attacker\
        \ intercepts the request, they can easily access the OTP and continue the\
        \ application flow without needing access to the actual phone number used.\
        \ \n\nThis is a serious security flaw as OTPs are meant to provide a second\
        \ layer of security by requiring users to have access to a specific device\
        \ (in this case, a phone). By allowing the OTP to be intercepted, this layer\
        \ of security is effectively bypassed."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:math';

        shelf.Response handleRequest(shelf.Request request) {
          var params = request.url.queryParameters;
          var phoneNumber = params['phoneNumber'];
          var OTP = generateOTP();

          // Send OTP to client
          return shelf.Response.ok('OTP: $OTP');
        }

        String generateOTP() {
          var rng = new Random();
          return List.generate(6, (_) => rng.nextInt(9)).join();
        }
    language: dart
    secure_code_example:
      description: "The code above fixes the vulnerability by moving the OTP generation\
        \ to the server-side and sending it directly to the user's phone number using\
        \ an SMS gateway service. \n\nThe OTP is generated using the `_generateOTP`\
        \ function, which generates a random 6-digit number. This OTP is then stored\
        \ in a server-side session using the `shelf_session` package. The session\
        \ is associated with the user's request, allowing the OTP to be stored securely\
        \ and associated with the user's session or phone number.\n\nThe OTP is then\
        \ sent to the user's phone number using the `_sendOTP` function. This function\
        \ uses the `sms_maintained` package to send an SMS to the user's phone number\
        \ with the OTP. \n\nThe OTP is not included in the response sent back to the\
        \ client, preventing it from being intercepted. \n\nThis code also sets up\
        \ a session middleware and a session handler using the `shelf` and `shelf_session`\
        \ packages. This allows the server to handle multiple sessions and store session\
        \ data securely.\n\nPlease note that this code does not implement a time limit\
        \ for the OTP, rate limiting, or HTTPS. These features should be implemented\
        \ as well to further secure the OTP process."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'dart:math';
        import 'package:shelf_session/shelf_session.dart';
        import 'package:sms_maintained/sms.dart';

        // Create a session middleware
        var sessionMiddleware = SessionMiddleware(
          SessionConfig(
            sessionKey: 'session',
          ),
        );

        // Create a session handler
        var handler = const shelf.Pipeline()
            .addMiddleware(sessionMiddleware)
            .addHandler(_handleRequest);

        shelf.Response _handleRequest(shelf.Request request) {
          var session = Session.fromRequest(request);
          var params = request.url.queryParameters;
          var phoneNumber = params['phoneNumber'];

          // Generate OTP
          var OTP = _generateOTP();

          // Store OTP in session
          session['OTP'] = OTP;

          // Send OTP to user's phone number
          _sendOTP(phoneNumber, OTP);

          // Do not send OTP in response
          return shelf.Response.ok('OTP sent to your phone number');
        }

        String _generateOTP() {
          var rng = new Random();
          return List.generate(6, (_) => rng.nextInt(9)).join();
        }

        void _sendOTP(String phoneNumber, String OTP) {
          SmsSender sender = new SmsSender();
          SmsMessage message = new SmsMessage(phoneNumber, 'Your OTP is: $OTP');
          sender.sendSms(message);
        }
    steps:
    - Move the OTP generation to the server-side. This way, the OTP is not exposed
      to the client-side where it can be intercepted.
    - Ensure the OTP is sent directly to the user's phone number, not returned in
      the response. This can be done using an SMS gateway service.
    - Implement secure communication between the client and the server. Use HTTPS
      to encrypt the data in transit and prevent it from being intercepted.
    - Store the OTP in a secure server-side session, associated with the user's session
      or phone number. This way, when the user submits the OTP, you can compare it
      with the stored value.
    - Implement a time limit for the OTP. After the limit, the OTP should expire and
      a new one should be generated for the next request. This prevents an attacker
      from using an old OTP.
    - Consider adding rate limiting to prevent brute force attacks. This could limit
      the number of OTP requests from a single IP address or phone number.
  title: Insecurely generated token - OTP
  vulnerability_id: '383'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of lib.dart for implementing Dart libraries and modules
  need: Enforce explicit export of functions in libraries
  solution:
    insecure_code_example:
      description: "The `lib.dart` file defines a library named `lib` and it includes\
        \ three functions: `function1`, `function2`, and `function3`. \n\nIn `main.dart`,\
        \ the wildcard operator (*) is used to import all functions from `lib.dart`.\
        \ This is a bad practice because it can lead to name clashes if there are\
        \ functions with the same name in different libraries. It also makes it harder\
        \ to track which functions are being used from the `lib.dart` file. It can\
        \ lead to unnecessary imports if not all functions are used, which can increase\
        \ the size of the final compiled code. \n\nMoreover, the wildcard import makes\
        \ it harder to understand which functions are coming from which libraries,\
        \ especially in a large codebase with many libraries. This can make the code\
        \ harder to read and maintain. \n\nTherefore, it is better to explicitly import\
        \ only the functions that are needed. This not only avoids potential name\
        \ clashes and unnecessary imports, but also makes the code easier to understand\
        \ and maintain."
      text: |-
        // lib.dart
        library lib;

        void function1() {
          print('Function 1');
        }

        void function2() {
          print('Function 2');
        }

        void function3() {
          print('Function 3');
        }

        // main.dart
        import 'lib.dart' show *;

        void main() {
          function1();
          function2();
          function3();
        }
    language: dart
    secure_code_example:
      description: |-
        The original code was vulnerable due to the use of the wildcard operator (*) in the import statement. This operator was used to import all functions from the 'lib.dart' library, which is a bad practice as it can lead to complications in the use and maintenance of the module.

        The fixed code no longer uses the wildcard operator. Instead, it explicitly imports only the functions that are required, which in this case are `function1`, `function2`, and `function3`. This is done using the `show` keyword followed by the specific function names separated by commas.

        This change makes the code safer and easier to maintain, as it's now clear which functions are being imported from the library. It also reduces the risk of naming conflicts and makes the code easier to read and understand.

        Remember to update the rest of your code to reflect these changes if necessary. For example, if you were using a function from the library that you have now stopped importing, you will need to either start importing that function or remove the code that uses it.
      text: |-
        // lib.dart
        library lib;

        void function1() {
          print('Function 1');
        }

        void function2() {
          print('Function 2');
        }

        void function3() {
          print('Function 3');
        }

        // main.dart
        import 'lib.dart' show function1, function2, function3;

        void main() {
          function1();
          function2();
          function3();
        }
    steps:
    - Identify the specific functions that are needed from the library in your code.
    - Instead of using the wildcard operator (*), explicitly import only those functions
      that are required.
    - Remove the wildcard operator (*) from the import statement.
    - Replace it with the specific function names separated by commas.
    - Ensure that the rest of your code is updated to reflect these changes, if necessary.
  title: Inappropriate coding practices - Wildcard export
  vulnerability_id: '384'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for building high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Encryption of confidential information
  solution:
    insecure_code_example:
      description: "In the above code, we have a simple server application using the\
        \ Shelf framework in Dart. The function `_echoRequest` handles all the incoming\
        \ requests. \n\nThe vulnerability lies in the line where we have the `apiKey`\
        \ variable. This variable is storing a very sensitive piece of information\
        \ - an API key. This key is stored in plain text, meaning it's not encrypted\
        \ or hashed in any way. \n\nAnyone who has access to the source code, either\
        \ through a repository or by gaining unauthorized access to the server, can\
        \ easily view this API key. Once they have this key, they can potentially\
        \ use it to make requests to the API, leading to data breaches or other security\
        \ issues.\n\nThis is a serious security vulnerability, as sensitive data like\
        \ API keys should never be stored in plain text. Instead, they should be encrypted\
        \ or hashed, and ideally stored in a secure environment variable or a dedicated\
        \ secure vault."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var apiKey = 'my_super_secret_api_key'; // Confidential information stored in plain text
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The original code had a vulnerability where the API key was stored in plain text within the code. This is a security risk as it exposes the key to anyone who has access to the code, and it could potentially be leaked in version control history or logs.

        The updated code fixes this vulnerability by storing the API key in an environment variable instead. The `Platform.environment` method is used to access the value of the environment variable named 'API_KEY'. This way, the API key is not exposed in the code and can be securely managed outside of the application.

        To set the environment variable, you can use the following command in the terminal before running your Dart application:

        ```bash
        export API_KEY=your_api_key
        ```

        Remember to replace `your_api_key` with your actual API key.

        This method of storing sensitive information is more secure, but it's still not perfect. For even better security, consider using a secure key vault service, which can securely store and manage secrets like API keys, and provide them to your application as needed.

        Also, ensure that the environment variable or key vault is properly secured and only accessible to authorized individuals or services.
      text: |-
        import 'dart:io';
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          shelf.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          var apiKey = Platform.environment['API_KEY']; // Accessing the API key from environment variable
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Remove the hard-coded API key from the code.
    - Store the API key in an environment variable or a secure key vault.
    - Access the API key in your code through the environment variable or key vault.
    - Ensure that the environment variable or key vault is properly secured and only
      accessible to authorized individuals or services.
  title: Non-encrypted confidential information - Keys
  vulnerability_id: '385'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Secure object reutilization management
  solution:
    insecure_code_example:
      description: "In the code snippet above, we have a Singleton class `SingletonObject`\
        \ that reuses the same instance for every request coming to the `handleRequest`\
        \ function. This can lead to severe security issues like data leakage between\
        \ different users' sessions if the singleton object stores any user-specific\
        \ data.\n\nThe Singleton design pattern is meant to ensure that a class has\
        \ only one instance, and provide a global point of access to it. However,\
        \ in a multi-user environment like a web server, this can create problems\
        \ if not handled correctly. For example, if the Singleton class is used to\
        \ store user-related data, then that data will be shared among all users,\
        \ leading to data leakage.\n\nThe `handleRequest` function uses the `SingletonObject`\
        \ instance to perform some operations. Since the same instance is reused for\
        \ every request, if the instance stores any state that is specific to a request,\
        \ that state will be shared among all requests, which can lead to data leakage\
        \ and other security issues. \n\nThis is a classic case of insecure service\
        \ configuration - Object Reutilization vulnerability. The system does not\
        \ validate that objects, data or information, valid for one use only can be\
        \ reused."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class SingletonObject {
          static SingletonObject _instance;

          SingletonObject._internal();

          static SingletonObject getInstance() {
            if (_instance == null) {
              _instance = new SingletonObject._internal();
            }
            return _instance;
          }
        }

        void handleRequest(shelf.Request request) {
          SingletonObject instance = SingletonObject.getInstance();
          // perform operations using the instance
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    language: dart
    secure_code_example:
      description: |-
        The code above fixes the vulnerability by introducing a mechanism to invalidate the SingletonObject instance after its use. This is done by adding a method `invalidateInstance` in the SingletonObject class that sets the `_instance` to null.

        In the `handleRequest` function, after performing operations using the instance, the `invalidateInstance` method is called to invalidate the SingletonObject instance. This ensures that the SingletonObject instance is invalidated after each request.

        A `validateInstance` method is also added to the SingletonObject class to check if the SingletonObject instance is being used after it has been invalidated. This method is called before performing operations using the instance in the `handleRequest` function. If the SingletonObject instance has been invalidated (i.e., `_instance` is null), an exception is thrown. This prevents the reuse of invalidated objects, data, or information, thereby fixing the vulnerability.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class SingletonObject {
          static SingletonObject _instance;

          SingletonObject._internal();

          static SingletonObject getInstance() {
            if (_instance == null) {
              _instance = new SingletonObject._internal();
            }
            return _instance;
          }

          static void invalidateInstance() {
            _instance = null;
          }

          void validateInstance() {
            if (_instance == null) {
              throw Exception('Instance has been invalidated');
            }
          }
        }

        void handleRequest(shelf.Request request) {
          SingletonObject instance = SingletonObject.getInstance();
          instance.validateInstance();
          // perform operations using the instance
          SingletonObject.invalidateInstance();
        }

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(handleRequest);

          shelf.serve(handler, 'localhost', 8080).then((server) {
            print('Serving at http://${server.address.host}:${server.port}');
          });
        }
    steps:
    - Introduce a mechanism to invalidate the SingletonObject instance after its use.
      This can be done by adding a method in the SingletonObject class that sets the
      _instance to null.
    - Ensure that the SingletonObject instance is invalidated after each request in
      the handleRequest function. Call the invalidation method after the operations
      using the instance are performed.
    - Add checks to ensure that the SingletonObject instance is not being used after
      it has been invalidated. This can be done by throwing an exception if methods
      are called on an invalidated instance.
  title: Insecure service configuration - Object Reutilization
  vulnerability_id: '387'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  need: Elimination of unused properties in the codebase
  solution:
    insecure_code_example:
      description: "In the above Dart code, we have a class `UnusedProperties` that\
        \ defines two properties: `unusedString` and `unusedInt`. These properties\
        \ are initialized through the class constructor but are not used anywhere\
        \ in the class methods or elsewhere in the code. \n\nThis is an example of\
        \ inappropriate coding practices where unused properties are defined. These\
        \ unused properties add unnecessary complexity to the source code and can\
        \ lead to a suboptimal state that may affect the overall application performance.\
        \ \n\nIn the worst-case scenario, these unused properties could consume memory\
        \ and other system resources, slowing down the application and causing a poor\
        \ user experience. Furthermore, it makes the code harder to read and maintain,\
        \ as other developers may spend time trying to understand why these properties\
        \ are defined and where they are used. \n\nTherefore, it is recommended to\
        \ remove any unused properties to improve the code quality and performance\
        \ of your application."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class UnusedProperties {
          final String unusedString;
          final int unusedInt;

          UnusedProperties(this.unusedString, this.unusedInt);

          shelf.Response handleRequest(shelf.Request request) {
            return shelf.Response.ok('Hello, World!');
          }
        }
    language: dart
    secure_code_example:
      description: "The original code had two properties, `unusedString` and `unusedInt`,\
        \ that were defined but not used anywhere in the class. This is considered\
        \ a bad coding practice as it adds unnecessary complexity to the code and\
        \ can potentially affect the performance of the application.\n\nTo fix this\
        \ vulnerability, the unused properties were removed from the class definition.\
        \ This included removing them from the class constructor as well. \n\nThe\
        \ `UnusedProperties` class now only contains the `handleRequest` method, which\
        \ is responsible for handling requests. The class is now simpler and more\
        \ efficient, as it does not contain any unused properties.\n\nAfter making\
        \ these changes, it's important to test the application to ensure that it\
        \ still works as expected. If the unused properties were referenced elsewhere\
        \ in the code, those references would need to be removed or modified. However,\
        \ in this case, the properties were not used anywhere else, so no further\
        \ changes were necessary."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        class UnusedProperties {

          UnusedProperties();

          shelf.Response handleRequest(shelf.Request request) {
            return shelf.Response.ok('Hello, World!');
          }
        }
    steps:
    - Identify the unused properties in the class. In this case, 'unusedString' and
      'unusedInt' are the unused properties.
    - Remove the unused properties from the class definition. This includes removing
      them from the class constructor as well.
    - Ensure that the removal of these properties does not affect other parts of the
      code. If these properties are referenced elsewhere, you will need to remove
      or modify those references.
    - Test the application to ensure that it still works as expected after the removal
      of the unused properties.
  title: Inappropriate coding practices - Unused properties
  vulnerability_id: '391'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance, cross-platform applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and organizing data storage in Node.js
  - Usage of shelf_router for routing and request handling in a Shelf-based web application
  - Usage of shelf_static for serving static files with Shelf framework
  need: Mitigation of known vulnerabilities in software and dependencies used in development
  solution:
    insecure_code_example:
      description: "The above code demonstrates a Dart backend application using the\
        \ Shelf framework. The application is set up to serve static files from a\
        \ 'public' directory. \n\nThe vulnerability lies in the use of a version of\
        \ the `shelf_static` package that is known to have security issues. The `createStaticHandler`\
        \ function from `shelf_static` is used to serve static files. If the version\
        \ of `shelf_static` used in this code contains known vulnerabilities, it can\
        \ expose the application to potential security risks. \n\nFor instance, a\
        \ known vulnerability in a specific version might allow unauthorized file\
        \ access, path traversal, or remote code execution. By continuing to use this\
        \ version in a pre-production environment, you run the risk of these vulnerabilities\
        \ being exploited, leading to potential data leakage, system compromise, or\
        \ other security incidents. \n\nIt is crucial to always use the latest and\
        \ most secure versions of all dependencies and to regularly check for and\
        \ apply updates. This includes not only the direct dependencies you use in\
        \ your code, but also any indirect dependencies they may rely on."
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart'\
        \ as io;\nimport 'package:shelf_router/shelf_router.dart';\nimport 'package:shelf_static/shelf_static.dart';\n\
        \nvoid main() {\n  var app = Router();\n\n  // Known vulnerable package version\n\
        \  var handler = createStaticHandler('public', \n    defaultDocument: 'index.html',\
        \ \n    listDirectories: true);\n\n  app.mount('/', handler);\n\n  var server\
        \ = io.serve(app, 'localhost', 8080);\n  server.then((value) => print('Server\
        \ started on port ${value.port}'));\n}"
    language: dart
    secure_code_example:
      description: |-
        The original code was using a known vulnerable version of the 'shelf_static' package. This package is used to serve static files in a Dart backend application using the Shelf framework.

        The vulnerability was fixed by updating the 'shelf_static' package to the latest stable version that has addressed the known vulnerabilities. This was done by updating the version number in the 'pubspec.yaml' file and running 'pub get' to fetch the updated package.

        After updating the package, the application was tested to ensure it still works as expected. This was done by running the application's test suite, if one exists, or manually testing the application's functionality.

        To prevent similar vulnerabilities in the future, it's recommended to regularly check for updates to the software or dependencies used in the project. This can be done by subscribing to security mailing lists, using automated dependency checkers, or regularly visiting the official documentation or package pages.
      text: "import 'package:shelf/shelf.dart' as shelf;\nimport 'package:shelf/shelf_io.dart'\
        \ as io;\nimport 'package:shelf_router/shelf_router.dart';\nimport 'package:shelf_static/shelf_static.dart';\n\
        \nvoid main() {\n  var app = Router();\n\n  // Updated package version\n \
        \ var handler = createStaticHandler('public', \n    defaultDocument: 'index.html',\
        \ \n    listDirectories: true);\n\n  app.mount('/', handler);\n\n  var server\
        \ = io.serve(app, 'localhost', 8080);\n  server.then((value) => print('Server\
        \ started on port ${value.port}'));\n}"
    steps:
    - Identify the software or dependencies with known vulnerabilities. In this case,
      it's the 'shelf_static' package.
    - Check the version of the vulnerable software or dependency being used. This
      can be found in the 'pubspec.yaml' file in Dart projects.
    - Research the latest stable version of the software or dependency that has addressed
      the known vulnerabilities. This can be done by checking the official documentation
      or the package's page on pub.dev.
    - Update the vulnerable software or dependency to the latest stable version that
      has fixed the known vulnerabilities. This is done by updating the version number
      in the 'pubspec.yaml' file and running 'pub get' to fetch the updated package.
    - Test the application after updating the software or dependency to ensure it
      still works as expected. This can be done by running the application's test
      suite, if one exists, or manually testing the application's functionality.
    - Regularly check for updates to the software or dependencies used in the project.
      This can be done by subscribing to security mailing lists, using automated dependency
      checkers, or regularly visiting the official documentation or package pages.
  title: Use of software with known vulnerabilities in development
  vulnerability_id: '393'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.0 for developing high-performance, cross-platform applications
  - Usage of crypto for cryptographic operations
  need: Secure generation of random numbers and dynamic initialization vectors
  solution:
    insecure_code_example:
      description: "The above code is an encryption service in a Dart backend application.\
        \ It uses the AES/CBC/PKCS7 cipher for encryption and decryption. \n\nThe\
        \ vulnerability here is that the initialization vector (IV) is hardcoded and\
        \ static. The IV is supposed to be random and unique for each encryption operation.\
        \ If an attacker knows the IV, they could potentially reverse engineer the\
        \ encryption process to predict the random values that should remain as secrets.\n\
        \nIn the `encrypt` and `decrypt` functions, the IV is set to a static, hard-coded\
        \ value `1234567890123456`. This means that every time data is encrypted,\
        \ the same IV is used. This makes the encryption predictable and susceptible\
        \ to reverse engineering attacks.\n\nThe key is also hard-coded and static,\
        \ which is another security vulnerability, but that's not the focus of this\
        \ context.\n\nBy using a static, hard-coded IV, the application is not securely\
        \ generating random numbers, which is a serious security vulnerability."
      text: |-
        import 'dart:convert';
        import 'dart:typed_data';
        import 'package:crypto/crypto.dart';

        class EncryptionService {
          static final key = utf8.encode('12345678901234567890123456789012');
          static final iv = utf8.encode('1234567890123456');

          static String encrypt(String plaintext) {
            final c = Cipher('AES/CBC/PKCS7');
            final encrypter = Encrypter(c);
            final encrypted = encrypter.encrypt(plaintext, iv: IV.fromUtf8(iv));
            return encrypted.base64;
          }

          static String decrypt(String encryptedText) {
            final c = Cipher('AES/CBC/PKCS7');
            final encrypter = Encrypter(c);
            final decrypted = encrypter.decrypt64(encryptedText, iv: IV.fromUtf8(iv));
            return decrypted;
          }
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now generates a new, unique initialization vector (IV) each time a message is encrypted. This is done in the `_generateRandomIV` function, which uses Dart's `Random.secure()` function to generate a secure random number for each byte of the IV.

        The `encrypt` function has been updated to generate a new IV each time it is called. This IV is then used to encrypt the plaintext message. The encrypted message is then concatenated with the IV (after both have been base64 encoded) to form the final encrypted string. This ensures that the IV is stored alongside the encrypted data, allowing it to be retrieved when the data needs to be decrypted.

        The `decrypt` function has also been updated to retrieve the IV from the encrypted string before attempting to decrypt it. It does this by first base64 decoding the first 24 characters of the string (which represent the IV), and then removing these characters from the string to leave just the encrypted message. The IV and encrypted message are then used to decrypt the original plaintext message.

        This approach ensures that a unique IV is used for each encryption operation, preventing an attacker from being able to predict the IV and reverse engineer the encryption.
      text: |-
        import 'dart:convert';
        import 'dart:typed_data';
        import 'dart:math';
        import 'package:crypto/crypto.dart';

        class EncryptionService {
          static final key = utf8.encode('12345678901234567890123456789012');

          static String encrypt(String plaintext) {
            final c = Cipher('AES/CBC/PKCS7');
            final encrypter = Encrypter(c);
            final iv = _generateRandomIV();
            final encrypted = encrypter.encrypt(plaintext, iv: IV.fromUtf8(iv));
            return base64.encode(iv) + encrypted.base64;
          }

          static String decrypt(String encryptedText) {
            final c = Cipher('AES/CBC/PKCS7');
            final encrypter = Encrypter(c);
            final iv = base64.decode(encryptedText.substring(0, 24));
            final realEncryptedText = encryptedText.substring(24);
            final decrypted = encrypter.decrypt64(realEncryptedText, iv: IV.fromUtf8(iv));
            return decrypted;
          }

          static Uint8List _generateRandomIV() {
            final random = Random.secure();
            final iv = List<int>.generate(16, (i) => random.nextInt(256));
            return Uint8List.fromList(iv);
          }
        }
    steps:
    - Replace the static, hardcoded initialization vector (IV) with a dynamically
      generated one. This can be achieved by using a secure random number generator.
    - Ensure that a new, unique IV is generated each time a message is encrypted.
      This prevents an attacker from being able to predict the IV and reverse engineer
      the encryption.
    - Store the IV alongside the encrypted data. Since the IV does not need to be
      kept secret (unlike the key), it can be safely stored with the encrypted data.
      This allows the correct IV to be used when decrypting the data.
    - Update the decrypt function to retrieve the IV from the encrypted data before
      attempting to decrypt it.
  title: Insecure generation of random numbers -  Static IV
  vulnerability_id: '395'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of the http module for creating and handling HTTP servers
  need: Ensuring secure and accurate dependency management
  solution:
    insecure_code_example:
      description: "The Dart code above represents a basic backend application using\
        \ the shelf framework. The application listens to the localhost on port 8080\
        \ and responds with a simple message for each request it receives.\n\nThe\
        \ vulnerability in this code is not in the Dart code itself, but in the `pubspec.yaml`\
        \ file, which is used to manage Dart packages. \n\nThe dependencies section\
        \ of the file is set to use any version of the `shelf` and `http` packages.\
        \ This is a classic example of Dependency Confusion vulnerability. By not\
        \ specifying a particular version for these packages, an attacker could potentially\
        \ publish a malicious version of these packages and trick the package manager\
        \ into installing it. \n\nThis could lead to the execution of harmful code\
        \ when the application is run, as the malicious package could contain any\
        \ code that the attacker chooses. This increases the possible attack vectors\
        \ on the application. \n\nTo fix this vulnerability, it is recommended to\
        \ always specify the exact version of the dependencies to be used. This way,\
        \ the package manager will not be confused and will always install the correct\
        \ and safe version of the packages."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:http/http.dart' as http;

        void main() {
            var app = shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

            io.serve(app, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
            return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The above code is a simple backend application written in Dart using the Shelf framework. It imports three packages: 'shelf', 'shelf_io', and 'http'. The application creates a server that listens on localhost at port 8080 and responds with a message containing the requested URL.

        However, the code is vulnerable to a Dependency Confusion attack. This is because it does not specify the exact versions of the dependencies it requires. This can lead to ambiguity and confusion for the package manager, potentially allowing an attacker to execute harmful code by confusing the package manager into installing or updating the wrong versions of the dependencies.

        To fix this vulnerability, the exact versions of the dependencies should be specified in the 'pubspec.yaml' file of the project. This file is used by Dart's package manager to manage the project's dependencies. Here is an example of how to specify the exact versions of the dependencies:

        ```yaml
        name: my_project
        description: A simple backend application

        environment:
          sdk: '>=2.12.0 <3.0.0'

        dependencies:
          shelf: ^1.1.5
          shelf_io: ^1.1.5
          http: ^0.13.3
        ```

        In this example, the '^' symbol before the version number indicates that the project can use any version that is compatible with the specified version. This still allows for some flexibility in the versions of the dependencies that can be used, while also ensuring that the package manager does not get confused and install or update to an incorrect or insecure version.

        In addition to specifying the exact versions of the dependencies, it is also recommended to use a private package repository if possible, to regularly update the dependencies to their latest secure versions, and to use dependency checking tools or services to automatically check for potential security vulnerabilities in the project's dependencies.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;
        import 'package:http/http.dart' as http;

        void main() {
            var app = shelf.Pipeline().addMiddleware(shelf.logRequests()).addHandler(_echoRequest);

            io.serve(app, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
            return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Identify all the dependencies used in your project. In this case, the dependencies
      are 'shelf', 'shelf_io', and 'http'.
    - Ensure that the dependencies are correctly defined in your project's package
      manager file. For Dart, this would be the 'pubspec.yaml' file.
    - Specify the exact versions of the dependencies that your project requires. Avoid
      using version ranges or the latest version tag to prevent the package manager
      from getting confused.
    - Use a private package repository if possible. This can prevent an attacker from
      injecting malicious code into your project through a public repository.
    - Regularly update your dependencies to their latest secure versions. This can
      help to prevent dependency confusion attacks by ensuring that your project is
      not relying on outdated or insecure versions of dependencies.
    - Consider using dependency checking tools or services that can automatically
      check for and alert you to any potential security vulnerabilities in your project's
      dependencies.
  title: Dependency Confusion
  vulnerability_id: '410'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for ORM (Object-Relational Mapping) in Node.js
  need: Secure service configuration - Enable Header Checking
  solution:
    insecure_code_example:
      description: "The above Dart code represents a simple server application using\
        \ the Shelf framework. The server listens on localhost and port 8080 and responds\
        \ with a simple message for every request it receives.\n\nHowever, this code\
        \ is vulnerable to HTTP header injection attacks. This is because it doesn't\
        \ perform any kind of header checking or sanitization on incoming requests.\
        \ \n\nThe `_echoRequest` function, which handles all incoming requests, simply\
        \ returns a response with the requested URL. It doesn't check if the URL or\
        \ any other part of the request contains malicious headers.\n\nAn attacker\
        \ can exploit this vulnerability by sending a request with malicious headers.\
        \ Since these headers aren't sanitized or checked in any way, they can cause\
        \ various kinds of damage, such as cross-site scripting (XSS) attacks, HTTP\
        \ response splitting attacks, and others."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code includes a middleware function `_sanitizeHeaders` that sanitizes all incoming request headers. This function is added to the pipeline before the request handler.

        The `_sanitizeHeaders` function returns a new middleware that wraps around the inner handler. This middleware creates a new request with sanitized headers and passes it to the inner handler.

        The sanitization process is done in the `_sanitize` function. This function takes the headers map from the request, and for each key-value pair, it replaces any newline (`\\n`) or carriage return (`\\r`) characters in the value with an empty string. This effectively removes these characters from the headers, preventing header injection attacks.

        This solution ensures that all incoming requests are properly sanitized and validated, which includes checking for any unexpected or malicious characters in the headers. It also implements a strict content security policy, which helps to mitigate the risk of header injection attacks by specifying the sources from which valid content can be loaded. Regular updates and patches to your server software are also recommended to protect against known vulnerabilities that could be exploited through header injection.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;

        void main() {
          var handler = const shelf.Pipeline()
              .addMiddleware(shelf.logRequests())
              .addMiddleware(_sanitizeHeaders)
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Middleware _sanitizeHeaders() {
          return (shelf.Handler innerHandler) {
            return (shelf.Request request) async {
              var sanitizedHeaders = _sanitize(request.headers);
              var sanitizedRequest = request.change(headers: sanitizedHeaders);
              return await innerHandler(sanitizedRequest);
            };
          };
        }

        Map<String, String> _sanitize(Map<String, String> headers) {
          return headers.map((key, value) => MapEntry(key, value.replaceAll(RegExp(r'[\\n\\r]'), '')));
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Enable the HeaderChecking property in your application. This will ensure that
      newlines and carriage returns are properly encoded, preventing the injection
      of malicious headers.
    - Ensure that all incoming requests are properly sanitized and validated. This
      includes checking for any unexpected or malicious characters in the headers.
    - Implement a strict content security policy. This will help to mitigate the risk
      of header injection attacks by specifying the sources from which valid content
      can be loaded.
    - Regularly update and patch your server software to protect against known vulnerabilities
      that could be exploited through header injection.
    - Consider using a security tool or service that can automatically detect and
      block header injection attacks.
  title: Insecure service configuration - Header Checking
  vulnerability_id: '414'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing data storage and retrieval
  - Usage of shelf_router for creating a router middleware in Shelf framework
  need: Secure password reset functionality
  solution:
    insecure_code_example:
      description: "In the above Dart code, we have a `UserController` class that\
        \ handles user related operations. It uses the `shelf_router` package to define\
        \ routes for the application.\n\nThe `/reset-password` POST endpoint is used\
        \ to generate a password reset link for the user. It reads the email from\
        \ the request, generates a reset link, and sends it to the user's email. \n\
        \nThe vulnerability lies in the generation of the reset link. The domain of\
        \ the reset link is hard-coded as `http://yourapp.com`. An attacker can manipulate\
        \ the request and change the domain to one under his control. \n\nWhen the\
        \ reset link is clicked, the request goes to the attacker's server with the\
        \ reset token and the user's email. This allows the attacker to reset the\
        \ user's password, effectively gaining control over the user's account.\n\n\
        This is a classic example of Password Reset Poisoning where the application\
        \ does not properly validate the reset link's domain."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class UserController {
          Router _router;

          UserController() {
            _router = Router();
            _router.post('/reset-password', (shelf.Request request) async {
              final params = await request.readAsString();
              final email = params['email'];

              // Generate reset link
              final resetLink = 'http://yourapp.com/reset?token=123456&email=$email';

              // Send the reset link to the user's email
              // This is just a placeholder. In a real world scenario, you would use an email service.
              print('Password reset link: $resetLink');

              return shelf.Response.ok('Password reset link sent.');
            });
          }

          shelf.Handler get handler => _router;
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now generates a unique, random token for each password reset request. This token is associated with the user's email on the server side, and is included in the password reset link. The link now uses HTTPS to ensure secure communication.

        The `_generateToken` method generates a random 20-character string to be used as the token. This token is stored in a map along with the user's email.

        When the user clicks on the reset link, the server should validate the token and check if it's expired before allowing the password reset. This validation is not included in the code above, but should be implemented in the route handling the password reset.

        The email is no longer included in the reset link, preventing an attacker from changing the email parameter to one under his control. The token is associated with the user's email on the server side, ensuring that the password reset is performed for the correct user.

        The token should be set to expire after a certain period of time or after it's used to further enhance security. This is not included in the code above, but should be implemented in your application.
      text: |-
        import 'dart:math';
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf_router/shelf_router.dart';

        class UserController {
          Router _router;
          Map<String, String> tokens = {};

          UserController() {
            _router = Router();
            _router.post('/reset-password', (shelf.Request request) async {
              final params = await request.readAsString();
              final email = params['email'];

              // Generate a unique, random token for each password reset request
              final token = _generateToken();

              // Associate the token with the user's email on the server side
              tokens[token] = email;

              // Generate reset link
              final resetLink = 'https://yourapp.com/reset?token=$token';

              // Send the reset link to the user's email
              // This is just a placeholder. In a real world scenario, you would use an email service.
              print('Password reset link: $resetLink');

              return shelf.Response.ok('Password reset link sent.');
            });
          }

          String _generateToken() {
            var rng = Random();
            var codeUnits = List.generate(20, (index){
              return rng.nextInt(33)+89;
            });

            return String.fromCharCodes(codeUnits);
          }

          shelf.Handler get handler => _router;
        }
    steps:
    - Use HTTPS instead of HTTP for the reset link to ensure the communication is
      secure.
    - Do not include the email in the reset link. Instead, associate the token with
      the user's email on the server side.
    - Generate a unique, random token for each password reset request. Do not use
      a static token.
    - Ensure the token expires after a certain period of time or after it's used.
    - Validate the token server-side before allowing the password reset.
  title: Password reset poisoning
  vulnerability_id: '420'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of cryptoutils for cryptographic operations
  need: Implementation of secure elliptic curves for encryption
  solution:
    insecure_code_example:
      description: "The above code is an example of a security vulnerability related\
        \ to the use of weak elliptic curve cryptography. The problem lies in the\
        \ use of the `secp112r1` elliptic curve, which is considered insecure due\
        \ to its small size. \n\nIn the code, we are encrypting some sensitive data\
        \ using the Elliptic Curve Digital Signature Algorithm (ECDSA). The `ECDomainParameters`\
        \ object is created using the `secp112r1` curve. This curve is known to be\
        \ weak and vulnerable to attacks, which means that an attacker could potentially\
        \ decrypt the sensitive data.\n\nThe `PrivateKeyParameter` object is created\
        \ using the private key derived from the weak curve. The signer object is\
        \ then initialized with this weak private key. \n\nFinally, the sensitive\
        \ data is signed using the signer's `generateSignature` method. The resulting\
        \ signature is then printed out.\n\nIn summary, the use of a weak elliptic\
        \ curve (`secp112r1`) in this code makes the encryption of the sensitive data\
        \ insecure. An attacker could exploit this weakness to decrypt the data."
      text: "import 'package:cryptoutils/cryptoutils.dart';\n\nvoid main() {\n  var\
        \ data = \"Sensitive Information\";\n  var privateKey = \"privateKey\";\n\n\
        \  // Using weak elliptic curve - secp112r1\n  var ecdsa = ECDomainParameters('secp112r1');\n\
        \n  var signer = Signer(\"SHA-1/ECDSA\");\n\n  PrivateKeyParameter<ECPrivateKey>\
        \ privateKeyParam = \n    PrivateKeyParameter<ECPrivateKey>(ecdsa.privateKeyFromBigInt(Utils.createUint8ListFromHexString(privateKey)));\n\
        \n  signer.init(true, privateKeyParam);\n\n  ECSignature signature = signer.generateSignature(Uint8List.fromList(data.codeUnits));\n\
        \  print(\"Signature: ${signature.r}, ${signature.s}\");\n}"
    language: dart
    secure_code_example:
      description: |-
        The original code was using a weak elliptic curve 'secp112r1' for encryption, which is not secure. The updated code now uses a stronger elliptic curve 'secp256r1'. This provides a higher level of security and makes it more difficult for attackers to break the encryption.

        The original code was also using the SHA-1 hash function, which is considered insecure due to vulnerabilities that allow for collision attacks. The updated code uses the SHA-256 hash function, which is currently considered secure against all known practical attacks.

        The private key was hardcoded in the original code, which is a security risk as anyone with access to the code would also have access to the private key. The updated code includes a placeholder function `generateSecurePrivateKey()` for generating a secure private key. This function should be implemented to generate a secure private key and store it securely.

        It's important to use libraries or frameworks that provide secure defaults to avoid these types of mistakes. Always keep your libraries up to date and follow best practices for secure coding.
      text: "import 'package:cryptoutils/cryptoutils.dart';\n\nvoid main() {\n  var\
        \ data = \"Sensitive Information\";\n  \n  // Generate a secure private key\n\
        \  var privateKey = generateSecurePrivateKey();\n\n  // Using a stronger elliptic\
        \ curve - secp256r1\n  var ecdsa = ECDomainParameters('secp256r1');\n\n  var\
        \ signer = Signer(\"SHA-256/ECDSA\");\n\n  PrivateKeyParameter<ECPrivateKey>\
        \ privateKeyParam = \n    PrivateKeyParameter<ECPrivateKey>(ecdsa.privateKeyFromBigInt(Utils.createUint8ListFromHexString(privateKey)));\n\
        \n  signer.init(true, privateKeyParam);\n\n  ECSignature signature = signer.generateSignature(Uint8List.fromList(data.codeUnits));\n\
        \  print(\"Signature: ${signature.r}, ${signature.s}\");\n}\n\nUint8List generateSecurePrivateKey()\
        \ {\n  // Implement a secure method to generate a private key\n}"
    steps:
    - Replace the weak elliptic curve 'secp112r1' with a stronger one such as 'secp256r1'.
    - Replace the SHA-1 hash function with a more secure one such as SHA-256 or SHA-3.
    - Ensure that the private key is securely generated and stored, not hardcoded
      in the code.
    - Consider using a library or framework that provides secure defaults to avoid
      these types of mistakes.
  title: Insecure encryption algorithm - Insecure Elliptic Curve
  vulnerability_id: '421'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart 2.12.0 for developing cross-platform applications
  - Usage of Shelf for managing database queries and data modeling
  - Usage of shelf_io for managing and organizing data in a Node.js application
  need: Enforcement of proper file validation and verification
  solution:
    insecure_code_example:
      description: |-
        The above Dart code is a basic backend application that uses the Shelf framework to serve HTTP requests. It has a vulnerability related to inappropriate coding practices specifically related to handling files.

        In the `handler` function, the code reads a file named 'file.txt' synchronously and sends its content as a response to any HTTP request. The vulnerability here is that the file content is read directly and sent without any verification of its content or its extension.

        This is a significant security vulnerability because it allows for potential security risks such as serving malicious content or sensitive information unintentionally. For example, if 'file.txt' was replaced with a file containing malicious scripts or sensitive data, this code would serve that content to any client making a request.

        Moreover, the code assumes that the file 'file.txt' will always be present in the directory where the server is running. If the file does not exist, the server will throw an unhandled exception, and the application will crash.

        To fix this vulnerability, the code should verify the file's content and its extension before reading and serving it. It should also handle the case where the file does not exist gracefully.
      text: |-
        import 'dart:convert';
        import 'dart:io';
        import 'package:shelf/shelf.dart';
        import 'package:shelf/shelf_io.dart' as io;

        void main() async {
          var server = await io.serve(handler, 'localhost', 8080);

          print('Serving at http://${server.address.host}:${server.port}');
        }

        Response handler(Request request) {
          var file = File('file.txt'); // Invalid file
          var content = file.readAsStringSync();

          return Response.ok(content);
        }
    language: dart
    secure_code_example:
      description: |-
        The updated code now checks if the file exists before trying to read it. This is done using the `exists` method of the `File` class in Dart. If the file does not exist, a 404 Not Found response is returned.

        If the file does exist, the code attempts to read the file content as a string using the `readAsString` method, which returns a `Future`. This allows the code to handle any errors that occur during the file reading process in a non-blocking way.

        The code then attempts to parse the file content as JSON, assuming that the file should contain JSON. If the parsing is successful, the file content is returned in the response. If an error occurs during parsing, a 500 Internal Server Error response is returned with a message indicating that the file content is invalid.

        This approach ensures that the file content is compatible with its extension and that any errors that occur during the file reading or parsing process are handled appropriately. It also prevents the server from crashing due to unhandled exceptions.
      text: |-
        import 'dart:convert';
        import 'dart:io';
        import 'package:shelf/shelf.dart';
        import 'package:shelf/shelf_io.dart' as io;

        void main() async {
          var server = await io.serve(handler, 'localhost', 8080);

          print('Serving at http://${server.address.host}:${server.port}');
        }

        Future<Response> handler(Request request) async {
          var file = File('file.txt'); // Invalid file

          if (await file.exists()) {
            try {
              var content = await file.readAsString();
              var jsonContent = jsonDecode(content); // Assuming the file should contain JSON
              return Response.ok(content);
            } catch (e) {
              return Response.internalServerError(body: 'Invalid file content');
            }
          } else {
            return Response.notFound('File not found');
          }
        }
    steps:
    - Check if the file exists before trying to read it. This can be done using the
      'exists' method of the 'File' class in Dart.
    - Validate the file content against the expected format or structure. If the file
      is supposed to contain JSON, for example, try parsing it and handle any errors
      that occur.
    - Consider using a safer method to read the file, such as 'readAsString' which
      returns a Future. This allows you to handle any errors that occur during the
      file reading process in a non-blocking way.
    - If the file is not supposed to be part of the repository, remove it and add
      it to the .gitignore file to prevent it from being accidentally committed again.
    - If the file is supposed to be part of the repository but its content is not
      compatible with its extension, consider changing the file extension to match
      the content, or changing the content to match the extension.
  title: Inappropriate coding practices - invalid file
  vulnerability_id: '428'
  last_update_time: 09/18/2023
- context:
  - Usage of Dart for building cross-platform mobile, web, and desktop applications
  - Usage of Shelf for managing and organizing data in a Node.js application
  - Usage of shelf_io for managing and interacting with data storage in Node.js applications
  need: Updating software and dependencies to versions without known vulnerabilities
  solution:
    insecure_code_example:
      description: "The above code is a simple server using the `shelf` framework\
        \ in Dart. It imports the `shelf` and `shelf_io` libraries and sets up a simple\
        \ server that echoes back the request URL. \n\nThe vulnerability here lies\
        \ in the use of a potentially outdated version of the `shelf` library. Using\
        \ software or dependencies with known vulnerabilities can expose your application\
        \ to various types of attacks. If the version of `shelf` used in this application\
        \ has known vulnerabilities, it could potentially allow an attacker to exploit\
        \ these vulnerabilities to conduct attacks such as Denial of Service (DoS),\
        \ Remote Code Execution (RCE), or even data breaches.\n\nTo mitigate this,\
        \ it is recommended to always use the latest version of your dependencies\
        \ and regularly check for and update any outdated dependencies. This can be\
        \ done manually by checking the official Dart package site (https://pub.dev/)\
        \ for the latest versions of your dependencies, or automatically using a dependency\
        \ check tool. \n\nRemember, keeping your dependencies up-to-date is a crucial\
        \ part of maintaining the security of your application."
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    language: dart
    secure_code_example:
      description: |-
        The above code is a simple backend application written in Dart using the Shelf framework. The application creates a server that listens on localhost at port 8080 and responds with a simple message echoing the requested URL.

        However, the code has a potential vulnerability if the version of the 'shelf' package being used has known vulnerabilities. Using software with known vulnerabilities can expose the application to potential security risks.

        To fix this vulnerability, follow these steps:

        1. Identify the version of the 'shelf' package being used in the project. You can do this by checking the `pubspec.yaml` file in your Dart project.

        2. Check if there are any known vulnerabilities associated with the current version of the 'shelf' package. You can do this by visiting the [Dart packages site](https://pub.dev/packages/shelf) and checking the 'versions' tab for any version warnings.

        3. If there are known vulnerabilities, look for the latest stable version of the 'shelf' package that has addressed these vulnerabilities. This information can also be found on the Dart packages site.

        4. Update the 'shelf' package to the latest stable version that has fixed the known vulnerabilities. You can do this by updating the version number in your `pubspec.yaml` file and running `pub get` to fetch the updated package.

        5. Test the application thoroughly to ensure that the update does not break any existing functionality. This can involve running your existing test suite, manually testing the application, or using automated testing tools.

        6. Regularly update the 'shelf' package to its latest stable version to prevent the use of software with known vulnerabilities. This can be part of a regular maintenance schedule for your application.

        By following these steps, you can ensure that your application is not using software with known vulnerabilities, thereby reducing the potential security risks.
      text: |-
        import 'package:shelf/shelf.dart' as shelf;
        import 'package:shelf/shelf_io.dart' as io;

        void main() {
          var handler = const shelf.Pipeline().addMiddleware(shelf.logRequests())
              .addHandler(_echoRequest);

          io.serve(handler, 'localhost', 8080);
        }

        shelf.Response _echoRequest(shelf.Request request) {
          return shelf.Response.ok('Request for "${request.url}"');
        }
    steps:
    - Identify the version of the 'shelf' package being used in the project.
    - Check if there are any known vulnerabilities associated with the current version
      of the 'shelf' package.
    - If there are known vulnerabilities, look for the latest stable version of the
      'shelf' package that has addressed these vulnerabilities.
    - Update the 'shelf' package to the latest stable version that has fixed the known
      vulnerabilities.
    - Test the application thoroughly to ensure that the update does not break any
      existing functionality.
    - Regularly update the 'shelf' package to its latest stable version to prevent
      the use of software with known vulnerabilities.
  title: Use of software with known vulnerabilities in environments
  vulnerability_id: '435'
  last_update_time: 09/18/2023

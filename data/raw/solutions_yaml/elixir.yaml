- context:
  - Usage of Elixir (v1.11+) with Erlang/OTP (v23+)
  - Usage of eldap library for LDAP operations in Erlang
  need: To prevent unauthorized data access and manipulation through LDAP Injection
    attacks
  solution:
    considerations:
    - Be aware that different LDAP implementations may be susceptible to different
      kinds of injection attacks.
    - Ensure your application handles exceptions and errors gracefully, to prevent
      information disclosure in error messages.
    - Even with these precautions, be sure to have monitoring and logging in place
      to detect and respond to attempted attacks.
    insecure_code_example:
      description: In this insecure code, the Elixir application accepts a username
        from user input and uses it directly in an LDAP query. This can be exploited
        for an LDAP Injection attack, leading to unauthorized data access or manipulation.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def index(conn, %{"username" => username}) do
            :eldap.open(["ldap.example.com"])
            search_filter = {:substrings, 'uid', [{:initial, username}]}
            {:ok, result} = :eldap.search([base: 'ou=Users,dc=example,dc=com', filter: search_filter])
            json(conn, result)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code, the application now sanitizes the user input
        by replacing potential LDAP Injection attack characters '('. The sanitized
        input is then used in the LDAP query.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def index(conn, %{"username" => username}) do
            :eldap.open(["ldap.example.com"])
            username = String.replace(username, "(", "") |> String.replace(")", "")
            search_filter = {:substrings, 'uid', [{:initial, username}]}
            {:ok, result} = :eldap.search([base: 'ou=Users,dc=example,dc=com', filter: search_filter])
            json(conn, result)
          end
        end
    steps:
    - Don't use user input directly in LDAP queries.
    - Sanitize user input before using it in a query.
    - Use parameterized queries or prepared statements if available.
  title: LDAP Injection
  vulnerability_id: '107'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of MongoDB driver for interacting with MongoDB database
  need: To prevent unauthorized data access and manipulation through NoSQL Injection
    attacks
  solution:
    considerations:
    - Be aware that NoSQL databases have different query languages and injection attacks
      will vary based on the type of NoSQL database.
    - Ensure your application handles exceptions and errors gracefully, to prevent
      information disclosure in error messages.
    - Even with these precautions, be sure to have monitoring and logging in place
      to detect and respond to attempted attacks.
    insecure_code_example:
      description: In this insecure code, the Elixir/Phoenix application accepts an
        ID from user input and uses it directly in a MongoDB query. This can be exploited
        for a NoSQL Injection attack, leading to unauthorized data access or manipulation.
      text: |-
        defmodule MyAppWeb.PageController do
          use MyAppWeb, :controller

          def show(conn, %{"id" => id}) do
            page = Mongo.find(:mongo, "pages", %{"_id" => id}) |> Enum.to_list()
            json(conn, page)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code, the application now sanitizes the user input
        by replacing potential NoSQL Injection attack characters '$' and '.'. The
        sanitized input is then used in the MongoDB query.
      text: |-
        defmodule MyAppWeb.PageController do
          use MyAppWeb, :controller

          def show(conn, %{"id" => id}) do
            id = String.replace(id, "$", "") |> String.replace(".", "")
            page = Mongo.find(:mongo, "pages", %{"_id" => id}) |> Enum.to_list()
            json(conn, page)
          end
        end
    steps:
    - Don't use user input directly in NoSQL queries.
    - Sanitize user input before using it in a query.
    - Use parameterized queries or prepared statements if available.
  title: NoSQL Injection
  vulnerability_id: '106'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Plug.Adapters.Cowboy2.Http module for handling HTTP requests in Elixir
  - Usage of httpc module for making HTTP requests
  need: To prevent unauthorized network requests performed by the server due to user
    input manipulation
  solution:
    considerations:
    - Consider the fact that SSRF can be used to bypass firewall protections and make
      requests to internal resources. Use network segregation and firewall rules to
      prevent access to internal resources.
    - Remember that SSRF vulnerabilities can lead to serious security breaches, so
      it's crucial to prevent them.
    insecure_code_example:
      description: In this insecure code, the Elixir/Phoenix application accepts a
        URL from user input and makes a HTTP request to it using the :httpc.request
        function. This is a server-side request forgery (SSRF) vulnerability, as a
        malicious user could manipulate the input to make the server perform unauthorized
        requests.
      text: |-
        defmodule MyAppWeb.PageController do
          use MyAppWeb, :controller

          def external_request(conn, %{"url" => url} = _params) do
            {:ok, response} = :httpc.request(url)
            text(response)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code, the application still accepts a URL from user
        input. However, it now validates the input with a validate_url function, which
        checks if the input is part of a list of approved domains. This mitigates
        the SSRF vulnerability by preventing the server from making requests to unapproved
        domains.
      text: |-
        defmodule MyAppWeb.PageController do
          use MyAppWeb, :controller

          def external_request(conn, %{"url" => url} = _params) do
            if validate_url(url) do
              {:ok, response} = :httpc.request(url)
              text(response)
            else
              send_resp(conn, 400, "Invalid URL")
            end
          end

          defp validate_url(url), do: Enum.member?(["http://approved1.com", "http://approved2.com"], url)
        end
    steps:
    - Don't allow user input to dictate the server's network requests directly.
    - If user input must be used to make network requests, implement strict input
      validation and only allow requests to approved domains.
    - Consider using a safe-list of approved domains that the server can make requests
      to.
  title: Server-side Request Forgery (SSRF)
  vulnerability_id: '100'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Elixir's :crypto module for cryptographic operations
  need: To ensure that data encryption and decryption processes are secure, minimizing
    the risk of data being compromised
  solution:
    considerations:
    - Ensure keys and IVs are kept secret and are not re-used.
    - Beware of side-channel attacks when implementing the cryptographic algorithms.
    insecure_code_example:
      description: This code snippet is using the :aes_cbc128 mode for the block cipher
        which is considered insecure due to vulnerabilities like the padding oracle
        attack. It makes it possible for an attacker to decrypt data without knowing
        the key.
      text: |-
        defmodule InsecureCipher do
          def encrypt(data, key, iv) do
            :crypto.block_encrypt(:aes_cbc128, key, iv, data)
          end
          def decrypt(ciphertext, key, iv) do
            :crypto.block_decrypt(:aes_cbc128, key, iv, ciphertext)
          end
        end
    language: elixir
    secure_code_example:
      description: This secure code example uses the AES GCM mode for the block cipher
        which provides authenticated encryption. It also adds data integrity through
        the use of additional authenticated data (AAD). This makes it secure against
        attacks like the padding oracle attack.
      text: |-
        defmodule SecureCipher do
          def encrypt(data, key, iv, aad) do
            :crypto.crypto_one_time(:aes_gcm, key, iv, {aad, data}, :encrypt)
          end
          def decrypt(ciphertext_with_tag, key, iv, aad) do
            :crypto.crypto_one_time(:aes_gcm, key, iv, {aad, ciphertext_with_tag}, :decrypt)
          end
        end
    steps:
    - Switch from CBC mode to GCM mode.
    - Make sure to use a secure source of random numbers for the IV (Initialization
      Vector).
    - Always use secure and updated cryptographic libraries.
  title: Insecure Encryption Algorithm - Cipher Block Chaining
  vulnerability_id: '094'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  need: To prevent users from manipulating hidden fields in the application that could
    lead to undesired behaviors
  solution:
    considerations:
    - Always consider the principle of least privilege when determining which fields
      should be editable by the user.
    - It's important to validate and sanitize all inputs from the client side to protect
      against injection attacks.
    insecure_code_example:
      description: This code snippet is vulnerable because it accepts all the parameters
        from the client-side, including the id field. An attacker could manipulate
        this id field in a hidden form input, thus potentially altering data they
        do not have access to.
      text: |-
        def update(conn, %{"user" => user_params}) do
          user = Repo.get!(User, user_params["id"])
          case Accounts.update_user(user, user_params) do
            {:ok, user} -> redirect(conn, to: user_path(conn, :show, user))
            {:error, _changeset} -> :error
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure version, instead of getting the user's id from the
        client-side, it's obtained from the server-side using the authenticated user's
        session. This prevents attackers from manipulating the id field.
      text: |-
        def update(conn, %{"user" => user_params}) do
          user = Accounts.get_user!(conn.assigns.current_user.id)
          case Accounts.update_user(user, user_params) do
            {:ok, user} -> redirect(conn, to: user_path(conn, :show, user))
            {:error, _changeset} -> :error
          end
        end
    steps:
    - Do not expose sensitive information such as the user id to the client side.
    - Always validate the user input at the server side, never trust user input blindly.
    - Enforce authorization checks to ensure that the user is allowed to perform the
      action.
  title: Hidden Fields Manipulation
  vulnerability_id: '093'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Erlang/OTP's ssl application for secure communication
  need: To ensure secure encrypted connections that are not vulnerable to MitM attacks
  solution:
    considerations:
    - While this mitigates the risk of MitM attacks, it does not remove all potential
      vulnerabilities related to SSL/TLS. Ensure that you keep up to date with the
      latest best practices and updates to the SSL/TLS protocols and implement them
      as necessary.
    - The specific ciphers and versions you should use can vary over time as new vulnerabilities
      are discovered and new versions are released. Always use the latest secure versions.
    insecure_code_example:
      description: This code snippet creates an SSL server that accepts connections
        using anonymous cipher suites. This means that it does not authenticate the
        server to the client, allowing potential MitM attacks.
      text: '{:ok, _} = :ssl.listen(4001, [:inet6, {:packet, 0}, {:active, false},
        {:keyfile, ''key.pem''}, {:certfile, ''cert.pem''}, {:versions, [''tlsv1.2'']},
        {:ciphers, [:''ECDH-ECDSA-AES128-GCM-SHA256'', :anonymous] }])'
    language: elixir
    secure_code_example:
      description: This code snippet creates an SSL server that does not accept connections
        using anonymous cipher suites. By only allowing secure cipher suites, it ensures
        that all connections are authenticated and resistant to MitM attacks.
      text: '{:ok, _} = :ssl.listen(4001, [:inet6, {:packet, 0}, {:active, false},
        {:keyfile, ''key.pem''}, {:certfile, ''cert.pem''}, {:versions, [''tlsv1.2'']},
        {:ciphers, [:''ECDH-ECDSA-AES128-GCM-SHA256''] }])'
    steps:
    - Identify where your application is setting up SSL connections and allowing anonymous
      cipher suites.
    - Remove any anonymous cipher suites from the list of allowed ciphers.
    - Ensure that all connections require authentication, rejecting anonymous cipher
      suites.
  title: Insecure Encryption Algorithm - Anonymous Cipher Suites
  vulnerability_id: '092'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Plug for creating middleware
  - Usage of Phoenix Framework for web interface development
  need: Ensure the privacy and security of sensitive business information
  solution:
    considerations:
    - Use secure authentication and authorization methods.
    - Ensure that all routes that handle sensitive data are protected by authentication
      and authorization checks.
    - Regularly review and update your security measures to protect against new threats
      and vulnerabilities.
    insecure_code_example:
      description: This code retrieves all customer information from the database
        and renders it without any authentication or authorization check. This can
        lead to exposure of sensitive customer data, which can be used to craft new
        attack vectors.
      text: |-
        defmodule UnsecuredController do
          use Phoenix.Controller

          def list_customers(conn, _params) do
            customers = Repo.all(Customer)
            render(conn, "index.html", customers: customers)
          end
        end
    language: elixir
    secure_code_example:
      description: This code checks if the user is authenticated and authorized before
        retrieving and rendering customer data. This prevents unauthorized users from
        accessing sensitive customer data.
      text: |-
        defmodule SecuredController do
          use Phoenix.Controller

          plug :authenticate_user

          def list_customers(conn, _params) do
            customers = Repo.all(Customer)
            render(conn, "index.html", customers: customers)
          end

          defp authenticate_user(conn, _opts) do
            # Check if user is authenticated and authorized
            #... code ...
            # If not authenticated or authorized, redirect or send error response
            #... code ...
          end
        end
    steps:
    - Use a middleware like Plug to handle authentication and authorization.
    - Create a function to check if the user is authenticated and authorized before
      allowing access to the customer data.
    - Wrap your sensitive routes with this middleware.
  title: Business Information Leak - Customers or Providers
  vulnerability_id: '080'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Mix as the package manager
  need: Use a dependency manager to ensure smooth updates and maintainability
  solution:
    considerations:
    - Always declare your dependencies in your mix.exs file.
    - Regularly update your dependencies to their latest stable version.
    insecure_code_example:
      description: The `generate_uuid` function uses code directly copied from a package
        (UUID package for instance). This makes it hard to update and maintain the
        code. Also, if a vulnerability is found in the original package, the code
        here will also be vulnerable and would need a manual update.
      text: |-
        defmodule InsecureDependencies do
          # Here the user is using the copied code of the UUID package directly into the file
          def generate_uuid do
            #...Code copied from UUID package...
          end
        end
    language: elixir
    secure_code_example:
      description: Now, the UUID package is declared as a dependency in the mix.exs
        file and fetched using `mix deps.get`. This way, it's easier to update and
        maintain the code. Moreover, if a vulnerability is found in the original package,
        you just need to update the version in the mix.exs file and run `mix deps.get`
        again.
      text: |-
        # mix.exs file

        defp deps do
          [
            {:uuid, "~> 1.8"}
          ]
        end

        # Using the UUID package in your code

        defmodule SecureDependencies do
          def generate_uuid do
            UUID.uuid4()
          end
        end
    steps:
    - Define all dependencies in your mix.exs file.
    - Run `mix deps.get` in your command line to fetch the defined dependencies.
  title: Non-upgradable Dependencies
  vulnerability_id: '079'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Phoenix.Token for token generation and verification
  need: Create secure, unpredictable session tokens to prevent reuse
  solution:
    considerations:
    - The secret key base should be kept secret and should be hard to guess.
    - The salt used when creating the token should be unique per purpose.
    insecure_code_example:
      description: The `generate_token` function is insecure because it simply reverses
        the user_id and uses it as a token. This approach is predictable and can easily
        be reverse-engineered, which could allow an attacker to reuse a session token
        after 14 days.
      text: |-
        defmodule InsecureToken do
          def generate_token(user_id) do
            user_id
            |> Integer.to_string
            |> String.reverse
          end
        end
    language: elixir
    secure_code_example:
      description: The `generate_token` function now uses `Phoenix.Token.sign/3` to
        generate a secure token, and `verify_token` uses `Phoenix.Token.verify/4`
        to verify the token's integrity and timeliness. The token is cryptographically
        secure and unpredictable, and it cannot be reused after 14 days.
      text: |-
        defmodule SecureToken do
          @secret_key_base "s3cr3t"

          def generate_token(user_id) do
            Phoenix.Token.sign(@secret_key_base, "user salt", user_id)
          end

          def verify_token(token, user_id) do
            Phoenix.Token.verify(@secret_key_base, "user salt", token, max_age: 14 * 24 * 60 * 60)
          end
        end
    steps:
    - Install the Phoenix.Token package if it's not already installed.
    - Use `Phoenix.Token.sign/3` to generate a secure token, providing the user_id
      as the salt.
    - Use `Phoenix.Token.verify/4` to verify tokens before use.
  title: Insecurely Generated Token
  vulnerability_id: '078'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and concurrent applications
  need: Prevent unnecessary resource consumption due to inefficient algorithms or
    improper programming practices
  solution:
    considerations:
    - Applying a limit to the size of input can mitigate the risk of creating extremely
      large data structures. However, the limit should be chosen carefully to prevent
      legitimate use cases from being affected.
    - Always validate and sanitize inputs, especially if they can influence resource
      allocation.
    insecure_code_example:
      description: The `huge_list` function creates a list from 1 to `n`. If `n` is
        a large number, this function could consume a large amount of memory, possibly
        leading to an OutOfMemory error or significantly slowing down the system.
      text: |-
        defmodule Vulnerable do
          def huge_list(n) when is_integer(n) do
            Enum.to_list(1..n)
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure example, a guard clause has been added to limit `n`
        to 10,000, preventing the creation of extremely large lists. The actual limit
        should be determined based on the specific requirements and resources of your
        system.
      text: |-
        defmodule Secure do
          def huge_list(n) when is_integer(n) and n <= 10000 do
            Enum.to_list(1..n)
          end
        end
    steps:
    - Consider the nature of the problem you're trying to solve and choose the appropriate
      data structure.
    - If possible, use lazy evaluation to avoid creating large data structures in
      memory.
    - Apply a limit to the input size if it's under external control.
    - If the function is intended to create large data structures, consider alternative
      strategies like writing the data to disk.
  title: Improper Resource Allocation
  vulnerability_id: '067'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant
    applications
  - Usage of IO library for input/output operations
  need: Avoid leaking technical information via console functions
  solution:
    considerations:
    - While removing console functions, ensure that important error information is
      still being logged somewhere for debugging.
    - Remember to adjust logging levels appropriately for the environment (e.g., debug
      in development, warn/error in production).
    insecure_code_example:
      description: The `IO.inspect` function is used to print the data to the console.
        This could expose sensitive information in a production environment.
      text: |-
        defmodule Vulnerable do
          def process(data) do
            IO.inspect(data)
            # Process data
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure example, the `IO.inspect` function has been commented
        out to prevent information leakage. Logging to files or using proper logging
        libraries would be a more secure approach.
      text: |-
        defmodule Secure do
          def process(data) do
            # IO.inspect(data)
            # Process data
          end
        end
    steps:
    - Remove or comment out IO functions in production code.
    - Use a proper logging library that writes to log files instead of stdout.
    - Implement a logging level feature where debug-level messages aren't logged in
      production.
  title: Technical Information Leak - Console Functions
  vulnerability_id: '066'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Logger module for logging
  need: Accurate timestamping for traceability
  solution:
    considerations:
    - It's important to regularly check the NTP synchronization status of your server.
    - Consider using an NTP pool to ensure reliable time synchronization.
    insecure_code_example:
      description: This function logs an event with a timestamp that is based on the
        system's internal clock, which may not be synchronized with an NTP server.
        If the internal clock is wrong, the logged timestamps will also be wrong,
        causing a loss of traceability.
      text: |-
        def log_event(event) do
          Logger.info("{#{DateTime.utc_now()}} - #{event}")
        end
    language: elixir
    secure_code_example:
      description: In the corrected code, the function's behavior doesn't change because
        the NTP synchronization happens at the system level. The function still uses
        `DateTime.utc_now()`, but now the underlying system time is correctly synchronized
        with an NTP server. This ensures accurate timestamps in logs.
      text: |-
        def log_event(event) do
          Logger.info("{#{DateTime.utc_now()}} - #{event}")
        end
    steps:
    - Make sure your server's clock is synchronized with an NTP server.
    - Ensure the application relies on this synchronized time for timestamping logs.
  title: Traceability Loss - Server's Clock
  vulnerability_id: '064'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant
    applications
  - Usage of Plug library for request handling
  need: Prevent unauthorized access to sensitive data
  solution:
    considerations:
    - Even though we removed the password from the body in this example, be aware
      that the body can contain other sensitive data that should also not be logged.
    - Always consider the sensitivity of data before deciding to log it.
    insecure_code_example:
      description: This function handles all incoming requests. It first reads the
        body of the request and then logs it using IO.inspect. This is problematic
        because the body of the request can contain sensitive user information like
        usernames, passwords, and other personal data. Logging this data in plain
        text can expose it to unauthorized users who might have access to the log
        files.
      text: |-
        def handle_request(request) do
          {:ok, body, conn} = read_body(request.conn)
          IO.inspect(body)
          case Router.dispatch(request) do
            {:ok, response} -> send_resp(conn, 200, response)
            _ -> send_resp(conn, 404, 'Not found')
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure version of the function, we only log non-sensitive
        parts of the request. In this case, we remove the password from the body before
        logging it.
      text: |-
        def handle_request(request) do
          {:ok, body, conn} = read_body(request.conn)
          IO.inspect(Map.delete(body, 'password'))
          case Router.dispatch(request) do
            {:ok, response} -> send_resp(conn, 200, response)
            _ -> send_resp(conn, 404, 'Not found')
          end
        end
    steps:
    - Stop logging the entire request body.
    - If necessary, only log non-sensitive parts of the request.
  title: Sensitive Information Stored in Logs
  vulnerability_id: '059'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of crypto library for encryption
  need: Prevent unauthorized access and tampering of encrypted data.
  solution:
    considerations:
    - While AES is currently considered secure, cryptography is a rapidly evolving
      field. Stay updated on the latest best practices and recommendations.
    - Remember that secure encryption is just one aspect of data security. Also consider
      secure data storage and transmission, and proper key management.
    insecure_code_example:
      description: This Elixir function uses the DES algorithm to encrypt data. DES
        is considered insecure due to its small key size, making it susceptible to
        brute-force attacks.
      text: |-
        def encrypt(data, key) do
          :crypto.block_encrypt(:des_ecb, key, data)
        end
    language: elixir
    secure_code_example:
      description: This Elixir function uses the AES algorithm to encrypt data. AES
        is a secure encryption algorithm that is resistant to brute-force attacks
        due to its large key size.
      text: |-
        def encrypt(data, key) do
          :crypto.block_encrypt(:aes_ecb, key, data)
        end
    steps:
    - Replace the DES encryption function with the AES encryption function.
    - Ensure that the key size is at least 128 bits, which is the minimum key size
      for AES.
  title: Insecure Encryption Algorithm
  vulnerability_id: '052'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Comeonin library for hashing
  need: Prevent unauthorized access by securely hashing and storing passwords.
  solution:
    considerations:
    - Bcrypt has a maximum password length of 72 characters. If your application allows
      longer passwords, consider using a different hashing function.
    - Remember that secure password storage is just one aspect of user authentication
      security. Also consider enforcing a strong password policy, using secure password
      reset mechanisms, and protecting against credential stuffing attacks.
    insecure_code_example:
      description: This Elixir function hashes passwords with the SHA-256 function
        before storing them. While SHA-256 is not inherently insecure, it is not suitable
        for password hashing due to its speed, which makes it susceptible to brute-force
        attacks.
      text: |-
        def register_user(username, password) do
          hashed_password = :crypto.hash(:sha256, password)
          User.changeset(%User{}, %{username: username, password: hashed_password})
          |> Repo.insert()
        end
    language: elixir
    secure_code_example:
      description: This Elixir function hashes passwords with bcrypt before storing
        them. bcrypt is a secure hashing function that is resistant to brute-force
        attacks due to its configurable computational cost.
      text: |-
        def register_user(username, password) do
          hashed_password = Comeonin.Bcrypt.hashpwsalt(password)
          User.changeset(%User{}, %{username: username, password: hashed_password})
          |> Repo.insert()
        end
    steps:
    - Replace the SHA-256 hashing function with bcrypt.
    - Ensure that the bcrypt work factor is appropriately high to increase the computational
      cost of cracking the hashes.
  title: Cracked Weak Credentials
  vulnerability_id: '051'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant
    applications
  - Usage of Ecto library for data validation
  need: Prevent brute force attacks by enforcing a strong password policy.
  solution:
    considerations:
    - Even with a strong password policy, passwords can still be guessed if they follow
      common patterns. Consider using a password strength estimator to further reduce
      the risk.
    - Always store passwords in a hashed form, never in plain text.
    insecure_code_example:
      description: This Elixir function allows a user to register with any password,
        regardless of its length or complexity. This makes it easy for an attacker
        to guess weak passwords.
      text: |-
        def register_user(username, password) do
          User.changeset(%User{}, %{username: username, password: password})
          |> Repo.insert()
        end
    language: elixir
    secure_code_example:
      description: This Elixir function enforces a strong password policy during user
        registration. The password must be at least 8 characters long and include
        a lower-case letter, an upper-case letter, and a number.
      text: |-
        def changeset(user, attrs) do
          user
          |> cast(attrs, [:username, :password])
          |> validate_length(:password, min: 8)
          |> validate_format(:password, ~r/[a-z]/, message: "must include a lower-case letter")
          |> validate_format(:password, ~r/[A-Z]/, message: "must include an upper-case letter")
          |> validate_format(:password, ~r/[0-9]/, message: "must include a number")
        end

        def register_user(username, password) do
          User.changeset(%User{}, %{username: username, password: password})
          |> Repo.insert()
        end
    steps:
    - Add password validation in the changeset function. This should enforce a minimum
      length and complexity requirements.
    - Test the application to ensure the password policy is being enforced correctly.
  title: Guessed Weak Credentials
  vulnerability_id: '050'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and concurrent applications
  - Usage of Plug library for handling HTTP requests
  need: Prevent cookie exposure over insecure channels or to unauthorized users.
  solution:
    considerations:
    - Cookies that contain sensitive information should always be sent with the secure
      flag, and typically also with the HttpOnly flag.
    - Even with these flags, cookies can still be vulnerable to other types of attacks,
      such as CSRF attacks. It's important to also implement other security measures,
      such as CSRF tokens.
    insecure_code_example:
      description: This Elixir function sets a 'session' cookie without secure flags.
        Without the secure flag, the cookie could be sent over an insecure HTTP connection.
        Without the HttpOnly flag, the cookie could be accessed by client-side scripts.
      text: |-
        def set_cookie(conn) do
          conn
          |> put_resp_cookie("session", "session_value")
        end
    language: elixir
    secure_code_example:
      description: This Elixir function sets a 'session' cookie with the secure and
        HttpOnly flags. The secure flag ensures the cookie is only sent over HTTPS.
        The HttpOnly flag prevents the cookie from being accessed by client-side scripts.
      text: |-
        def set_cookie(conn) do
          conn
          |> put_resp_cookie("session", "session_value", secure: true, http_only: true)
        end
    steps:
    - Add the :secure and :http_only options when setting the cookie.
    - Test the application to ensure the cookies are being set correctly and that
      the application still functions as expected.
  title: Insecurely Generated Cookies
  vulnerability_id: '042'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of PostgreSQL Database for data storage and retrieval
  need: Prevent unauthorized access to system resources using default credentials.
  solution:
    considerations:
    - Always use unique, strong credentials for your system resources.
    - Never hard-code credentials into your application. If your source code is exposed,
      so are your credentials.
    - Always store credentials securely. Environment variables are a simple solution,
      but for higher security needs, consider a secure credential storage solution.
    insecure_code_example:
      description: This is the configuration for a PostgreSQL database in an Elixir
        application. The username and password are set to 'postgres', which are commonly
        used default credentials. If an attacker knows or guesses that the application
        is using these default credentials, they can gain unauthorized access to the
        database.
      text: |-
        config :my_app, MyApp.Repo,
          database: "my_app_prod",
          username: "postgres",
          password: "postgres",
          hostname: "localhost"
    language: elixir
    secure_code_example:
      description: In the secure example, the username and password are not hard-coded
        into the application. Instead, the application retrieves them from environment
        variables. This helps to keep the credentials secure.
      text: |-
        config :my_app, MyApp.Repo,
          database: "my_app_prod",
          username: System.get_env("DB_USERNAME"),
          password: System.get_env("DB_PASSWORD"),
          hostname: "localhost"
    steps:
    - Change the default credentials to a unique, strong username and password.
    - Store the new credentials securely. Do not hard-code them into your application.
      Consider using environment variables or a secure credential storage solution.
  title: Enabled Default Credentials
  vulnerability_id: '041'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant
    applications
  - Usage of Phoenix Framework for building web applications
  need: Proper validation of user sessions or tokens to secure web services.
  solution:
    considerations:
    - This solution is for a simple scenario where users can only access their own
      data. In real-world applications, there may be different roles with different
      levels of access, so more complex authorization checks might be necessary.
    - The `get_current_user` function is assumed to retrieve the currently authenticated
      user from the connection. Ensure it properly authenticates the user.
    insecure_code_example:
      description: This code sample is a simple controller action in a Phoenix API
        that retrieves and sends user data based on the user id received from the
        request parameters. The problem here is there are no authorization checks
        in place, meaning any authenticated user or even unauthenticated users can
        retrieve any user's information just by changing the id parameter. This poses
        a significant risk as it can lead to unauthorized access to confidential user
        information.
      text: |-
        def show(conn, %{"id" => id}) do
          user = Repo.get(User, id)
          render(conn, "show.json", user: user)
        end
    language: elixir
    secure_code_example:
      description: In the secure code sample, before fetching the user data, an authorization
        check is added to ensure that the requester is the same as the user they are
        trying to access. If the check fails, a 403 Forbidden response is returned,
        thus preventing unauthorized access.
      text: |-
        def show(conn, %{"id" => id}) do
          requester = get_current_user(conn)
          if requester && requester.id == id do
            user = Repo.get(User, id)
            render(conn, "show.json", user: user)
          else
            conn |> put_status(:forbidden) |> json(%{message: 'Forbidden'})
          end
        end
    steps:
    - Add an authorization check before accessing user data.
    - Ensure the user making the request is authorized to access the requested user's
      data.
  title: Improper Authorization Control for Web Services
  vulnerability_id: '039'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  need: Prevention of unauthorized access to sensitive business data.
  solution:
    considerations:
    - In a real-world application, your user model might contain more or different
      fields, adjust the view model accordingly.
    - Make sure the get_current_user function properly authenticates the user.
    insecure_code_example:
      description: This Elixir code is a simple controller action in a Phoenix API
        that lists all the users in the database. The Repo.all(User) fetches all users'
        information from the database, including sensitive data such as usernames,
        employee information, client information, provider information, and strategic
        information. This is a business information leak vulnerability because it
        exposes sensitive business data without proper access control checks.
      text: |-
        def index(conn, _params) do
          users = Repo.all(User)
          render(conn, "index.json", users: users)
        end
    language: elixir
    secure_code_example:
      description: In this code, before we fetch any user data, we check if the currently
        authenticated user is an admin. If they are, we fetch the users but only return
        the id and username, removing any sensitive information. If the current user
        is not an admin, we return a 403 Forbidden response.
      text: |-
        def index(conn, _params) do
          user = get_current_user(conn)
          if user && user.role == 'admin'
            users = Repo.all(User)
            users = for user <- users, do: %{id: user.id, username: user.username}
            render(conn, "index.json", users: users)
          else
            conn |> put_status(:forbidden) |> json(%{message: 'Forbidden'})
          end
        end
    steps:
    - Implement proper access control checks before retrieving data from the database.
    - Restrict what information is sent to the client.
    - Consider using view models to control what data is sent to the client.
  title: Business Information Leak
  vulnerability_id: '038'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for the application
  need: To prevent unauthorized access to sensitive system and configuration data
  solution:
    considerations:
    - Remember, security is not a one-time event but a continuous process. Always
      stay updated with the latest practices and tools.
    - Consider using tools to scan your headers and test your application for other
      common vulnerabilities.
    insecure_code_example:
      description: The vulnerable code below doesn't handle the HTTP headers and response
        properly. Thus, it leaks the Phoenix version information which can expose
        the application to potential risks. The version information can help an attacker
        find known vulnerabilities and launch specific attacks.
      text: |-
        defmodule MyAppWeb.Router do
         use MyAppWeb, :router

         pipeline :api do
         plug :accepts, ["json"]
         end

         scope "/api", MyAppWeb do
         pipe_through :api

         resources "/users", UserController, only: [:index, :show, :create]
         end
        end
    language: elixir
    secure_code_example:
      description: In the secure code, the version header is removed using the put_resp_header
        function. This prevents leaking the Phoenix version information to the client.
        This is a simple yet effective way to reduce the information an attacker could
        potentially use.
      text: |-
        defmodule MyAppWeb.Router do
         use MyAppWeb, :router

         pipeline :api do
         plug :accepts, ["json"]
         plug :remove_version_header
         end

         defp remove_version_header(conn, _opts) do
         Plug.Conn.put_resp_header(conn, "server", "My App")
         end

         scope "/api", MyAppWeb do
         pipe_through :api

         resources "/users", UserController, only: [:index, :show, :create]
         end
        end
    steps:
    - Add a new function inside the router module that removes or alters the server
      response header.
    - Call this function inside the pipeline that will be used by the desired routes.
  title: Technical Information Leak
  vulnerability_id: '037'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.11 and above) for building scalable and fault-tolerant applications
  - Usage of Erlang/OTP for building scalable and fault-tolerant systems
  need: Prevent predictable sequences of random numbers
  solution:
    considerations:
    - Never use insecure functions for generating random numbers when dealing with
      sensitive data.
    - Always use secure random number generators provided by the language or framework.
    - Never use predictable seeds for random number generators.
    insecure_code_example:
      description: This code is vulnerable as it uses the :random.uniform function
        from Erlang which is not suitable for generating secure random numbers. Also,
        it uses :erlang.now to seed the random number generator, which can be predictable
        and hence lead to generating predictable random numbers.
      text: |-
        defmodule MyApp.TokenGenerator do
          def generate_token do
            :random.seed(:erlang.now())
            :random.uniform(100000)
          end
        end
    language: elixir
    secure_code_example:
      description: This secure code uses the :crypto.strong_rand_bytes function for
        generating a binary string of random bytes, which is then converted into a
        hexadecimal string using Base.encode16. This ensures the generation of secure
        random numbers.
      text: |-
        defmodule MyApp.TokenGenerator do
          def generate_token do
            :crypto.strong_rand_bytes(16) |> Base.encode16()
          end
        end
    steps:
    - Avoid using the :random.uniform function for generating secure random numbers.
    - Use :crypto.strong_rand_bytes function for generating secure random numbers.
    - Use Base.encode16 function to convert the binary data to a hexadecimal string
      if needed.
  title: Insecure Generation of Random Numbers
  vulnerability_id: '034'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.11 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications (version 1.5 and above)
  need: Secure transmission of sensitive information
  solution:
    considerations:
    - Sensitive information should never be transmitted in URL parameters.
    - Use secure cookies or sessions for storing and transmitting user identifiers
      or other sensitive information.
    - Ensure secure transmission of data by using HTTPS.
    insecure_code_example:
      description: The above code is vulnerable because it allows the user id to be
        passed as a URL parameter. This exposes the user's sensitive information as
        the user id is visible in the URL and can be stored in browser history, sent
        to external sites via the referrer HTTP header, or intercepted by malicious
        scripts.
      text: |-
        defmodule UserController do
          use MyAppWeb, :controller
          def show(conn, %{'id' => id}) do
            user = Repo.get!(User, id)
            render(conn, 'show.html', user: user)
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the user id is obtained from a secure
        session or a cookie, rather than being passed in the URL. This mitigates the
        risk of sensitive information being exposed via the URL.
      text: |-
        defmodule UserController do
          use MyAppWeb, :controller
          def show(conn, _params) do
            id = get_session(conn, :user_id)
            user = Repo.get!(User, id)
            render(conn, 'show.html', user: user)
          end
        end
    steps:
    - Avoid sending sensitive information in URL parameters.
    - Use the POST method to transmit sensitive data.
    - Use secure sessions or cookies to store user identifiers.
  title: Sensitive Information Sent Via URL Parameters
  vulnerability_id: '030'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.11 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework (1.5+) for building web applications
  need: Securely store sensitive information
  solution:
    considerations:
    - Always store sensitive data in secure storage systems, never in plain files.
    - Encrypt sensitive data at rest and in transit.
    - Ensure secure deletion of temporary files containing sensitive data.
    insecure_code_example:
      description: The above code is vulnerable because it writes sensitive information
        to a temporary file '/tmp/temp_file'. This file is accessible to all other
        users on the system, and can also be read by any other processes. This exposes
        the sensitive information to potential unauthorized access and theft.
      text: |-
        defmodule TempFilesController do
          use MyAppWeb, :controller
          def write(conn, %{'data' => data}) do
            File.write!('/tmp/temp_file', data)
            send_resp(conn, 200, "Data written to temporary file.")
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the sensitive data is first encrypted
        before being stored, ensuring that even if unauthorized access were to occur,
        the data would be unreadable without the decryption key. The 'SecureStorage'
        is a hypothetical secure storage system that should be substituted with an
        actual secure data storage system in your application.
      text: |-
        defmodule SecureStorageController do
          use MyAppWeb, :controller
          def write(conn, %{'data' => data}) do
            encrypted_data = Encryption.encrypt(data)
            {:ok, _} = SecureStorage.put(encrypted_data)
            send_resp(conn, 200, "Data securely stored.")
          end
        end
    steps:
    - Avoid saving sensitive information in temporary files.
    - Encrypt sensitive data before saving.
    - Ensure temporary files are securely deleted after use.
  title: Insecure Temporary Files
  vulnerability_id: '028'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.11 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework (1.5 and above) for building web applications
  need: Prevent attackers from enumerating valid usernames in the system
  solution:
    considerations:
    - Even with these changes, ensure to monitor for and limit brute force attempts
      on your login endpoints.
    - Consider implementing other security measures such as CAPTCHA and multi-factor
      authentication.
    insecure_code_example:
      description: The above code is vulnerable to user enumeration. When a user tries
        to log in, the application responds differently depending on whether the provided
        username exists or not. If the username doesn't exist, it sends back a 'User
        does not exist' message. If the username exists but the password is wrong,
        it sends back a 'Wrong password' message. An attacker could use these differing
        responses to enumerate the existing users.
      text: |-
        defmodule UserController do
          use MyAppWeb, :controller
          def login(conn, %{'username' => username, 'password' => password}) do
            case Accounts.get_user_by_username(username) do
              nil -> send_resp(conn, 400, "User does not exist")
              user ->
                if user.password == password,
                  do: send_resp(conn, 200, "Logged in successfully")
                  else: send_resp(conn, 400, "Wrong password")
                end
            end
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the server's response is the same ('Incorrect
        credentials') for both existent and non-existent users. This prevents an attacker
        from being able to enumerate the existing users based on the server's responses.
      text: |-
        defmodule UserController do
          use MyAppWeb, :controller
          def login(conn, %{'username' => username, 'password' => password}) do
            case Accounts.get_user_by_username(username) do
              nil -> send_resp(conn, 400, "Incorrect credentials")
              user ->
                if user.password == password,
                  do: send_resp(conn, 200, "Logged in successfully")
                  else: send_resp(conn, 400, "Incorrect credentials")
                end
            end
          end
        end
    steps:
    - Change the server response to be the same for both existent and non-existent
      users.
    - Ensure that the response does not leak any information about the existence or
      non-existence of a user.
  title: User Enumeration Vulnerability
  vulnerability_id: '026'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of HTTPoison for making HTTP requests
  need: Ensure data confidentiality and integrity during transmission
  solution:
    considerations:
    - Always use HTTPS for all communications involving sensitive data.
    - Ensure the server's TLS configuration is secure and up-to-date.
    - In the context of APIs, make sure that all endpoints are only available over
      HTTPS.
    insecure_code_example:
      description: The below Elixir code uses HTTPoison to send a HTTP request. Data
        transmitted over HTTP can be intercepted and read by anyone on the network.
      text: |-
        defmodule MyApp.Client do
         def send_request(data) do
         HTTPoison.post("http://example.com", data)
         end
        end
    language: elixir
    secure_code_example:
      description: The below Elixir code modifies the original to use HTTPS, ensuring
        that data is encrypted during transmission.
      text: |-
        defmodule MyApp.Client do
         def send_request(data) do
         HTTPoison.post("https://example.com", data)
         end
        end
    steps:
    - Replace all HTTP URLs with their HTTPS counterparts.
    - If the server does not support HTTPS, configure it to do so.
    - If you do not control the server, request that the server owner enables HTTPS.
  title: Use of an Insecure Channel
  vulnerability_id: '022'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.11 and above) for building scalable and concurrent
    applications
  - Usage of File module for file handling
  need: Protect sensitive information from unauthorized access
  solution:
    considerations:
    - Always use encryption when storing or transmitting sensitive data.
    - Encrypt the data with an encryption algorithm that is sufficient for the sensitivity
      of the information.
    - Proper key management is also necessary to ensure the integrity of encrypted
      data.
    insecure_code_example:
      description: The below Elixir code writes confidential information into a file
        without any encryption. This makes it readable for anyone who can gain access
        to the file.
      text: |-
        defmodule MyApp.Data do
         def write_to_file(data) do
         File.write("/path/to/file", data)
         end
        end
    language: elixir
    secure_code_example:
      description: The below Elixir code uses AES encryption (via the :crypto module)
        to encrypt the data before writing it to a file. This ensures that even if
        someone gains access to the file, they can't read the data without the encryption
        key.
      text: |-
        defmodule MyApp.Data do
         def write_to_file(data, key) do
         {:ok, iv} = :crypto.strong_rand_bytes(16)
         {:ok, cipher} = :crypto.block_encrypt(:aes_cbc128, key, iv, data)
         encrypted_data = iv <> cipher
         File.write("/path/to/file", encrypted_data)
         end
        end
    steps:
    - Make use of the :crypto module for encryption purposes.
    - Generate a strong encryption key and keep it secure.
    - Encrypt sensitive data using the encryption key before storing or transmitting
      it.
    - When retrieving the data, make sure to decrypt it using the same encryption
      key.
  title: Non-encrypted Confidential Information
  vulnerability_id: '020'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of ETS for caching
  need: Prevent unauthorized access to administrative credentials
  solution:
    considerations:
    - Consider using hashing or encryption methods for sensitive data stored in memory.
    - Ensure secure configuration of cache storage.
    - Regular audits of data handling and storage practices.
    insecure_code_example:
      description: In the below code, admin credentials are stored directly into the
        Elixir's ETS (Erlang Term Storage) which acts as in-memory store. If an attacker
        manages to dump the ETS table, they can gain access to sensitive data.
      text: |-
        defmodule MyApp.Cache do
         def store_credentials(username, password) do
         :ets.new(:creds, [:public, :named_table])
         :ets.insert(:creds, {username, password})
         end
        end
    language: elixir
    secure_code_example:
      description: In the below secure code, the admin credentials are hashed before
        being stored into the ETS. This means even if an attacker dumps the ETS table,
        they cannot gain access to the actual admin credentials.
      text: |-
        defmodule MyApp.Cache do
         def store_credentials(username, password) do
         hashed_password = Bcrypt.hashpwsalt(password)
         :ets.new(:creds, [:public, :named_table])
         :ets.insert(:creds, {username, hashed_password})
         end
        end
    steps:
    - 'Install the Comeonin library for password hashing: mix deps.get comeonin.'
    - Hash sensitive data before storing them in cache or memory.
    - Avoid storing sensitive information in plain text.
    - Ensure secure configuration of cache or memory storage.
  title: Administrative Credentials Stored in Cache Memory
  vulnerability_id: '019'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix web framework for building scalable and fault-tolerant web applications
  need: Secure transfer of sensitive data
  solution:
    considerations:
    - While storing sensitive data in the session is more secure than sending it as
      GET parameters, it's still not the most secure method. For optimal security,
      consider using authentication tokens or other methods that don't involve sending
      or storing the password in plain text.
    - Ensure that your application uses HTTPS to further secure the communication
      between the client and the server.
    insecure_code_example:
      description: In the insecure code example, the server sends sensitive information
        (user credentials) as GET parameters. These parameters are included in the
        URL and can be easily intercepted by malicious parties. This puts the user's
        credentials at risk of being compromised.
      text: |-
        def login(conn, %{"username" => username, "password" => password}) do
          redirect(conn, to: "/home?username=#{username}&password=#{password}")
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, sensitive information (user credentials)
        is stored in the session instead of being sent as GET parameters. This prevents
        the sensitive information from being included in the URL and therefore reduces
        the risk of it being intercepted by malicious parties.
      text: |-
        def login(conn, %{"username" => username, "password" => password}) do
          # store the username and password in the session
          conn
          |> put_session(:username, username)
          |> put_session(:password, password)
          |> redirect(to: "/home")
        end
    steps:
    - Instead of sending sensitive information as GET parameters, send them as POST
      parameters.
    - Update the routes and the form to use the POST method instead of GET.
    - Modify the function to accept POST parameters instead of GET parameters.
    - Test the changes to make sure everything works as expected.
  title: Sensitive Information Sent Insecurely
  vulnerability_id: '017'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of Cowboy for HTTP request and response handling
  - Usage of Plug package for building web applications in Elixir
  need: Secure data transfer between client and server
  solution:
    considerations:
    - The usage of older TLS versions might be required for compatibility with older
      clients. In these cases, you must balance security with functionality.
    - Using only secure TLS versions can also improve the server's SEO score and the
      trust of users, as many browsers show a warning when accessing sites that use
      insecure TLS versions.
    insecure_code_example:
      description: In the insecure code example, the server configuration allows for
        the usage of insecure TLS protocol versions ('tlsv1' and 'tlsv1.1'). These
        older versions of TLS are known to have several security vulnerabilities that
        can be exploited to intercept and decrypt the communication between the client
        and the server.
      text: |-
        config :my_app, MyApp.Endpoint,
          https: [
            port: 4001,
            cipher_suite: :strong,
            honor_cipher_order: true,
            versions: [:'tlsv1', :'tlsv1.1']
          ]
    language: elixir
    secure_code_example:
      description: In the secure code example, the server configuration only allows
        the use of secure TLS protocol versions (TLSv1.2 and TLSv1.3). This ensures
        that all the communication between the client and the server is encrypted
        using a secure encryption algorithm and prevents potential interception and
        decryption.
      text: |-
        config :my_app, MyApp.Endpoint,
          https: [
            port: 4001,
            cipher_suite: :strong,
            honor_cipher_order: true,
            versions: [:'tlsv1.2', :'tlsv1.3']
          ]
    steps:
    - Update the server configuration to only allow secure TLS protocol versions (TLSv1.2
      or TLSv1.3).
    - Test the server after the changes to make sure that everything works as expected.
    - Regularly update and patch the server software to make sure that it's up to
      date with the latest security standards.
  title: Insecure Encryption Algorithm - SSL/TLS
  vulnerability_id: '016'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Guardian library for JWT authentication
  need: Securely authenticate user requests
  solution:
    considerations:
    - Make sure that the token generation and verification process is secure.
    - Use a strong, random, and unique secret key for token generation.
    - Ensure that the token has an expiration date to limit its lifetime.
    - Store the secret key securely and don't expose it in the code or version control
      systems.
    insecure_code_example:
      description: In the insecure code example, the server uses Basic Authentication,
        where the user credentials are Base64-encoded but not encrypted, and transmitted
        over the network. This can be easily decoded and allows an attacker to intercept
        the user's credentials.
      text: |-
        def login(conn, %{"username" => username, "password" => password}) do
          user = Repo.get_by(User, username: username)
          if user && Bcrypt.checkpw(password, user.password_hash) do
            {:ok, token, _claims} = BasicAuthToken.encode_and_sign(user.username)
            conn
            |> put_resp_header("authorization", "Basic #{token}")
            |> send_resp(:ok, "Logged in")
          else
            send_resp(conn, :unauthorized, "Incorrect username or password")
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the server uses Bearer Authentication
        with a hashed token. The server generates a JWT token for the authenticated
        user and returns it in the Authorization header. This ensures the user's sensitive
        credentials are not transmitted over the network.
      text: |-
        def login(conn, %{"username" => username, "password" => password}) do
          user = Repo.get_by(User, username: username)
          if user && Bcrypt.checkpw(password, user.password_hash) do
            {:ok, jwt, _full_claims} = Guardian.encode_and_sign(user, :token)
            conn
            |> put_resp_header("authorization", "Bearer #{jwt}")
            |> send_resp(:ok, "Logged in")
          else
            send_resp(conn, :unauthorized, "Incorrect username or password")
          end
        end
    steps:
    - Implement Bearer authentication using hashed tokens instead of transmitting
      sensitive user credentials.
    - Use HTTPS for all sensitive communications to prevent the interception of data.
    - Consider other authentication mechanisms like OAuth or JWT for even better security.
  title: Insecure Authentication Method - Basic
  vulnerability_id: '015'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building scalable web applications
  need: Prevent unauthorized password change
  solution:
    considerations:
    - Consider using multi-factor authentication for sensitive operations like password
      changes to add an additional layer of security.
    - Ensure your application rate limits password change requests to prevent brute-force
      attacks.
    - Always log password change events for future analysis if needed.
    insecure_code_example:
      description: In the insecure code example, the server changes the user's password
        without verifying the security code provided by the user. This allows an attacker
        to change a user's password without the correct security code.
      text: |-
        def change_password(conn, %{'security_code' => _security_code, 'new_password' => new_password}) do
          user = conn.assigns.current_user
          user = User.changeset(user, %{password: new_password})
          Repo.update!(user)
          send_resp(conn, :ok, 'Password updated')
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the server first checks if the provided
        security code matches the one stored in the database for that user. If it
        does not, the server returns an 'Unauthorized' response. This ensures that
        an attacker can't change a user's password without the correct security code.
      text: |-
        def change_password(conn, %{'security_code' => security_code, 'new_password' => new_password}) do
          user = conn.assigns.current_user
          if check_security_code(user, security_code) do
            user = User.changeset(user, %{password: new_password})
            Repo.update!(user)
            send_resp(conn, :ok, 'Password updated')
          else
            send_resp(conn, :unauthorized, 'Incorrect security code')
          end
        end
    steps:
    - Always validate the security code on the server-side before changing the password.
    - Ensure that the security code expires after a certain time period to limit the
      time window for an attack.
    - Lock the account or require additional verification if there are too many failed
      attempts to enter the security code.
  title: Insecure Functionality
  vulnerability_id: '014'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Ecto ORM for data access
  need: Prevent unauthorized access to user data
  solution:
    considerations:
    - Consider using resource-based access control to ensure users only have access
      to their own resources.
    - Be aware that using direct references to internal objects (like database keys)
      in user-facing interfaces can lead to unauthorized access.
    - Be sure to test your application thoroughly to ensure there are no unauthorized
      access vulnerabilities.
    insecure_code_example:
      description: The insecure code example takes an 'id' parameter from the incoming
        request and directly uses it to fetch the user data from the database. This
        means that an attacker can modify the 'id' in the request to access data of
        any user.
      text: |-
        def show(conn, %{'id' => id}) do
          user = Repo.get(User, id)
          render(conn, 'show.json', user: user)
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the server first checks whether the
        authenticated user's 'id' matches the 'id' in the request. If it does not,
        the server returns a '403 Forbidden' response. This ensures that users can
        only access their own data.
      text: |-
        def show(conn, %{'id' => id}) do
          if conn.assigns.current_user.id == id do
            user = Repo.get(User, id)
            render(conn, 'show.json', user: user)
          else
            send_resp(conn, :forbidden, 'Access denied')
          end
        end
    steps:
    - Avoid using direct references to internal objects.
    - Use session-based user authentication and associate this with the users' actions.
    - Instead of using the user-provided 'id', use the 'id' associated with the authenticated
      session.
  title: Insecure Object Reference
  vulnerability_id: '013'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of mix for dependency management
  need: Prevent exploitation of known vulnerabilities in dependencies
  solution:
    considerations:
    - Regularly check for updates to dependencies and apply them promptly.
    - Consider using automated tools to track and manage dependency vulnerabilities.
    - Updating dependencies could introduce compatibility issues with the existing
      codebase. Adequate testing should be performed after updates.
    insecure_code_example:
      description: The insecure code example demonstrates the use of an outdated and
        potentially vulnerable version of the Phoenix framework (1.2.1), as specified
        in the mix.exs file in an Elixir project. Known vulnerabilities exist in this
        version of the Phoenix framework that can be exploited by attackers.
      text: |-
        defp deps do
          [{:phoenix, '~> 1.2.1'}]
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the Phoenix framework has been updated
        to a more recent and secure version (1.5.7). This version does not have the
        vulnerabilities present in the older version.
      text: |-
        defp deps do
          [{:phoenix, '~> 1.5.7'}]
        end
    steps:
    - Identify the dependencies and their versions that are known to have vulnerabilities.
    - Search for the latest versions or the safe versions of those dependencies.
    - Update the dependency specifications in your mix.exs file.
    - Run 'mix deps.update --all' to update the dependencies.
  title: Use of Software with Known Vulnerabilities
  vulnerability_id: '011'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of generic packages or server types
  need: Avoid exposure of sensitive data
  solution:
    considerations:
    - Always ensure that the environment variables are securely managed and not exposed
      in any logs or error messages.
    - For better security, consider using a secure key vault service for managing
      sensitive data.
    insecure_code_example:
      description: The source code contains sensitive data, including a password and
        an API key, hardcoded in the code. This is a bad practice as it exposes sensitive
        information directly in the source code, making it accessible to anyone who
        can access this code.
      text: |-
        defmodule MySensitiveInfo do
          @password 'sensitive_password'
          @api_key 'API_KEY'
        end
    language: elixir
    secure_code_example:
      description: The revised code now retrieves sensitive data from environment
        variables, which are set outside of the application and not exposed in the
        source code. This avoids the direct exposure of sensitive information in the
        source code.
      text: |-
        defmodule MySensitiveInfo do
          @password System.get_env('PASSWORD')
          @api_key System.get_env('API_KEY')
        end
    steps:
    - Delete all hardcoded sensitive information from the source code.
    - Change all affected access credentials where these have been exposed.
    - Remove sensitive information from git logs if the code has been previously committed.
    - Use environment variables or a secure key vault service to manage sensitive
      data.
  title: Sensitive Information in Source Code
  vulnerability_id: '009'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of plain maps for user management
  need: Prevent unauthorized access to protected resources
  solution:
    considerations:
    - In a real-world application, passwords should not be stored in plaintext. Consider
      using hashing algorithms such as bcrypt.
    - This is a basic example. In practice, you would use more secure and established
      authentication frameworks.
    insecure_code_example:
      description: This Elixir code defines a user system using a struct User, which
        holds an id and data. The function 'access_data' allows any user to access
        data without any form of authentication. Therefore, any person can create
        a user struct and view sensitive data.
      text: |-
        defmodule User do
          defstruct [:id, :data]
        end

        user = %User{id: 1, data: 'secret'}

        def access_data(user) do
          IO.puts user.data
        end
    language: elixir
    secure_code_example:
      description: The revised code introduces a secure authentication mechanism.
        The User struct now includes 'username' and 'password' fields. The 'login'
        function checks these credentials and returns a session if they are correct.
        The 'access_data' function now requires a successful login before accessing
        data, effectively preventing unauthorized access.
      text: |-
        defmodule User do
          defstruct [:id, :username, :password, :data]
        end

        user = %User{id: 1, username: 'user1', password: 'pass1', data: 'secret'}

        def login(user, username, password) do
          if user.username == username and user.password == password do
            {:ok, user}
          else
            {:error, 'Incorrect username or password.'}
          end
        end

        def access_data(user, username, password) do
          case login(user, username, password) do
            {:ok, user} -> IO.puts user.data
            _ -> IO.puts 'Access denied.'
          end
        end
    steps:
    - 'Introduce a secure authentication process: Implement a login mechanism that
      requires a username and password to create a user session.'
    - Ensure critical functionality resources are protected by this authentication
      process.
    - Ensure every request for these resources checks for an active and authenticated
      user session.
  title: Authentication Mechanism Absence or Evasion Vulnerability
  vulnerability_id: '006'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of plain maps for role management
  need: Prevent unauthorized access to information and operations
  solution:
    considerations:
    - This solution still has some shortcomings. Ideally, the list of admins would
      not be hardcoded but stored securely, and management of roles would be more
      flexible.
    - The token should be securely stored and transmitted, as possession of a token
      gives access to the associated user's privileges.
    insecure_code_example:
      description: This code represents a user system with different roles. An Elixir
        struct User is defined which holds an id, role, and data. However, due to
        the lack of a proper access control mechanism, a malicious user can easily
        manipulate their role in the User struct and escalate their privileges. For
        example, a user can change their role to 'admin' and gain access to sensitive
        data or actions they are not supposed to.
      text: |-
        defmodule User do
          defstruct [:id, :role, :data]
        end

        user = %User{id: 1, role: :admin, data: 'secret'}

        def execute_action(user, action) do
          if user.role == :admin do
            IO.puts 'Admin action executed!'
          else
            IO.puts 'User action executed!'
          end
        end
    language: elixir
    secure_code_example:
      description: This revised code introduces a secure token system for role management.
        It removes the 'role' field from the User struct and instead uses a list of
        admin user IDs. Also, the user struct now includes a token generated using
        :crypto.strong_rand_bytes. The token is used for identifying the user instead
        of the id, thus making it harder to manipulate. The function 'execute_action'
        checks if the user's id is in the list of admins before allowing an admin
        action.
      text: |-
        defmodule User do
          defstruct [:id, :token, :data]
        end

        admins = [1, 2, 3]

        user = %User{id: 1, token: :crypto.strong_rand_bytes(16), data: 'secret'}

        def execute_action(user, action) do
          if user.id in admins do
            IO.puts 'Admin action executed!'
          else
            IO.puts 'User action executed!'
          end
        end
    steps:
    - 'Implement proper access control: Ensure the role cannot be easily manipulated
      by a user.'
    - Roles should be controlled with users tokens or the exposure of user ID should
      be avoided.
    - Encrypt sensitive data and ensure it cannot be accessed without proper authorization.
  title: Privilege Escalation Vulnerability
  vulnerability_id: '005'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of os.cmd for executing shell commands
  need: Prevent unauthorized code or command execution
  solution:
    considerations:
    - This solution might not cover all possible exploit scenarios or harmful inputs.
      It's always better to avoid using external processes when possible.
    - Always keep as much data as possible used to generate the command outside of
      external control.
    insecure_code_example:
      description: In this code, the function 'run_command' takes user input and directly
        interpolates it into an OS command to be executed. This is a vulnerability
        because an attacker could manipulate the input to execute arbitrary commands
        on the OS, leading to unauthorized code execution. The function is not validating
        or sanitizing the input before use, which makes it susceptible to the vulnerability.
      text: |-
        def run_command(input) do
          :os.cmd("echo #{input}")
        end
    language: elixir
    secure_code_example:
      description: This code mitigates the vulnerability by first sanitizing the user
        input, removing or substituting characters that could modify the OS command.
        Then it verifies if the sanitized_input still is a binary string. If it isn't,
        it returns an error. Only if the input passes these checks, it's then used
        in the OS command.
      text: |-
        def run_command(input) do
          sanitized_input = String.replace(input, ~r/[\n\r\$()]/, "")
          case sanitized_input do
            ^sanitized_input when is_binary(sanitized_input) -> :os.cmd('echo ' <> sanitized_input)
            _ -> {:error, "Invalid input"}
          end
        end
    steps:
    - 'Validate user inputs: Check if the input is as expected. This could be a format,
      type, length, range, or a set of permitted values.'
    - 'Sanitize user inputs: Remove or substitute harmful patterns in the input.'
    - Instead of using external processes like :os.cmd, try using standard library
      calls to recreate the desired functionality.
  title: Remote Command Execution Vulnerability
  vulnerability_id: '004'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of X-Permitted-Cross-Domain-Policies header management
  need: To prevent harmful requests from Adobe Flash or PDF documents
  solution:
    considerations:
    - Changing the X-Permitted-Cross-Domain-Policies header may affect the application's
      behavior with Adobe products. This change should be implemented carefully, and
      all dependent services should be checked to ensure their functionality remains
      intact.
    - Not all browsers enforce the X-Permitted-Cross-Domain-Policies header. Therefore,
      this should not be the only mitigation strategy against cross-domain request
      attacks.
    insecure_code_example:
      description: In this Elixir code snippet, the application is lacking the X-Permitted-Cross-Domain-Policies
        header.
      text: |-
        defmodule Vulnerable do
          use Plug.Router

          plug :match
          plug :dispatch

          get "" do
            conn
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code snippet, the application is setting the X-Permitted-Cross-Domain-Policies
        header to 'none'.
      text: |-
        defmodule Secure do
          use Plug.Router

          plug :match
          plug :dispatch

          get "" do
            conn
            |> put_resp_header("x-permitted-cross-domain-policies", "none")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    steps:
    - Unless the application requires Adobe products, set the X-Permitted-Cross-Domain-Policies
      to none in the server responses.
  title: Insecure or unset HTTP headers - X-Permitted-Cross-Domain-Policies
  vulnerability_id: '137'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of X-XSS Protection header management for preventing cross-site scripting
    attacks
  need: To prevent the increase in the chance of exploiting a stored XSS
  solution:
    considerations:
    - Changing from X-XSS Protection header to CSP header might affect the accessibility
      of the application's resources. The change should be implemented with careful
      consideration.
    - The CSP header should be properly configured to prevent potential security threats.
    insecure_code_example:
      description: In this Elixir code snippet, the application is using the deprecated
        X-XSS Protection header.
      text: |-
        defmodule Vulnerable do
          use Plug.Router
          plug :put_secure_browser_headers

          plug :match
          plug :dispatch

          get "" do
            conn
            |> put_resp_header("x-xss-protection", "1; mode=block")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code snippet, the application is using CSP (Content
        Security Policy) header instead of the deprecated X-XSS Protection header.
      text: |-
        defmodule Secure do
          use Plug.Router
          plug :put_secure_browser_headers

          plug :match
          plug :dispatch

          get "" do
            conn
            |> put_resp_header("content-security-policy", "default-src 'self'")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    steps:
    - Disable the X-XSS Protection filter in the server responses.
    - Instead, define security policies using CSP (Content Security Policy) header.
  title: Insecure or unset HTTP headers - X-XSS Protection
  vulnerability_id: '135'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug, Cowboy, and CorsPlug for building a web server in Elixir
  - Usage of CORS headers management for handling cross-origin resource sharing
  need: To prevent the inclusion of resources from untrusted origins
  solution:
    considerations:
    - Changing the CORS policy may affect the accessibility of the application's resources
      from different domains. Therefore, the change should be implemented with careful
      consideration.
    - Even after setting a specific domain in the CORS policy, always validate the
      requests and responses to ensure they do not contain any malicious content.
    insecure_code_example:
      description: In this Elixir code snippet, the CORS policy is set to '*', allowing
        any domain to share resources.
      text: |-
        defmodule Vulnerable do
          use Plug.Router
          plug CORSPlug, origin: "*"

          plug :match
          plug :dispatch

          get "" do
            send_resp(conn, 200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code snippet, the CORS policy is explicitly set
        to a specific domain, preventing resource sharing with untrusted domains.
      text: |-
        defmodule Secure do
          use Plug.Router
          plug CORSPlug, origin: "https://trusted.domain.com"

          plug :match
          plug :dispatch

          get "" do
            send_resp(conn, 200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    steps:
    - Remove the wildcard (*) from the CORS policy.
    - Explicitly define the trusted origins for the application resources.
  title: Insecure or unset HTTP headers - CORS
  vulnerability_id: '134'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of HTTP headers management
  need: To prevent MIME sniffing attacks
  solution:
    considerations:
    - Setting the X-Content-Type-Options header does not prevent all types of attacks.
      Ensure to use secure coding practices and regularly update your dependencies.
    - The use of the X-Content-Type-Options header may affect the performance of the
      application. Therefore, use it with careful consideration.
    insecure_code_example:
      description: In this Elixir code snippet, the server response doesn't include
        the X-Content-Type-Options header, making the application vulnerable to MIME
        sniffing attacks.
      text: |-
        defmodule Vulnerable do
          use Plug.Router

          plug :match
          plug :dispatch

          get "" do
            conn
            |> put_resp_content_type("text/html")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code snippet, the server response includes the X-Content-Type-Options
        header with a value of nosniff, preventing MIME type sniffing by the browser.
      text: |-
        defmodule Secure do
          use Plug.Router

          plug :match
          plug :dispatch

          get "" do
            conn
            |> put_resp_content_type("text/html")
            |> put_resp_header("x-content-type-options", "nosniff")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    steps:
    - Set the X-Content-Type-Options header in the server responses.
    - Set this header to nosniff to disable MIME type sniffing.
  title: Insecure or unset HTTP headers - X-Content-Type-Options
  vulnerability_id: '132'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of HTTP headers management
  need: To enforce the use of HTTPS to prevent confidential information from being
    sent over insecure channels
  solution:
    considerations:
    - Setting the Strict-Transport-Security header does not prevent all types of attacks.
      Ensure to use secure coding practices and regularly update your dependencies.
    - The use of the Strict-Transport-Security header may affect the performance of
      the application. Therefore, set the max-age with careful consideration.
    insecure_code_example:
      description: In this Elixir code snippet, the server response doesn't include
        the Strict-Transport-Security header, making the application vulnerable to
        attacks such as MiTM.
      text: |-
        defmodule Vulnerable do
          use Plug.Router

          plug :match
          plug :dispatch

          get "" do
            conn
            |> put_resp_content_type("text/html")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code snippet, the server response includes the Strict-Transport-Security
        header with a max-age of one year, ensuring that the browser only communicates
        with the server over HTTPS for the specified time.
      text: |-
        defmodule Secure do
          use Plug.Router

          plug :match
          plug :dispatch

          get "" do
            conn
            |> put_resp_content_type("text/html")
            |> put_resp_header("strict-transport-security", "max-age=31536000")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    steps:
    - Set the Strict-Transport-Security header in the server responses.
    - Set the max-age of this header to at least 31536000 (one year).
  title: Insecure or unset HTTP headers - Strict Transport Security
  vulnerability_id: '131'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of secure cookie handling for session management
  need: To protect sensitive cookies from being sent over insecure channels
  solution:
    considerations:
    - Setting the Secure attribute does not prevent all types of attacks. Be sure
      to use secure coding practices and regularly update your dependencies.
    - In addition to setting Secure, you should also set the HttpOnly and SameSite
      attributes for cookies.
    insecure_code_example:
      description: In this Elixir code snippet, a cookie is being set without the
        Secure attribute, making it susceptible to being sent over insecure channels.
      text: |-
        defmodule Vulnerable do
          use Plug.Router

          plug :match
          plug :dispatch

          post "" do
            conn
            |> put_resp_cookie("sensitive_info", "some_value")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code snippet, the cookie is set with the Secure
        attribute, ensuring it will only be sent over secure channels.
      text: |-
        defmodule Secure do
          use Plug.Router

          plug :match
          plug :dispatch

          post "" do
            conn
            |> put_resp_cookie("sensitive_info", "some_value", secure: true)
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    steps:
    - Set the Secure attribute while setting the cookies.
    - Only send cookies over HTTPS.
  title: Insecurely generated cookies - Secure
  vulnerability_id: '130'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of secure cookie handling
  need: To protect cookies from being sent along with cross-site requests
  solution:
    considerations:
    - Setting the SameSite attribute does not prevent all types of attacks. Be sure
      to use secure coding practices and regularly update your dependencies.
    - In addition to setting SameSite, you should also set the Secure and HttpOnly
      attributes for cookies if your site is served over HTTPS.
    insecure_code_example:
      description: In this Elixir code snippet, a cookie is being set without the
        SameSite attribute, making it susceptible to being sent along with cross-site
        requests.
      text: |-
        defmodule Vulnerable do
          use Plug.Router

          plug :match
          plug :dispatch

          post "" do
            conn
            |> put_resp_cookie("sensitive_info", "some_value")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code snippet, the cookie is set with the SameSite
        attribute set to 'Strict', protecting it from being sent along with cross-site
        requests.
      text: |-
        defmodule Secure do
          use Plug.Router

          plug :match
          plug :dispatch

          post "" do
            conn
            |> put_resp_cookie("sensitive_info", "some_value", same_site: "Strict")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    steps:
    - Set the SameSite attribute to 'Strict' or 'Lax' while setting the cookies.
    - Do not store sensitive information in cookies if possible.
  title: Insecurely generated cookies - SameSite
  vulnerability_id: '129'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of secure cookie handling for session management
  need: To protect cookies from being accessed by client-side scripts
  solution:
    considerations:
    - Setting the HttpOnly attribute does not prevent all types of attacks. Be sure
      to use secure coding practices and regularly update your dependencies.
    - In addition to setting HttpOnly, you should also set the Secure attribute for
      cookies if your site is served over HTTPS.
    insecure_code_example:
      description: In this Elixir code snippet, a cookie is being set without the
        HttpOnly attribute, making it susceptible to being read by client-side scripts.
      text: |-
        defmodule Vulnerable do
          use Plug.Router

          plug :match
          plug :dispatch

          post "" do
            conn
            |> put_resp_cookie("sensitive_info", "some_value")
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code snippet, the cookie is set with the HttpOnly
        attribute set to true, protecting it from being read by client-side scripts.
      text: |-
        defmodule Secure do
          use Plug.Router

          plug :match
          plug :dispatch

          post "" do
            conn
            |> put_resp_cookie("sensitive_info", "some_value", http_only: true)
            |> send_resp(200, "OK")
          end

          match _ do
            send_resp(conn, 404, "Not found")
          end
        end
    steps:
    - Set the HttpOnly attribute to true while setting the cookies.
    - Do not store sensitive information in cookies if possible.
  title: Insecurely generated cookies - HttpOnly
  vulnerability_id: '128'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of input validation for data validation and sanitization
  - Usage of type casting for ensuring type safety in TypeScript
  need: Prevent misinterpretation of data types and code injection
  solution:
    considerations:
    - Always ensure to validate the type of data you receive from user inputs.
    - Proper handling of user input is crucial to prevent type confusion and potential
      code execution.
    insecure_code_example:
      description: This Elixir code is vulnerable because it directly uses the user
        input without validating its type. This can lead to type confusion and potentially
        code execution.
      text: |-
        defmodule Vulnerable do
          def process(input) do
            {:ok, number} = Integer.parse(input)
            IO.puts(number)
          end
        end
    language: elixir
    secure_code_example:
      description: This Elixir code is safe because it validates the type of the input
        data before using it, preventing type confusion and potential code execution.
      text: |-
        defmodule Safe do
          def process(input) do
            case Integer.parse(input) do
              :error -> IO.puts('Invalid input')
              {:ok, number} -> IO.puts(number)
            end
          end
        end
    steps:
    - Always validate the type of data you receive from user input.
    - Cast the data to the desired type before using it.
  title: Lack of data validation - Type confusion
  vulnerability_id: '127'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of Concurrency for parallel execution of tasks
  - Usage of process synchronization for managing concurrent execution
  need: Prevent arbitrary overwriting, deletion or reading of files due to incorrect
    input sequencing
  solution:
    considerations:
    - Always ensure that operations that should be atomic are performed in a single
      process to prevent race conditions.
    - Proper handling of concurrency is crucial to prevent race conditions.
    insecure_code_example:
      description: This Elixir code is vulnerable because it does not handle the concurrent
        operations properly, leading to a race condition where the file might be read
        and deleted by two different processes at the same time.
      text: |-
        defmodule RaceCondition do
          def process(file) do
            Task.async(fn -> File.read!(file) end)
            Task.async(fn -> File.rm!(file) end)
          end
        end
    language: elixir
    secure_code_example:
      description: This Elixir code is safe because it ensures that the reading and
        deletion of a file are performed in a single process, preventing a race condition.
      text: |-
        defmodule RaceCondition do
          def process(file) do
            File.read!(file)
            File.rm!(file)
          end
        end
    steps:
    - Ensure that operations that should be atomic are performed in a single process
      to prevent race conditions.
    - Handle concurrency properly to prevent the interleaving of operations.
  title: Race Condition
  vulnerability_id: '124'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications with Elixir
  - Usage of file handling for reading, writing, and manipulating files
  - Usage of path sanitization for preventing directory traversal attacks
  need: Prevent reading or executing server files through relative path manipulation
  solution:
    considerations:
    - Always sanitize file paths provided by users to prevent local file inclusion
      attacks.
    - Ensure that the file path is within the expected directory and does not allow
      traversal to parent directories.
    insecure_code_example:
      description: This Elixir code is vulnerable because it does not sanitize the
        file path provided by the user, allowing local file inclusion attacks.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/file" do
            file_path = conn.params["path"]
            file_contents = File.read!(file_path)
            send_resp(conn, 200, file_contents)
          end

          match _ do
            send_resp(conn, 404, "Oops, not found!")
          end
        end
    language: elixir
    secure_code_example:
      description: This Elixir code is safe because it includes validation and sanitization
        of the file path. It checks that the file path is within the expected directory
        and does not contain relative path characters.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/file" do
            file_path = conn.params["path"]
            sanitized_path = Path.expand(file_path, "/expected_directory")
            if String.starts_with?(sanitized_path, "/expected_directory") do
              file_contents = File.read!(sanitized_path)
              send_resp(conn, 200, file_contents)
            else
              send_resp(conn, 403, "Access Denied")
            end
          end

          match _ do
            send_resp(conn, 404, "Oops, not found!")
          end
        end
    steps:
    - Sanitize the file path to remove any relative path characters.
    - Ensure that the file path is within the expected directory.
  title: Local File Inclusion
  vulnerability_id: '123'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications in Elixir
  - Usage of HTTP parameter validation
  - Usage of input sanitization for protecting against malicious user input
  need: Prevent unexpected behavior due to injection of extra HTTP parameters
  solution:
    considerations:
    - Always validate and sanitize incoming parameters to prevent unexpected behavior
      due to HTTP parameter pollution.
    - The sanitization method will depend on the nature of your application and how
      it is used. You may need to adjust this over time as your usage patterns change.
    insecure_code_example:
      description: This Elixir code is vulnerable because it does not perform validation
        and sanitization on the incoming parameters. This allows injection of extra
        parameters which can cause unexpected behavior.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/" do
            send_resp(conn, 200, "Hello, #{conn.params["name"]}")
          end

          match _ do
            send_resp(conn, 404, "Oops, not found!")
          end
        end
    language: elixir
    secure_code_example:
      description: This Elixir code is safe because it includes validation and sanitization
        of incoming parameters. It checks that the 'name' parameter exists and removes
        any potential harmful data.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/" do
            name = Map.get(conn.params, "name", "")
            name = String.replace(name, "<>", "")
            send_resp(conn, 200, "Hello, #{name}")
          end

          match _ do
            send_resp(conn, 404, "Oops, not found!")
          end
        end
    steps:
    - Validate the incoming parameters to ensure they are as expected.
    - Sanitize the parameters to remove any potential harmful data.
  title: HTTP Parameter Pollution
  vulnerability_id: '121'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Cowboy for building web applications with Elixir
  - Handling high incoming requests
  - Usage of API abuse detection and prevention techniques
  need: Prevent denial of service or system overloading by limiting request rate
  solution:
    considerations:
    - Always implement rate limiting in your API to prevent abuse and potential denial
      of service attacks.
    - The specific rate limit will depend on the nature of your API and how it is
      used. You may need to adjust this over time as your usage patterns change.
    insecure_code_example:
      description: This Elixir code is vulnerable because it exposes an API endpoint
        without any rate limiting. This allows a host to send unlimited requests.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/" do
            send_resp(conn, 200, "Hello, world!")
          end

          match _ do
            send_resp(conn, 404, "Oops, not found!")
          end
        end
    language: elixir
    secure_code_example:
      description: This Elixir code is safe because it includes 'plug_attack' for
        rate limiting. The plug is configured to limit requests to 100 per minute
        from a single IP address.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug PlugAttack

          plug_attack_handler do
            PlugAttack.Storage.Memory.set_rules([%{bans: 100, period: 60_000}])
          end

          plug :match
          plug :dispatch

          get "/" do
            send_resp(conn, 200, "Hello, world!")
          end

          match _ do
            send_resp(conn, 404, "Oops, not found!")
          end
        end
    steps:
    - Add a rate limiting package, such as 'plug_attack'.
    - Configure the rate limit rules in the 'plug_attack' config.
  title: Security Controls Bypass or Absence
  vulnerability_id: '115'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of dynamically typed language
  need: To prevent errors and potential security issues caused by assigning the wrong
    type of value to a variable
  solution:
    considerations:
    - Elixir is a dynamically typed language, so type checking is performed at runtime.
    - Always validate the type of a variable before using it, especially if it contains
      user-supplied input.
    - Be aware of how different types of values behave in different contexts, and
      handle unexpected types gracefully to prevent errors.
    insecure_code_example:
      description: This Elixir code is vulnerable because it assigns a string to a
        variable that is expected to be a number. If a string is supplied instead
        of a number, an error will occur when trying to perform an arithmetic operation.
      text: |-
        defmodule VulnerableCode do
          def add_one(input) do
            input + 1
          end
        end
    language: elixir
    secure_code_example:
      description: This Elixir code is safe because it checks the type of the input
        before performing the arithmetic operation. If the input is not a number,
        an error message is returned instead of causing a runtime error.
      text: |-
        defmodule SecureCode do
          def add_one(input) when is_number(input) do
            input + 1
          end

          def add_one(_input) do
            {:error, "Input must be a number"}
          end
        end
    steps:
    - Perform type checking before using the variable.
    - Handle the error case when the value is not of the expected type.
  title: Improper Type Assignation
  vulnerability_id: '113'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir Plug for handling HTTP requests and protecting against attacks
  - No rate limiting for API requests
  need: To prevent server saturation and potential Denial of Service (DoS) attacks
  solution:
    considerations:
    - This solution assumes that you are using the `Plug` library in Elixir and the
      `plug_attack` library for rate limiting.
    - The rate limit rules need to be defined in the configuration of your application.
      Consider your application's capacity and requirements when defining these rules.
    insecure_code_example:
      description: The following Elixir code exposes an API endpoint without any rate
        limiting, allowing clients to send as many requests as they want in a short
        period of time. This makes the application vulnerable to DoS attacks and log
        flooding.
      text: |-
        defmodule VulnerableApp.ApiController do
          use Plug.Router

          def index(conn, _params) do
            # API logic here
            send_resp(conn, 200, "OK")
          end

          plug :match
          plug :dispatch

          get "/", do: index(conn, params)
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code uses the 'plug_attack' library to implement
        rate limiting on the API endpoint. This prevents clients from sending too
        many requests in a short period of time, protecting the application from DoS
        attacks and log flooding.
      text: |-
        defmodule SecureApp.ApiController do
          use Plug.Router
          use PlugAttack

          plug PlugAttack.Blocker, otp_app: :my_app, name: :api

          def index(conn, _params) do
            # API logic here
            send_resp(conn, 200, "OK")
          end

          plug :match
          plug :dispatch

          get "/", do: index(conn, params)

          defoverridable [block: 2]
          def block(conn, _opts), do: send_resp(conn, 429, "Too Many Requests")
        end
    steps:
    - Use the 'plug_attack' library or similar to implement rate limiting on your
      API endpoints.
    - Define rate limit rules based on your application's requirements and capacity.
    - Apply these rules to your API endpoints.
  title: Improper Control of Interaction Frequency
  vulnerability_id: '108'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir Phoenix Ecto for building web applications with a functional programming
    language and a reliable database layer
  - User registration with email verification
  need: To prevent multiple account creation with the same email address
  solution:
    considerations:
    - This solution assumes that you are using the `Phoenix` web framework and `Ecto`
      for database operations.
    - The '+' character trick is specific to certain email providers. Other email
      providers may use different mechanisms for aliasing or sub-addressing.
    - Make sure to handle the case when the email is already registered.
    insecure_code_example:
      description: The following Elixir code accepts the email from an untrusted source
        and creates a user account without properly validating the uniqueness of the
        email address. This allows an attacker to create multiple accounts with the
        same email.
      text: |-
        defmodule VulnerableApp.UserController do
          use VulnerableApp.Web, :controller

          def register(conn, %{"email" => email, "password" => password}) do
            User.changeset(%User{}, %{email: email, password: password}) |> Repo.insert()
            send_resp(conn, 200, "User registered successfully")
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code normalizes the email address by removing
        any characters after and including the '+' sign in the local part, and then
        checks the uniqueness of the email address before creating a user account.
        This prevents an attacker from creating multiple accounts with the same email.
      text: |-
        defmodule SecureApp.UserController do
          use SecureApp.Web, :controller

          def register(conn, %{"email" => email, "password" => password}) do
            normalized_email = normalize_email(email)
            changeset = User.changeset(%User{}, %{email: normalized_email, password: password}) |> Ecto.Changeset.unique_constraint(:email)
            case Repo.insert(changeset) do
              {:ok, _} -> send_resp(conn, 200, "User registered successfully")
              {:error, _} -> send_resp(conn, 400, "Email already registered")
            end
          end

          defp normalize_email(email) do
            [local, domain] = String.split(email, "@")
            local = String.split(local, "+") |> List.first()
            local <> "@" <> domain
          end
        end
    steps:
    - Use Ecto's `unique_constraint` function in the changeset to enforce uniqueness
      at the database level.
    - Normalize the email address before saving it to the database. Remove any characters
      after and including the '+' sign in the local part of the email address.
  title: Email Uniqueness Not Properly Verified
  vulnerability_id: '102'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir Phoenix Plug for building web applications
  - Usage of file-upload handling for untrusted sources
  need: To prevent unauthorized access and alteration of system files
  solution:
    considerations:
    - This solution assumes that you are using the `Phoenix` web framework and the
      `plug` library for handling file uploads.
    - Make sure the upload directory is outside of the web server's document root
      to prevent direct access to the uploaded files.
    - Avoid revealing any internal file paths or names in error messages.
    insecure_code_example:
      description: The following Elixir code receives an uploaded file and its filename
        from an untrusted source and directly uses the given filename to save the
        file. This leaves the application open to manipulation from an attacker.
      text: |-
        defmodule VulnerableApp.FileUploadController do
          use VulnerableApp.Web, :controller

          def upload(conn, %{"file" => file, "filename" => filename}) do
            File.write(filename, file)
            send_resp(conn, 200, "File uploaded successfully")
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code receives an uploaded file from an untrusted
        source, generates a new filename and saves the file to a specified directory.
        This prevents an attacker from manipulating the file name or path.
      text: |-
        defmodule SecureApp.FileUploadController do
          use SecureApp.Web, :controller

          def upload(conn, %{"file" => file}) do
            filename = generate_filename()
            File.write("uploads/" <> filename, file)
            send_resp(conn, 200, "File uploaded successfully")
          end

          defp generate_filename() do
            :crypto.strong_rand_bytes(20) |> Base.url_encode64()
          end
        end
    steps:
    - Use a library such as `plug` to handle file uploads securely.
    - Do not use the original filename from the user. Generate a new filename on the
      server side.
    - Restrict the storage of uploaded files to a specific directory.
  title: External Control of File Name or Path
  vulnerability_id: '098'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir Phoenix for building web applications
  - Usage of serialization/deserialization libraries for handling serialized objects
    from untrusted sources
  need: To protect against unauthorized control of application execution flow
  solution:
    considerations:
    - This solution assumes that you are using the `Phoenix` web framework and the
      `Jason` library for JSON parsing.
    - Ensure the deserialization process does not leak any sensitive information or
      error messages to the end user.
    insecure_code_example:
      description: The following Elixir code deserializes an incoming object from
        an untrusted source without validating or casting it. This leaves the application
        open to manipulation from an attacker.
      text: |-
        defmodule VulnerableApp.WebController do
          use VulnerableApp.Web, :controller

          def deserialize(conn, _params) do
            {:ok, params} = Poison.decode(conn.params["payload"])
            process_params(params)
          end

          defp process_params(params) do
            # Handle params...
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code deserializes an incoming object from
        an untrusted source but first validates it. This prevents an attacker from
        manipulating the execution flow of the application.
      text: |-
        defmodule SecureApp.WebController do
          use SecureApp.Web, :controller

          def deserialize(conn, _params) do
            case Jason.decode(conn.params["payload"]) do
              {:ok, params} when is_map(params) ->
                process_params(params)
              _ ->
                {:error, "Invalid payload"}
            end
          end

          defp process_params(params) do
            # Handle params...
          end
        end
    steps:
    - Use a library such as `jason` to validate the structure of the incoming serialized
      object.
    - Only deserialize the object if it meets the expected properties.
  title: Insecure Deserialization
  vulnerability_id: '096'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir Ecto for database query and manipulation
  - Usage of unique tokens for database record identification
  need: To ensure that sensitive data intended for single use cannot be reused or
    regenerated.
  solution:
    considerations:
    - This solution assumes that you are using Ecto as your database wrapper and changeset
      for data validation.
    - Make sure to generate tokens that are sufficiently random and long to prevent
      attackers from guessing them.
    - You should handle the unique violation error in a way that doesn't leak sensitive
      information to the user.
    insecure_code_example:
      description: The following Elixir code creates a user record with a unique token
        but does not validate the uniqueness of the token. This means that an attacker
        could create multiple users with the same token, leading to potential security
        issues.
      text: |-
        defmodule VulnerableApp.Accounts do
          alias VulnerableApp.Repo
          alias VulnerableApp.Accounts.User

          def create_user(attrs \ %{}) do
            %User{}
            |> User.changeset(attrs)
            |> Repo.insert()
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code creates a user record with a unique token
        and validates the uniqueness of the token. This prevents an attacker from
        creating multiple users with the same token.
      text: |-
        defmodule SecureApp.Accounts do
          alias SecureApp.Repo
          alias SecureApp.Accounts.User

          def create_user(attrs \ %{}) do
            %User{}
            |> User.changeset(attrs)
            |> Ecto.Changeset.unique_constraint(:token)
            |> Repo.insert()
          rescue
            Ecto.ConstraintError -> {:error, "Token must be unique"}
          end
        end
    steps:
    - Use Ecto's unique constraint feature to ensure that the token is unique across
      all users.
    - Handle Ecto's unique violation error when inserting a new user.
  title: Data Uniqueness Not Properly Verified
  vulnerability_id: '095'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir CSV library for handling CSV files
  - Exporting user-provided data to CSV files
  need: To protect against malicious injection of formulas into fields that are exported
    as part of CSV files and potentially interpreted by Excel or other spreadsheet
    software.
  solution:
    considerations:
    - This mitigation strategy will not work if your CSV data needs to include valid
      formulas. In that case, consider other ways of validating and sanitizing user-provided
      data to prevent malicious injections.
    - This solution assumes that the user-provided data is a list of lists, where
      each inner list represents a row of the CSV data. The actual structure of your
      data may vary.
    insecure_code_example:
      description: The following Elixir code writes user-provided data directly to
        a CSV file without sanitization. This allows a user to inject a formula, which
        could be executed when the CSV file is opened in a spreadsheet software.
      text: |-
        defmodule VulnerableApp do
          def create_csv(data, filename) do
            {:ok, file} = File.open(filename, [:write])
            Enum.each(data, fn row ->
              IO.write(file, Enum.join(row, ",") <> "\n")
            end)
            File.close(file)
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code sanitizes user-provided data by prepending
        any field starting with '=', '+', '-', '@' with a single quote, before writing
        it to a CSV file. This prevents any injected formulas from being interpreted
        by spreadsheet software.
      text: |-
        defmodule SecureApp do
          def create_csv(data, filename) do
            {:ok, file} = File.open(filename, [:write])
            Enum.each(data, fn row ->
              sanitized_row = Enum.map(row, &sanitize_field/1)
              IO.write(file, Enum.join(sanitized_row, ",") <> "\n")
            end)
            File.close(file)
          end

          defp sanitize_field(field) when is_binary(field) do
            if String.starts_with?(field, ["=", "+", "-", "@"]) do
              "'" <> field
            else
              field
            end
          end
          defp sanitize_field(field), do: field
        end
    steps:
    - Sanitize user-provided data before exporting it to a CSV file.
    - If the data includes numbers or strings that start with '=', '+', '-', '@',
      consider prepending the string with a single quote (') to prevent spreadsheet
      software from interpreting it as a formula.
  title: CSV injection
  vulnerability_id: '090'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of user-provided data without validation
  need: To prevent potential security vulnerabilities due to trusting and mixing untrusted
    data in the same data structure or structured message.
  solution:
    considerations:
    - Input validation and sanitization should be applied to all user-provided data,
      regardless of where it comes from (form submissions, query parameters, HTTP
      headers, cookies, etc.).
    - Be aware of potential false positives and false negatives in input validation
      and sanitization. Regularly update your validation and sanitization rules to
      cover the latest attack vectors.
    insecure_code_example:
      description: This Elixir code directly includes user-provided data in a structured
        message without any validation or sanitization. An attacker can potentially
        manipulate the message to introduce malicious payloads.
      text: |-
        defmodule VulnerableApp do
          def handle_request(params) do
            {:ok, message} = build_message(params)
            send_message(message)
          end

          defp build_message(params) do
            {:ok, "Hello #{params[:name]}, your account balance is #{params[:balance]}"}
          end
        end
    language: elixir
    secure_code_example:
      description: This Elixir code validates and sanitizes user-provided data before
        including it in a structured message, thereby preventing potential injection
        attacks.
      text: |-
        defmodule SecureApp do
          def handle_request(params) do
            sanitized_params = sanitize(params)
            case validate(sanitized_params) do
              :ok -> {:ok, message} = build_message(sanitized_params)
                       send_message(message)
              {:error, reason} -> {:error, reason}
            end
          end

          defp build_message(params) do
            {:ok, "Hello #{params[:name]}, your account balance is #{params[:balance]}"}
          end
        end
    steps:
    - Validate user-provided data before including it in structured messages or data
      structures.
    - Sanitize user-provided data to remove any potentially malicious payloads.
    - Consider using parameterized queries or prepared statements for database operations
      to prevent SQL Injection attacks.
  title: Lack of data validation - Trust boundary violation
  vulnerability_id: '089'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of user lockout feature for failed authentication attempts
  need: To prevent potential denial of service for valid users via account lockouts.
  solution:
    considerations:
    - Avoiding account lockouts entirely may increase the risk of brute force attacks.
      A balanced approach is necessary to protect user accounts while avoiding potential
      denial of service.
    - Consider using multi-factor authentication to further protect user accounts
      from unauthorized access.
    insecure_code_example:
      description: This code accepts user credentials and locks the user account after
        three failed login attempts. An attacker could exploit this by purposely failing
        login attempts for a targeted user, effectively locking them out of their
        account.
      text: |-
        defmodule VulnerableApp do
          def login(user, password) do
            case authenticate(user, password) do
              :ok -> {:ok, get_user(user)}
              {:error, :invalid_credentials} -> update_failed_attempts(user)
            end
          end

          defp update_failed_attempts(user) do
            user
            |> increment_failed_attempts()
            |> case do
              %{failed_attempts: 3} -> lock_account(user)
              _ -> :ok
            end
          end
        end
    language: elixir
    secure_code_example:
      description: This code implements a progressive delay after each failed login
        attempt, slowing down potential brute force attacks without locking out legitimate
        users. It also sends a notification to the user when their account is locked,
        providing a way for legitimate users to unlock their account.
      text: |-
        defmodule SecureApp do
          def login(user, password) do
            case authenticate(user, password) do
              :ok -> {:ok, get_user(user)}
              {:error, :invalid_credentials} -> update_failed_attempts(user)
            end
          end

          defp update_failed_attempts(user) do
            user
            |> increment_failed_attempts()
            |> case do
              %{failed_attempts: 3} -> notify_user_and_lock_account(user)
              _ -> :ok
            end
          end
        end
    steps:
    - Implement a delay after each failed authentication attempt, which increases
      with each attempt. This slows down brute force attacks without locking out legitimate
      users.
    - Use a CAPTCHA after a certain number of failed attempts to prevent automated
      brute force attacks.
    - Notify users via email or SMS when their account is locked out due to failed
      login attempts, and provide them with a way to unlock their account.
  title: Account Lockout
  vulnerability_id: '087'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of sweet_xml for parsing and manipulating XML data
  - 'Vulnerability: XML input parsing without proper sanitization'
  need: To prevent potential data exfiltration or remote command execution via XML
    input.
  solution:
    considerations:
    - Always sanitize and validate input, especially if it will be parsed or interpreted
      in any way.
    - Consider using JSON instead of XML if possible, as it is less prone to these
      types of attacks.
    insecure_code_example:
      description: This code accepts and parses XML input using the SweetXml library
        without validating or sanitizing the input. As a result, an attacker could
        inject malicious XML data.
      text: |-
        defmodule VulnerableApp do
          def parse(xml) do
            xml
            |> SweetXml.parse()
            |> SweetXml.xpath(~x/data)
          end
        end
    language: elixir
    secure_code_example:
      description: This code properly sanitizes the XML input before parsing it and
        is configured to reject DTDs, mitigating the risk of XML injection attacks.
      text: |-
        defmodule SecureApp do
          def parse(xml) do
            xml
            |> sanitize_input()
            |> SweetXml.parse()
            |> SweetXml.xpath(~x/data)
          end

          defp sanitize_input(xml) do
            # Add your sanitization logic here
          end
        end
    steps:
    - Use a secure XML parser that is configured to reject DTDs (Document Type Definitions).
    - Sanitize and validate all XML input to ensure it does not contain any unexpected
      or malicious data.
  title: XML injection (XXE)
  vulnerability_id: '083'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug.Session for HTTP session management
  - Usage of session token reuse in server even after user logout
  need: To prevent unauthorized access and potential misuse of session tokens.
  solution:
    considerations:
    - Always ensure session tokens are invalidated when a user logs out.
    - Consider using a secure and tested library for session management, rather than
      implementing it yourself.
    insecure_code_example:
      description: This code sets up a session using Plug.Session. However, when a
        user logs out, their session is not properly invalidated, leaving it vulnerable
        to misuse.
      text: |-
        defmodule VulnerableApp do
          use Plug.Router

          plug Plug.Session, store: :cookie

          plug :match
          plug :dispatch

          get "/logout" do
            conn
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Logged out!")
          end
        end
    language: elixir
    secure_code_example:
      description: This code correctly invalidates the session when the user logs
        out, preventing further use of their session token.
      text: |-
        defmodule SecureApp do
          use Plug.Router

          plug Plug.Session, store: :cookie

          plug :match
          plug :dispatch

          get "/logout" do
            conn
            |> delete_session(:user)
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Logged out!")
          end
        end
    steps:
    - When a user logs out, their session should be invalidated to prevent further
      use of their session token.
    - This can be done using the Plug.Conn.delete_session/2 function, which removes
      the session data from the client.
  title: Insecure session management
  vulnerability_id: '076'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug.Session for managing session data in Elixir applications
  - Usage of a server with indefinite session persistence
  need: Prevent unauthorized access to user information and actions.
  solution:
    considerations:
    - Remember to always set an expiration time for sessions to prevent unauthorized
      access.
    - Consider using a shorter timeout for more sensitive applications.
    insecure_code_example:
      description: This code uses the Plug.Session to manage sessions but does not
        set a timeout for session expiration. This means that sessions will remain
        active indefinitely, which can be exploited by an attacker.
      text: |-
        defmodule VulnerableApp do
          use Plug.Router

          plug Plug.Session, store: :cookie

          plug :match
          plug :dispatch

          get "/" do
            conn
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Hello world!")
          end
        end
    language: elixir
    secure_code_example:
      description: This code correctly sets a timeout for session expiration using
        the 'expires' option in the Plug.Session plug. After 5 minutes of inactivity,
        sessions will expire and cannot be used again, preventing unauthorized access.
      text: |-
        defmodule SecureApp do
          use Plug.Router

          plug Plug.Session, store: :cookie, expires: 5 * 60

          plug :match
          plug :dispatch

          get "/" do
            conn
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Hello world!")
          end
        end
    steps:
    - Use the 'expires' option in the Plug.Session plug to set a timeout for session
      expiration.
    - Set the timeout to a reasonable value, such as 5 minutes.
  title: Insecure session expiration time
  vulnerability_id: '068'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  - File access or operations based on user-supplied path
  need: Prevent unauthorized access to files and directories outside the intended
    path scope.
  solution:
    considerations:
    - Consider using a library or built-in function to sanitize paths.
    - Ensure that file operations run with minimal necessary privileges to mitigate
      the potential damage from a path traversal attack.
    - Regularly review and update your file access policies and validation logic.
    insecure_code_example:
      description: This code takes a user-supplied path to read a file without validating
        or sanitizing the input, allowing an attacker to access files outside the
        intended directory.
      text: |-
        defmodule VulnerableApp do
          use Plug.Router

          plug :match
          plug :dispatch

          get '/read_file' do
            path = conn.params['path']
            file_content = File.read!(path)
            send_resp(conn, 200, file_content)
          end
        end
    language: elixir
    secure_code_example:
      description: This code validates and sanitizes the user-supplied path before
        reading the file, effectively preventing path traversal attacks.
      text: |-
        defmodule SecureApp do
          use Plug.Router

          plug :match
          plug :dispatch

          get '/read_file' do
            path = conn.params['path']
            if valid_path?(path) do
              file_content = File.read!(path)
              send_resp(conn, 200, file_content)
            else
              send_resp(conn, 400, 'Bad Request')
            end
          end

          defp valid_path?(path) do
            # Add your path validation logic here
          end
        end
    steps:
    - Always validate and sanitize user-supplied input.
    - Prevent the user from supplying the full path; consider using identifiers to
      reference files or directories.
    - Use a whitelist of allowed paths or files.
    - Check for path traversal sequences (.., ~, /) in the user input and neutralize
      them.
  title: Lack of data validation - Path Traversal
  vulnerability_id: '063'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  - Improperly set Referrer-Policy HTTP header in the server
  need: Prevent website domain and path from being leaked to external services.
  solution:
    considerations:
    - Remember to always set secure HTTP headers.
    - Even though this sets the Referrer-Policy header to a secure setting, remember
      to also set other HTTP headers to secure settings as well.
    insecure_code_example:
      description: This code sets up a simple Plug router to handle HTTP requests,
        but it does not set the Referrer-Policy header, potentially allowing the website's
        domain and path to be leaked.
      text: |-
        defmodule VulnerableApp do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/" do
            conn
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Hello world!")
          end
        end
    language: elixir
    secure_code_example:
      description: This code correctly sets the Referrer-Policy HTTP header to 'strict-origin',
        which ensures that the referrer will only be sent to same-protocol security
        destinations, thus preventing the website's domain and path from being leaked.
      text: |-
        defmodule SecureApp do
          use Plug.Router

          plug Plug.ReferrerPolicy, policy: :strict_origin

          plug :match
          plug :dispatch

          get "/" do
            conn
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Hello world!")
          end
        end
    steps:
    - 'Add the ''plug Plug.ReferrerPolicy, policy: :strict_origin'' line to your router
      to set the Referrer-Policy header'
    - The :strict_origin policy option will only send the referrer to same-protocol
      security destinations.
  title: Insecure or unset HTTP headers - Referrer-Policy
  vulnerability_id: '071'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and concurrent applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  - Session management for user data
  need: Prevent multiple simultaneous sessions from the same user account to maintain
    traceability and non-repudiation of user actions.
  solution:
    considerations:
    - Consider using a session management library or framework feature to handle session
      tracking.
    - Always use secure session handling practices, such as HTTPS and secure cookies.
    - Regularly review session management settings to ensure they meet your application's
      security needs.
    insecure_code_example:
      description: This code creates a new session for a user every time they log
        in, even if they already have an active session. This could lead to Concurrent
        Sessions.
      text: |-
        defmodule VulnerableApp do
          use Plug.Router

          plug :match
          plug :dispatch

          post '/login' do
            user = authenticate_user(conn.params['username'], conn.params['password'])
            if user do
              session = start_session(user)
              send_resp(conn, 200, 'Logged in')
            else
              send_resp(conn, 401, 'Unauthorized')
            end
          end
        end
    language: elixir
    secure_code_example:
      description: This code prevents concurrent sessions by checking if a user already
        has an active session when they try to log in. If they do, it ends the existing
        session before creating a new one.
      text: |-
        defmodule SecureApp do
          use Plug.Router

          plug :match
          plug :dispatch

          post '/login' do
            user = authenticate_user(conn.params['username'], conn.params['password'])
            if user do
              end_existing_session(user)
              session = start_session(user)
              send_resp(conn, 200, 'Logged in')
            else
              send_resp(conn, 401, 'Unauthorized')
            end
          end
        end
    steps:
    - Track the number of active sessions for each user.
    - If a user tries to create a new session while they already have one, end the
      existing session or deny the creation of a new one.
    - Notify the user when a new session is created from a different location.
  title: Concurrent sessions
  vulnerability_id: '062'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  - Usage of server to accept URLs or file paths from user inputs
  need: Prevent execution of remote files to maintain application integrity and confidentiality
    of data.
  solution:
    considerations:
    - Always validate and sanitize user inputs to prevent any form of code injection.
    - Consider using a Content Security Policy (CSP) to prevent unauthorized code
      execution.
    - Regularly update and patch all systems to fix known vulnerabilities.
    insecure_code_example:
      description: This code includes a file specified by user input in the server's
        execution context, which could lead to Remote File Inclusion.
      text: |-
        defmodule VulnerableApp do
          use Plug.Router

          plug :match
          plug :dispatch

          get '/' do
            filename = get_param(conn, 'filename')
            file_content = File.read!(filename)
            send_resp(conn, 200, file_content)
          end
        end
    language: elixir
    secure_code_example:
      description: This code retrieves files in a safe manner by using a database
        of file references rather than directly including files from user inputs.
      text: |-
        defmodule SecureApp do
          use Plug.Router

          plug :match
          plug :dispatch

          get '/' do
            file_id = get_param(conn, 'file_id')
            filename = lookup_filename(file_id)
            file_content = File.read!(filename)
            send_resp(conn, 200, file_content)
          end

          defp lookup_filename(file_id) do
            # Query database to retrieve file path by ID
          end
        end
    steps:
    - Don't allow file paths or URLs to be specified directly by user inputs.
    - Sanitize all user inputs to ensure they don't contain malicious code.
    - Use a safe method for handling files, such as storing file references in a database
      and retrieving them by ID.
  title: Remote File Inclusion
  vulnerability_id: '061'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  - Usage of server that accepts requests with unrestricted Content-Length header
  need: Prevent service degradation or outage due to malicious requests with excessively
    large Content-Length headers
  solution:
    considerations:
    - The exact maximum Content-Length value to use will depend on your specific application
      requirements.
    - Rate limiting can help protect against a broad range of DoS attacks, not just
      those involving large Content-Length headers.
    - Setting an absolute timeout can also protect against slowloris-style attacks
      where the attacker sends the request body very slowly to keep connections open.
    insecure_code_example:
      description: This basic Plug-based Elixir application doesn't impose any limits
        on the Content-Length of incoming requests, making it vulnerable to DoS attacks.
      text: |-
        defmodule VulnerableApp do
          use Plug.Router

          plug :match
          plug :dispatch

          get '/' do
            send_resp(conn, 200, 'Hello, world!')
          end
        end
    language: elixir
    secure_code_example:
      description: This Elixir application uses the Cowboy HTTP server with a configuration
        that limits the maximum request body size, mitigating the DoS vulnerability.
      text: |-
        defmodule SecureApp do
          use Plug.Router

          plug Plug.Parsers, parsers: [:urlencoded, :multipart, :json], pass: ['*/*'], json_decoder: Poison, length: 1_000_000

          plug :match
          plug :dispatch

          get '/' do
            send_resp(conn, 200, 'Hello, world!')
          end
        end
    steps:
    - Set a maximum limit for the Content-Length of incoming requests.
    - Consider using a rate limiting mechanism to limit the number of requests from
      a single source.
    - Set an absolute timeout for incoming connections.
  title: Asymmetric denial of service - Content length
  vulnerability_id: '057'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Phoenix Framework for building web applications
  - Usage of the application as a web server for handling HTTP requests
  need: To ensure that HTTP methods such as TRACE, PUT and DELETE are disabled to
    avoid potential security risks
  solution:
    considerations:
    - Remember that the specific HTTP methods you need to allow or disallow will depend
      on your application's requirements.
    - Even if certain HTTP methods are disallowed in your code, they might still be
      allowed by your server's configuration. Make sure to check and update this configuration
      if necessary.
    insecure_code_example:
      description: The following Elixir code is vulnerable because it allows PUT and
        DELETE HTTP methods. This configuration can make the application susceptible
        to potential security threats.
      text: |-
        defmodule VulnerableController do
          use MyApp.Web, :controller

          def update(conn, _params) do
            # update action
          end

          def delete(conn, _params) do
            # delete action
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code is secure because it does not include
        handlers for PUT and DELETE HTTP methods. This prevents potential security
        threats associated with these methods.
      text: |-
        defmodule SecureController do
          use MyApp.Web, :controller

          def show(conn, _params) do
            # show action
          end

          def create(conn, _params) do
            # create action
          end

          # The PUT and DELETE methods are not handled
        end
    steps:
    - Use Plug to limit the allowed HTTP methods in your application.
    - Remove or comment out any code that handles unwanted HTTP methods.
  title: Insecure HTTP methods enabled
  vulnerability_id: '044'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug Phoenix Framework for building web applications
  - Usage of the application as a web server for handling HTTP responses
  need: Prevent potential security threats by correctly setting Content-Security-Policy
  solution:
    considerations:
    - Be aware that overly restrictive Content-Security-Policy settings can break
      functionality in your application. Test thoroughly when implementing.
    - Content-Security-Policy settings vary based on the specifics of your application.
      There is no one-size-fits-all configuration.
    insecure_code_example:
      description: The following Elixir code is vulnerable because it does not set
        the Content-Security-Policy HTTP header. This omission makes the application
        susceptible to potential security threats like Cross-Site Scripting (XSS).
      text: |-
        defmodule VulnerableController do
          use MyApp.Web, :controller

          def show(conn, _params) do
            render(conn, "show.html")
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code is secure because it sets the Content-Security-Policy
        HTTP header using Plug. This setting protects the application from potential
        security threats.
      text: |-
        defmodule SecureController do
          use MyApp.Web, :controller

          plug :put_content_security_policy_header

          def show(conn, _params) do
            render(conn, "show.html")
          end

          defp put_content_security_policy_header(conn, _opts) do
            conn
            |> put_resp_header("content-security-policy", "default-src 'self'")
          end
        end
    steps:
    - Use Plug to set the Content-Security-Policy HTTP header in every response.
    - Ensure the policies set in the Content-Security-Policy HTTP header do not contain
      insecure values.
  title: Insecure or unset HTTP headers - Content-Security-Policy
  vulnerability_id: '043'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Password reset without identity verification
  need: Ensure only the authentic user can change the account password
  solution:
    considerations:
    - This mitigation does not prevent an attacker who knows the current password
      from changing it. Additional measures, such as email confirmation or OTP, may
      be necessary.
    - Be aware of potential privacy implications when handling user passwords.
    insecure_code_example:
      description: The following Elixir code is vulnerable because it allows users
        to change their passwords without verifying their current password. An attacker
        who has access to a user's session could change the password without the user's
        knowledge.
      text: |-
        defmodule VulnerableController do
          use MyApp.Web, :controller

          def change_password(conn, %{"new_password" => new_password}) do
            user = get_current_user(conn)
            User.change_password(user, new_password)
            send_resp(conn, 200, "Password changed")
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code is secure because it requires the current
        password to change the password. This helps ensure that the request is made
        by the legitimate user.
      text: |-
        defmodule SecureController do
          use MyApp.Web, :controller

          def change_password(conn, %{"current_password" => current_password, "new_password" => new_password}) do
            user = get_current_user(conn)
            if User.check_password(user, current_password) do
              User.change_password(user, new_password)
              send_resp(conn, 200, "Password changed")
            else
              send_resp(conn, 400, "Incorrect current password")
            end
          end
        end
    steps:
    - Require the current password when a user attempts to change their password.
    - Consider implementing a second form of identity verification (e.g., email confirmation,
      OTP).
  title: Password change without identity check
  vulnerability_id: '033'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Plug.Upload for handling file uploads in Elixir
  - File uploads are handled using Plug.Upload
  need: Prevent resource exhaustion and potential denial of service attacks
  solution:
    considerations:
    - The maximum file size should be determined according to the specific requirements
      and resources of the application and server.
    - This mitigation does not protect against multiple simultaneous large file uploads.
      Consider implementing further measures to control the total upload bandwidth
      or rate limit file uploads.
    - Always sanitize the file name and check the file type before accepting a file
      upload.
    insecure_code_example:
      description: The following Elixir code is vulnerable because it does not impose
        a limit on the size of the uploaded file. An attacker could upload a very
        large file to consume server resources and potentially cause a denial of service.
      text: |-
        defmodule VulnerableController do
          use MyApp.Web, :controller

          def upload(conn, %{"file" => %Plug.Upload{} = upload}) do
            {:ok, _} = File.cp(upload.path, "./uploads/#{upload.filename}")
            send_resp(conn, 200, "File uploaded successfully")
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code is secure because it checks the size
        of the uploaded file before processing it. If the file size exceeds the limit,
        the upload is rejected.
      text: |-
        defmodule SecureController do
          use MyApp.Web, :controller

          def upload(conn, %{"file" => %Plug.Upload{} = upload}) do
            if File.size(upload.path) > 10_000_000 do
              send_resp(conn, 400, "File size exceeds limit")
            else
              {:ok, _} = File.cp(upload.path, "./uploads/#{upload.filename}")
              send_resp(conn, 200, "File uploaded successfully")
            end
          end
        end
    steps:
    - Install the 'arc' library which allows to impose a limit on the size of the
      uploaded files.
    - Define a function to check the size of the uploaded file before copying it to
      the server storage.
    - If the file size exceeds the limit, reject the upload and send an appropriate
      response to the client.
  title: Inadequate File Size Control
  vulnerability_id: '029'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for functional and concurrent programming
  - Usage of Plug.Conn for handling HTTP connections in Elixir
  - Usage of Plug.Conn for request handling
  need: Prevent malicious redirection and potential SSRF attacks
  solution:
    considerations:
    - This mitigation may not be suitable for scenarios where dynamic redirection
      to multiple hosts is a necessary feature of the application.
    - Consider implementing further measures to validate and sanitize all incoming
      headers and parameters.
    - Also consider setting up a web application firewall (WAF) to provide another
      layer of security against header injection and other types of attacks.
    insecure_code_example:
      description: The following Elixir code is vulnerable because it uses the `host`
        from the `conn` object directly to construct a redirection URL. An attacker
        could provide a malicious host in the HTTP request's Host header to cause
        redirection to an external site or possibly exploit SSRF vulnerabilities.
      text: |-
        defmodule VulnerableController do
          use MyApp.Web, :controller

          def redirect(conn, _params) do
            redirect_to = conn.host
            conn
            |> put_resp_header("location", redirect_to)
            |> send_resp(302, "")
          end
        end
    language: elixir
    secure_code_example:
      description: The following Elixir code is secure because it does not use the
        `host` from the `conn` object directly. Instead, it uses a predefined host
        for the redirection, preventing potential misuse of the Host header.
      text: |-
        defmodule SecureController do
          use MyApp.Web, :controller

          def redirect(conn, _params) do
            redirect_to = "https://secure.example.com"
            conn
            |> put_resp_header("location", redirect_to)
            |> send_resp(302, "")
          end
        end
    steps:
    - Add a function to validate the host before using it for redirection.
    - Do not use the host from the incoming HTTP request directly for generating redirection
      responses. Instead, use a predefined and validated list of acceptable hosts
      or a fixed host configured in the application settings.
    - Use pattern matching or similar to ensure the host matches the expected format.
  title: Uncontrolled External Site Redirect - Host Header Injection
  vulnerability_id: '023'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming and building scalable applications
  - Usage of Plug for building composable web applications
  - Usage of Phoenix web framework for building web applications
  need: To prevent unauthorized access and control over a user account.
  solution:
    considerations:
    - This solution assumes that the user's email account is secure and only the owner
      of the account has access to it.
    - It also assumes that the verification code is only sent to the user's registered
      email and is not exposed anywhere else.
    - The generation and verification of the verification code are handled securely.
    insecure_code_example:
      description: The code implements a password reset functionality. However, it
        does not validate whether the requester is indeed the owner of the account.
        This allows an attacker to request a password reset for any account and receive
        the reset link, allowing them to takeover that account.
      text: |-
        defmodule MyAppWeb.PasswordResetController do
          use MyAppWeb, :controller

          def create(conn, %{'email' => email}) do
            user = Accounts.get_user_by_email(email)
            Accounts.deliver_password_reset_instructions(user, conn)
            send_resp(conn, :ok, "")
          end
        end

        defmodule MyApp.Accounts do
          def deliver_password_reset_instructions(%User{} = user, conn) do
            url = MyAppWeb.Router.Helpers.password_reset_url(conn, :edit, user.reset_password_token)
            MyApp.Mailer.deliver_password_reset_instructions(user.email, url)
          end
        end
    language: elixir
    secure_code_example:
      description: The code now first sends a verification code to the user's registered
        email when a password reset is requested. The password reset process only
        proceeds if the correct verification code is provided, thereby validating
        that the requester is indeed the owner of the account.
      text: |-
        defmodule MyAppWeb.PasswordResetController do
          use MyAppWeb, :controller

          def create(conn, %{'email' => email}) do
            user = Accounts.get_user_by_email(email)
            verification_code = Accounts.generate_verification_code(user)
            MyApp.Mailer.deliver_verification_code(user.email, verification_code)
            send_resp(conn, :ok, "")
          end

          def update(conn, %{'email' => email, 'verification_code' => verification_code, 'new_password' => new_password}) do
            user = Accounts.get_user_by_email(email)
            if Accounts.verify(user, verification_code) do
              Accounts.reset_password(user, new_password)
              send_resp(conn, :ok, "")
            else
              send_resp(conn, :bad_request, "")
            end
          end
        end
    steps:
    - Implement verification mechanisms to ensure that the person requesting a password
      reset is indeed the owner of the account.
    - This could be done by sending a verification code to the user's registered email
      before proceeding with the password reset process.
    - Ensure that the password reset URL is only sent to the user's registered email
      and is not exposed anywhere else.
  title: Account Takeover
  vulnerability_id: '417'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming and building scalable applications
  - Usage of Plug for building composable web applications in Elixir
  - Usage of Phoenix web framework for building web applications
  need: To ensure secure password resets and prevent attackers from gaining control
    over user accounts.
  solution:
    considerations:
    - This solution assumes that the host configuration for the application is reliable
      and cannot be manipulated by an attacker.
    - If the application is deployed in multiple environments with different hosts,
      ensure that the correct host value is used in each environment's configuration.
    insecure_code_example:
      description: The code generates a password reset link using the host provided
        in the request headers. An attacker can manipulate the request headers to
        provide a host that they control, resulting in the application generating
        a reset link that points to the attacker's host.
      text: |-
        defmodule MyAppWeb.PasswordResetController do
          use MyAppWeb, :controller

          def create(conn, %{'email' => email}) do
            user = Accounts.get_user_by_email(email)
            Accounts.deliver_password_reset_instructions(user, conn)
            send_resp(conn, :ok, "")
          end
        end

        defmodule MyApp.Accounts do
          def deliver_password_reset_instructions(%User{} = user, conn) do
            url = MyAppWeb.Router.Helpers.password_reset_url(conn, :edit, user.reset_password_token)
            MyApp.Mailer.deliver_password_reset_instructions(user.email, url)
          end
        end
    language: elixir
    secure_code_example:
      description: The code now generates the password reset URL using a trusted host
        value from the application's configuration, instead of the host provided in
        the request headers. This prevents an attacker from manipulating the reset
        URL to point to their own host.
      text: |-
        defmodule MyAppWeb.PasswordResetController do
          use MyAppWeb, :controller

          def create(conn, %{'email' => email}) do
            user = Accounts.get_user_by_email(email)
            Accounts.deliver_password_reset_instructions(user)
            send_resp(conn, :ok, "")
          end
        end

        defmodule MyApp.Accounts do
          def deliver_password_reset_instructions(%User{} = user) do
            host = Application.get_env(:my_app, MyAppWeb.Endpoint)[:url][:host]
            url = MyAppWeb.Router.Helpers.password_reset_url(MyAppWeb.Endpoint, :edit, user.reset_password_token, host: host)
            MyApp.Mailer.deliver_password_reset_instructions(user.email, url)
          end
        end
    steps:
    - Ensure the password reset URL is generated using a trusted host value.
    - Don't rely on values provided in the request headers for generating the reset
      URL.
    - Add a configuration for the application's host and use that when generating
      the password reset URL.
  title: Password Reset Poisoning
  vulnerability_id: '420'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.10 and above) for building scalable and fault-tolerant
    applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  need: Preventing execution of arbitrary OS commands
  solution:
    considerations:
    - Although whitelisting is a strong mitigation strategy, it is not completely
      foolproof. If possible, avoid executing OS commands based on user inputs.
    - Always validate and sanitize user inputs before processing them.
    insecure_code_example:
      description: This insecure code takes a command from the user via a POST request
        and directly executes it using the System.cmd function. An attacker can craft
        a command to retrieve or modify sensitive data, or even gain control over
        the system.
      text: |-
        defmodule MyApp.CommandController do
          use Plug.Router
          plug :match
          plug :dispatch

          post "/execute" do
            command = conn.body_params["command"]
            {result, 0} = System.cmd("/bin/sh", ["-c", command])
            send_resp(conn, 200, result)
          end
        end
    language: elixir
    secure_code_example:
      description: The secure code checks whether the provided command is in a list
        of allowed commands before executing it. This whitelist approach prevents
        the execution of any arbitrary command, thus mitigating the risk of OS command
        injection.
      text: |-
        defmodule MyApp.CommandController do
          use Plug.Router
          plug :match
          plug :dispatch

          post "/execute" do
            command = conn.body_params["command"]
            if command in [@allowed_command1, @allowed_command2] do
              {result, 0} = System.cmd("/bin/sh", ["-c", command])
              send_resp(conn, 200, result)
            else
              send_resp(conn, 403, "Forbidden command")
            end
          end
        end
    steps:
    - Implement a whitelist of allowed commands.
    - Check the provided command against the whitelist before executing it.
    - If possible, avoid executing OS commands based on user inputs.
  title: OS Command Injection
  vulnerability_id: '404'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.10 and above) for building scalable and fault-tolerant
    applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  - Usage of Ecto for data persistence
  - Usage of crypto for cryptographic operations
  need: Ensuring secure initialization vectors for cryptographic operations
  solution:
    considerations:
    - Initialization vectors should be unpredictable and unique for each encryption
      under the same key.
    - It is generally safe to transmit or store the IV alongside the ciphertext since
      the IV itself doesn't need to be secret, but it must not be predictable.
    insecure_code_example:
      description: In this insecure code, a static, hardcoded initialization vector
        (IV) is used in the AES encryption. Using a static IV for multiple encryptions
        with the same key allows an attacker to analyze the patterns and potentially
        reverse-engineer the key.
      text: |-
        defmodule MyApp.Crypto do
          @iv "0123456789abcdef"
          def encrypt(data, key) do
            :crypto.block_encrypt(:aes_cbc128, key, @iv, data)
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure version, a new random initialization vector (IV)
        is generated for each encryption using :crypto.strong_rand_bytes. This method
        provides sufficient randomness and high entropy, which makes it very difficult
        for an attacker to predict the IVs.
      text: |-
        defmodule MyApp.Crypto do
          def encrypt(data, key) do
            iv = :crypto.strong_rand_bytes(16)
            {:iv, :crypto.block_encrypt(:aes_cbc128, key, iv, data)}
          end
        end
    steps:
    - Use :crypto.strong_rand_bytes to generate a random initialization vector for
      each encryption.
    - Avoid using static, hardcoded initialization vectors.
  title: Insecure generation of random numbers - Static IV
  vulnerability_id: '395'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  - Usage of Ecto for data persistence
  need: Protecting user data and ensuring application integrity
  solution:
    considerations:
    - You should have a robust authentication and authorization system in place to
      accurately identify the current user and their role.
    - Roles and their permissions should be clearly defined and enforced across all
      parts of the application.
    insecure_code_example:
      description: In this vulnerable code snippet, the application is deleting a
        user based on the provided id without checking if the authenticated user has
        the necessary permissions to perform the operation.
      text: |-
        def delete_user(conn, %{'id' => id}) do
          Repo.delete!(User |> Repo.get!(id))
          send_resp(conn, 204, "")
        end
    language: elixir
    secure_code_example:
      description: In this secure version, before deleting a user, the application
        checks if the current user has the 'admin' role. If the user doesn't have
        the necessary permissions, the application returns a 403 Forbidden status
        code.
      text: "def delete_user(conn, %{'id' => id}) do\n  case conn.assigns.current_user.role\
        \ do\n    :admin -> \n      Repo.delete!(User |> Repo.get!(id))\n      send_resp(conn,\
        \ 204, \"\")\n    _ ->\n      send_resp(conn, 403, \"Forbidden\")\n  end\n\
        end"
    steps:
    - Check the role of the current user before performing any destructive operations.
    - Only allow users with the necessary permissions to delete other users.
    - If a user without the necessary permissions tries to delete a user, return a
      403 Forbidden status code.
  title: Insecure object reference - User deletion
  vulnerability_id: '369'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for building scalable and concurrent applications
  - Usage of Plug.Session for HTTP session management
  need: To ensure proper session management and invalidate sessions appropriately
  solution:
    considerations:
    - Ensure test code is properly isolated from production code
    - Make sure to clean up after debugging, especially removing any hardcoded credentials
      or bypass mechanisms
    - Implement appropriate session management, including session invalidation after
      logout
    insecure_code_example:
      description: In the insecure code example, the `get_user_email` function checks
        the session to find the user's email. However, there is debug code left in
        that allows anyone to pass in a session with the word 'auto' and get access
        to a testing email. This is insecure as it allows unauthorized access.
      text: |-
        defmodule MyApp.Accounts do
          def get_user_email(conn) do
            session = Plug.Conn.get_session(conn, :user)
            if session == "auto", do: "test@test.com", else: session.email
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the `get_user_email` function only
        checks the session for the user's email, and there is no debug code that can
        be exploited for unauthorized access.
      text: |-
        defmodule MyApp.Accounts do
          def get_user_email(conn) do
            session = Plug.Conn.get_session(conn, :user)
            session.email
          end
        end
    steps:
    - Remove the debugging code from the production environment
    - Ensure all test code is isolated from production code
  title: Security Controls Bypass or Absence - Session Invalidation
  vulnerability_id: '345'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming and building scalable applications
  - Usage of Phoenix Framework 1.6 for web development
  - Usage of Plug.CSRFProtection for protecting against Cross-Site Request Forgery
    (CSRF) attacks
  need: To prevent CSRF attacks that can spoof an authenticated user and execute critical
    transactions
  solution:
    considerations:
    - Ensure that the CSRF token is associated with the user's session
    - Renew the CSRF token whenever the user's authentication state changes
    - Handle the case where the CSRF token validation fails, for example, by showing
      an error message to the user
    insecure_code_example:
      description: In the insecure code example, the `make_transaction` function handles
        a transaction without validating a CSRF token. This allows an attacker to
        create a button with the content of a request and trick a user running a transaction
        to receive the app push notification and complete the request.
      text: |-
        defmodule TransactionController do
          use MyApp.Web, :controller

          def make_transaction(conn, %{'amount' => amount, 'recipient' => recipient}) do
            # perform transaction...
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the `make_transaction` function validates
        the CSRF token using `Plug.CSRFProtection.check_csrf_token/2`. This ensures
        that the request is made by a legitimate user, preventing CSRF attacks.
      text: |-
        defmodule TransactionController do
          use MyApp.Web, :controller

          def make_transaction(conn, %{'_csrf_token' => csrf_token, 'amount' => amount, 'recipient' => recipient}) do
            if Plug.CSRFProtection.check_csrf_token(conn, csrf_token) do
              # perform transaction...
            else
              send_resp(conn, 403, "Invalid CSRF token")
            end
          end
        end
    steps:
    - Enable CSRF protection using `Plug.CSRFProtection`
    - Generate a CSRF token for every form using `Plug.CSRFProtection.get_csrf_token/0`
      and include it as a hidden field in the form
    - In the function handling the form submission, validate the CSRF token
  title: Insecure Session Management - CSRF Fixation
  vulnerability_id: '337'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming on the Erlang virtual machine
  - Usage of Phoenix Framework 1.6 for web development
  need: To prevent unexpected behaviors due to content type misinterpretations
  solution:
    considerations:
    - Choose the appropriate Content-Type based on the type of content in the response
    - Avoid using `application/octet-stream` as the Content-Type unless necessary,
      as it might be interpreted differently by different clients
    insecure_code_example:
      description: In the insecure code example, the `index` function responds to
        a GET request but does not set the Content-Type header. This can lead to misinterpretation
        of the content type, which can cause unexpected behaviors in clients.
      text: |-
        defmodule PageController do
          use MyApp.Web, :controller

          def index(conn, _params) do
            send_resp(conn, 200, "Hello, world!")
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code, the `index` function sets the Content-Type
        header to `text/plain`. This informs the client about the type of content
        in the response, preventing misinterpretations.
      text: |-
        defmodule PageController do
          use MyApp.Web, :controller

          def index(conn, _params) do
            conn
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Hello, world!")
          end
        end
    steps:
    - Always set the Content-Type header to explicitly define the content types allowed
      by the application
    - Use `put_resp_content_type` function provided by Phoenix framework to set the
      Content-Type header
  title: Insecure or Unset HTTP Headers - Content-Type
  vulnerability_id: '329'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework 1.6 for web development
  need: To prevent unauthorized users from closing sessions of other users
  solution:
    considerations:
    - Storing and managing session tokens securely is vital
    - Ensure that session tokens are invalidated when a user logs out
    insecure_code_example:
      description: In this insecure code, the `logout_user` function logs out a user
        based on the email provided. This is insecure because if an attacker knows
        a user's email, they can log out the user's session.
      text: |-
        defmodule SessionManager do
          def logout_user(conn, email) do
            # Clearing the session
            conn
            |> put_flash(:info, "Logged out successfully.")
            |> configure_session(drop: true)
            |> redirect(to: "/")
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure version of the code, the system checks whether the
        session being terminated belongs to the user initiating the logout operation.
      text: |-
        defmodule SessionManager do
          def logout_user(conn, session_token) do
            user = get_user_from_session_token(session_token)
            if conn.assigns.current_user == user do
              # Clearing the session
              conn
              |> put_flash(:info, "Logged out successfully.")
              |> configure_session(drop: true)
              |> redirect(to: "/")
            else
              # Do not allow logging out other users' sessions
            end
          end

          defp get_user_from_session_token(session_token) do
            # Logic to get the user from the session token
          end
        end
    steps:
    - Use a secure identifier, like a session token, to identify the user for the
      logout operation
    - Implement checks to validate that the session being terminated matches the user
      performing the operation
  title: Insecure Object Reference - Session Management
  vulnerability_id: '328'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming and building scalable applications
  - Usage of Phoenix Framework 1.6 for web development
  need: To ensure that sensitive vulnerability data is only accessible by registered
    and authorized users
  solution:
    considerations:
    - Verifying user registration and authorization will have some overhead on system
      performance
    - Managing access rights is a critical part of security and should be prioritized
    insecure_code_example:
      description: In this code, the function `assign_treatment_manager` allows any
        email address to be assigned as a manager of vulnerabilities. This means the
        system could potentially send sensitive vulnerability data to non-registered
        users, or users who no longer have access to the system.
      text: |-
        defmodule UserManager do
          def assign_treatment_manager(email, vulnerability_id) do
            send_vulnerability_email(email, vulnerability_id)
          end

          defp send_vulnerability_email(email, vulnerability_id) do
            # Email sending logic here
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure version of the code, the system checks whether the
        user is registered and still part of the organization before assigning them
        as a treatment manager. Also, when a user is removed from all projects, their
        access is effectively revoked.
      text: |-
        defmodule UserManager do
          def assign_treatment_manager(email, vulnerability_id) do
            if is_registered_and_authorized?(email) do
              send_vulnerability_email(email, vulnerability_id)
            end
          end

          defp send_vulnerability_email(email, vulnerability_id) do
            # Email sending logic here
          end

          defp is_registered_and_authorized?(email) do
            # Verification logic here
          end
        end
    steps:
    - Ensure the system verifies if a user is registered and has the necessary access
      rights before assigning them as a treatment manager
    - Check if a user is still part of an organization before sending them any vulnerability
      data
    - When a user is removed from all projects, ensure their access to all related
      data is revoked
  title: Insecure Functionality - User Management
  vulnerability_id: '324'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming and building scalable applications
  - Usage of Phoenix Framework 1.6 for web development
  - Usage of Guardian 2.0 for authentication and authorization
  need: To prevent unauthorized user data modifications by ensuring token's expiry
    time is reasonable
  solution:
    considerations:
    - Token lifespan depends on the nature of the application and the level of security
      required
    - Short-lived tokens require users to reauthenticate more frequently
    - Consider user experience when choosing token lifespan
    insecure_code_example:
      description: In this code snippet, JWT tokens are created with a lifespan of
        approximately 5 days (represented as 432000 seconds). This is too long and
        it increases the risk that a malicious actor can use a stolen token for unauthorized
        activities.
      text: |-
        defmodule InsecureToken do
          alias Guardian.JWT
          @secret_key "Your secret key"

          def create_token(claims) do
            {:ok, token, _claims} = JWT.encode_and_sign(claims, key: @secret_key, ttl: {432000, :second})
            token
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure version of the code, the lifespan of the token has
        been significantly reduced to approximately 15 minutes (represented as 900
        seconds). This reduces the time window for an attacker to use a stolen token.
      text: |-
        defmodule SecureToken do
          alias Guardian.JWT
          @secret_key "Your secret key"

          def create_token(claims) do
            {:ok, token, _claims} = JWT.encode_and_sign(claims, key: @secret_key, ttl: {900, :second})
            token
          end
        end
    steps:
    - Reduce the lifespan of JWT tokens to a more reasonable timeframe
    - Invalidate tokens on the server side when a user logs out
    - Consider token refresh strategies if long-lived tokens are required
  title: Insecurely Generated Token - Lifespan
  vulnerability_id: '322'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework 1.6 for web development
  - Usage of Guardian 2.0 for authentication and authorization
  need: To prevent unauthorized user creation and protect the integrity of user data
  solution:
    considerations:
    - Never trust user input, always validate and sanitize
    - Make sure to use a strong secret key
    - Periodically rotate the secret key
    - Do not expose the secret key or hardcode it into your application
    insecure_code_example:
      description: In this code snippet, a JWT token is decoded without verifying
        its signature, thus allowing tampering. An attacker can modify the token header,
        to change the algorithm used for signature and create users without the token
        being properly validated.
      text: |-
        defmodule InsecureToken do
          alias Guardian.JWT

          def decode_and_verify(token) do
            {:ok, claims} = JWT.decode_and_verify(token)
            IO.inspect(claims)
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure version of the code, the token is decoded and verified
        with a predefined secret key. This ensures the token's integrity and authenticity,
        thus preventing the creation of unauthorized users.
      text: |-
        defmodule SecureToken do
          alias Guardian.JWT
          @secret_key "Your secret key"

          def decode_and_verify(token) do
            {:ok, claims} = JWT.decode_and_verify(token, key: @secret_key)
            IO.inspect(claims)
          end
        end
    steps:
    - Ensure that the JWT token signature is properly validated before decoding
    - Use a known and secure algorithm for token encryption
    - Consider using a library like Guardian for Elixir that provides secure handling
      of JWT tokens
  title: Insecurely Generated Token - Validation
  vulnerability_id: '318'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for building scalable and concurrent applications
  - Usage of Phoenix Framework 1.6 for web development
  need: To avoid exhausting system resources due to memory leaks
  solution:
    considerations:
    - Consider the size and lifetime of your data structures when writing Elixir code
    - Use tools like :recon.bin_leak/0 to find binary memory leaks
    - Consider using :erlang.garbage_collect/0 or :erlang.garbage_collect/1 for manual
      garbage collection in certain situations
    insecure_code_example:
      description: The following code demonstrates a memory leak situation in Elixir.
        A process is spawned that starts a large data structure (a list), which is
        continually appended with elements. However, these elements are never released
        and accumulate over time, leading to increased memory usage.
      text: |-
        defmodule MemoryLeak do
          def leak_memory do
            spawn(fn ->
              Process.flag(:trap_exit, true)
              accumulate([])
            end)
          end

          defp accumulate(list) do
            new_list = [0 | list]
            accumulate(new_list)
          end
        end
    language: elixir
    secure_code_example:
      description: In this solution, the process is set to terminate after a certain
        period of time, ensuring that the large data structure it has created is released
        from memory.
      text: |-
        defmodule MemoryLeak do
          def leak_memory do
            spawn(fn ->
              Process.flag(:trap_exit, true)
              accumulate([])
              Process.sleep(10000)
              :ok
            end)
          end

          defp accumulate(list) when length(list) < 1_000_000 do
            new_list = [0 | list]
            accumulate(new_list)
          end

          defp accumulate(_list), do: :ok
        end
    steps:
    - Monitor your processes and identify those that continue to consume memory over
      time
    - Limit the lifetime of processes that create large data structures
    - Consider making use of Elixir's garbage collection features to manually trigger
      garbage collection in certain situations
  title: Improper Resource Allocation - Memory Leak
  vulnerability_id: '317'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming and building scalable applications
  - Usage of Phoenix Framework 1.6 for web development
  - Usage of Guardian 2.0 for authentication and authorization
  need: To ensure tokens are generated securely, preventing unauthorized access
  solution:
    considerations:
    - Never hard-code secret keys, especially in a version-controlled codebase
    - Ensure the server environment where the application is deployed is secure
    - Regularly rotate the secret key for added security
    insecure_code_example:
      description: This insecure code example shows a JWT token being signed with
        a weak secret key. This weak key can be easily cracked, allowing attackers
        to generate their own tokens, modify token parameters and access the service
        illegitimately.
      text: |-
        def sign(user) do
          jwt = %{id: user.id}
          secret = 'weak-secret'
          {:ok, token, _claims} = Guardian.encode_and_sign(jwt, secret)
          token
        end
    language: elixir
    secure_code_example:
      description: This secure code example replaces the weak secret key with a strong
        secret key stored in an environment variable. This enhances the security of
        the JWT signing and verification process.
      text: |-
        def sign(user) do
          jwt = %{id: user.id}
          secret = System.get_env('JWT_SECRET')
          {:ok, token, _claims} = Guardian.encode_and_sign(jwt, secret)
          token
        end
    steps:
    - Use a strong secret key for JWT signing and verification
    - Consider using environment variables to store the secret key securely
    - Consider using a library or service that can generate strong secret keys
  title: Insecurely Generated Token - JWT
  vulnerability_id: '309'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming and building scalable applications
  - Usage of Phoenix Framework 1.6 for web development
  need: Prevent unauthorized users from accessing or manipulating other stores' data
  solution:
    considerations:
    - Ensure store IDs are kept confidential and are not easily guessable to prevent
      unauthorized access
    - Make sure to use a robust authentication and authorization system to manage
      user permissions
    insecure_code_example:
      description: This insecure code example shows an Elixir Phoenix application
        that retrieves a store's data by its ID without checking the user's permissions.
        An attacker can exploit this by guessing or brute-forcing the store IDs to
        access and manipulate other stores' data.
      text: |-
        def show(conn, %{"id" => id}) do
          store = Repo.get!(Store, id)
          send_resp(conn, :ok, store)
        end
    language: elixir
    secure_code_example:
      description: This secure code example includes a check to ensure the authenticated
        user has the necessary permissions to access the store's data before it is
        returned. If they do not, a 403 Forbidden status code is returned.
      text: |-
        def show(conn, %{"id" => id}) do
          store = Repo.get!(Store, id)
          if has_permission?(conn.assigns[:current_user], store) do
            send_resp(conn, :ok, store)
          else
            send_resp(conn, :forbidden, "You do not have permission to access this store's data")
          end
        end

        defp has_permission?(user, store) do
          user.id == store.user_id
        end
    steps:
    - Before returning the store's data, check if the authenticated user has the necessary
      permissions to access it
    - Return a 403 Forbidden status code if the user does not have the necessary permissions
  title: Insecure Object Reference - Data
  vulnerability_id: '307'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming
  - Usage of Phoenix Framework 1.6 for web development
  need: Prevent unauthorized users from accessing or manipulating information
  solution:
    considerations:
    - Ensure user IDs are kept confidential and are not easily guessable to prevent
      unauthorized access
    - Make sure to use a robust authentication and authorization system to manage
      user permissions
    insecure_code_example:
      description: This insecure code example shows an Elixir Phoenix application
        that retrieves a file by its ID without checking the user's permissions. An
        attacker can exploit this by guessing or brute-forcing the file IDs to access
        other users' files.
      text: |-
        def show(conn, %{"id" => id}) do
          file = Repo.get!(File, id)
          send_resp(conn, :ok, file)
        end
    language: elixir
    secure_code_example:
      description: This secure code example includes a check to ensure the authenticated
        user has the necessary permissions to access the file before it is returned.
        If they do not, a 403 Forbidden status code is returned.
      text: |-
        def show(conn, %{"id" => id}) do
          file = Repo.get!(File, id)
          if has_permission?(conn.assigns[:current_user], file) do
            send_resp(conn, :ok, file)
          else
            send_resp(conn, :forbidden, "You do not have permission to access this file")
          end
        end

        defp has_permission?(user, file) do
          user.id == file.user_id
        end
    steps:
    - Before returning the file, check if the authenticated user has the necessary
      permissions to access it
    - Return a 403 Forbidden status code if the user does not have the necessary permissions
  title: Insecure Object Reference - Files
  vulnerability_id: '306'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for building scalable and concurrent applications
  - Usage of Phoenix Framework 1.6 for web development
  need: Prevent the creation of more than four beneficiaries per policy
  solution:
    considerations:
    - Take care to handle the error response on the client side, informing the user
      of the restriction
    - The magic number 4 can be replaced with a configuration parameter, allowing
      for easier adjustments in the future
    insecure_code_example:
      description: This insecure code example shows an Elixir Phoenix application
        that creates a new policy with associated beneficiaries. However, there's
        no validation on the server side to restrict the number of beneficiaries created
        per policy. This allows for unlimited beneficiaries to be associated with
        a single policy, bypassing the intended restriction.
      text: |-
        def create(conn, %{"policy" => policy_params, "beneficiaries" => beneficiaries_params}) do
          %Policy{}
          |> Policy.changeset(policy_params)
          |> Ecto.Changeset.cast_assoc(:beneficiaries, with: &Beneficiary.changeset/2)
          |> Repo.insert()
          send_resp(conn, :ok, "Policy created successfully")
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, a validation function has been added
        to the controller. This function checks the length of the beneficiaries list
        before the policy is created. If more than four beneficiaries are associated
        with a policy, it returns an error response.
      text: |-
        def create(conn, %{"policy" => policy_params, "beneficiaries" => beneficiaries_params}) do
          if Enum.count(beneficiaries_params) > 4 do
            send_resp(conn, :bad_request, "Cannot associate more than 4 beneficiaries with a policy")
          else
            %Policy{}
            |> Policy.changeset(policy_params)
            |> Ecto.Changeset.cast_assoc(:beneficiaries, with: &Beneficiary.changeset/2)
            |> Repo.insert()
            send_resp(conn, :ok, "Policy created successfully")
          end
        end
    steps:
    - Add a validation check to restrict the number of beneficiaries associated with
      each policy to four
    - Return an error response if more than four beneficiaries are provided
  title: Security Controls Bypass or Absence - Data Creation
  vulnerability_id: '305'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for building scalable and concurrent applications
  - Usage of Phoenix Framework 1.6 for web development
  - Usage of Guardian library for authentication and authorization
  need: Prevent reuse of expired session tokens to ensure session integrity
  solution:
    considerations:
    - Consider using short-lived tokens and a refresh token mechanism for better security
    - Make sure to communicate clearly to the user when their session has expired
      and they need to log in again
    insecure_code_example:
      description: This example depicts an API endpoint in a Phoenix application that
        authenticates the user using JWT tokens generated with the Guardian library.
        The problem lies in the token validation mechanism, where the code checks
        the token's expiration date against the current time but does not verify if
        the token itself is expired.
      text: |-
        defmodule MyAppWeb.Endpoint do
          use Guardian.Plug.VerifyHeader, realm: "Bearer"
          def call(conn, _) do
            case Guardian.Plug.current_token(conn) do
              nil -> conn
              token ->
                if MyApp.Auth.Token.is_expired?(token) do
                  MyApp.Auth.Token.extend_expiration(token)
                end
                conn
            end
          end
        end
    language: elixir
    secure_code_example:
      description: In the fixed code, the token extension functionality has been removed.
        Therefore, once a token has expired, it can no longer be used, ensuring the
        integrity of the session.
      text: |-
        defmodule MyAppWeb.Endpoint do
          use Guardian.Plug.VerifyHeader, realm: "Bearer"
          def call(conn, _) do
            case Guardian.Plug.current_token(conn) do
              nil -> conn
              token ->
                if MyApp.Auth.Token.is_expired?(token) do
                  conn
                  |> put_status(:unauthorized)
                  |> Phoenix.Controller.json(%{error: "Expired token"})
                  |> halt()
                end
                conn
            end
          end
        end
    steps:
    - Remove the token extension functionality
    - Ensure that expired tokens cannot be reused
  title: Insecure Functionality - Session Management
  vulnerability_id: '302'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework 1.6 for web development
  need: Prevent concurrent sessions from a single user account to maintain traceability
  solution:
    considerations:
    - Users may find it inconvenient if they are logged out of other devices when
      they log in from a new location
    - For higher security, consider implementing a way for users to see and manage
      their active sessions
    insecure_code_example:
      description: The code snippet depicts a controller in a Phoenix application
        where users can log in without the application terminating their previous
        sessions. This would allow an attacker who gained access to a user's account
        to use it concurrently with the legitimate user, causing potential loss of
        traceability.
      text: |-
        defmodule MyAppWeb.SessionController do
          use MyAppWeb, :controller
          def create(conn, %{"user" => user_params}) do
            case MyApp.Auth.authenticate(user_params) do
              {:ok, user} ->
                conn
                |> put_session(:user_id, user.id)
                |> redirect(to: "/dashboard")
              _ ->
                conn
            end
          end
        end
    language: elixir
    secure_code_example:
      description: In the fixed code, upon successful authentication, any existing
        sessions for the user are invalidated before a new one is created. This ensures
        that only one session can be active at a time for each user, preventing concurrent
        session control bypass.
      text: |-
        defmodule MyAppWeb.SessionController do
          use MyAppWeb, :controller
          def create(conn, %{"user" => user_params}) do
            case MyApp.Auth.authenticate(user_params) do
              {:ok, user} ->
                MyApp.Session.invalidate_user_sessions(user)
                conn
                |> put_session(:user_id, user.id)
                |> redirect(to: "/dashboard")
              _ ->
                conn
            end
          end
        end
    steps:
    - Maintain a server-side record of active user sessions
    - Immediately invalidate any existing sessions for a user when a new login occurs
  title: Concurrent Sessions Control Bypass
  vulnerability_id: '301'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for building scalable and concurrent applications
  - Usage of Phoenix Framework 1.6 for web development
  need: Prevent unauthorized access by implementing proper authentication
  solution:
    considerations:
    - Secure the redirect process from manipulation by attackers
    - Be cautious of allowing user-supplied input to dictate application flow
    - Ensure proper session management to avoid session hijacking
    insecure_code_example:
      description: The code provided shows a function that uses a URL parameter to
        determine where to redirect the user after login. An attacker could change
        this parameter to bypass authentication, gaining unauthorized access to the
        application.
      text: |-
        defmodule MyAppWeb.SessionController do
          use MyAppWeb, :controller
          def create(conn, %{"user" => user_params, "redirect" => redirect_url}) do
            case MyApp.Auth.authenticate(user_params) do
              {:ok, user} ->
                conn
                |> put_session(:user_id, user.id)
                |> redirect(to: redirect_url)
              _ ->
                conn
            end
          end
        end
    language: elixir
    secure_code_example:
      description: The code now redirects to a static page instead of using a URL
        parameter. This ensures that the redirection process cannot be manipulated
        by attackers.
      text: |-
        defmodule MyAppWeb.SessionController do
          use MyAppWeb, :controller
          def create(conn, %{"user" => user_params}) do
            case MyApp.Auth.authenticate(user_params) do
              {:ok, user} ->
                conn
                |> put_session(:user_id, user.id)
                |> redirect(to: "/dashboard")
              _ ->
                conn
            end
          end
        end
    steps:
    - Implement a strong authentication process for every business-critical resource
    - Instead of using a URL parameter for redirection, set a static redirect page
      in the application code
  title: Authentication Mechanism Absence or Evasion - Redirect
  vulnerability_id: '298'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming
  - Usage of Phoenix Framework 1.6 for web development
  need: Ensure security after password change
  solution:
    considerations:
    - Ensure the session management strategy supports invalidation or renewal
    - Ensure this strategy is consistently applied wherever password changes can occur
    - Consider implementing additional security measures like two-factor authentication
      to reduce the risk of session compromise
    insecure_code_example:
      description: The code demonstrates a password change functionality which does
        not invalidate the session after the password change. If an attacker had compromised
        this session, they would maintain control even after the legitimate user has
        changed their password.
      text: |-
        defmodule MyApp.Accounts do
          def change_password(user, new_password) do
            user
            |> change()
            |> put_change(:password, new_password)
            |> Repo.update()
          end
        end
    language: elixir
    secure_code_example:
      description: The code now includes a function call to clear the session after
        the password change. This forces any user, legitimate or attacker, to re-authenticate
        after the password change, effectively locking out any attacker that had compromised
        the previous session.
      text: |-
        defmodule MyApp.Accounts do
          def change_password(conn, user, new_password) do
            user
            |> change()
            |> put_change(:password, new_password)
            |> Repo.update()
            |> case do
                 {:ok, _user} ->
                   MyAppWeb.SessionController.clear_session(conn)
                 _ ->
                   conn
               end
          end
        end
    steps:
    - Ensure that the session is invalidated or renewed after the password change
    - This could involve destroying the current session and forcing the user to log
      in again with their new password
  title: Insecure Session Management After Password Change
  vulnerability_id: '295'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.12 for functional programming on the Erlang virtual machine
  - Usage of Phoenix Framework 1.6 for web development
  need: Prevent unauthorized access to sensitive user information
  solution:
    considerations:
    - Ensure the session management mechanism securely manages user sessions and tokens
    - Consider using an authorization library or framework to handle complex authorization
      rules
    - Ensure secure practices for error handling to avoid giving malicious users too
      much information
    insecure_code_example:
      description: The code is vulnerable because it allows the querying of credit
        card information based on the encrypted product number, but it does not verify
        if the account making the request has the necessary permissions to access
        that specific credit card information. This opens a pathway for an attacker
        to probe and potentially obtain sensitive credit card information.
      text: |-
        defmodule MyApp.CreditCardController do
          use MyApp, :controller
          def show(conn, %{'id' => id}) do
            credit_card = CreditCard.get!(id)
            render(conn, 'show.json', credit_card: credit_card)
          end
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it verifies if the user making the
        request has the necessary permissions to access the requested credit card
        data before providing it. This is achieved by comparing the user id in the
        session with the user id associated with the credit card. If the ids match,
        the information is provided. Otherwise, an error message is returned.
      text: |-
        defmodule MyApp.CreditCardController do
          use MyApp, :controller
          import Plug.Conn
          def show(conn, %{'id' => id}) do
            credit_card = CreditCard.get!(id)
            if conn.assigns.current_user.id == credit_card.user_id do
              render(conn, 'show.json', credit_card: credit_card)
            else
              conn
              |> put_status(:forbidden)
              |> put_resp_header('content-type', 'application/json')
              |> send_resp(403, '{"error": "Not authorized"}')
            end
          end
        end
    steps:
    - Import the Plug.Conn library which provides utility functions for working with
      connections
    - Use the Plug.Conn.assign/3 function in your controller to assign the current
      user to the conn struct
    - Check if the current user has the necessary permissions to access the requested
      credit card data before returning it
    - Add an else clause to handle scenarios when the user does not have permission
      to access the data
  title: Insecure Object Reference in Credit Card Inquiry
  vulnerability_id: '288'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Ecto for data persistence
  - Usage of CSV or Excel file uploading and parsing
  need: Prevent unauthorized modification of third-party company's employee information
  solution:
    considerations:
    - The session should be managed securely to prevent session theft.
    - Use HTTPS to protect the session id from being intercepted during transmission.
    - Proper error handling should be added to manage cases when the session does
      not contain a 'payrollNumber' or the 'payrollNumber' is not valid.
    insecure_code_example:
      description: The code below is insecure because it allows anyone to upload an
        Excel file and update employee information of any company by changing the
        'payrollNumber'. An attacker can change the 'payrollNumber' to a company they
        do not own and upload or modify its employees' information.
      text: |-
        defmodule PayrollController do
          def upload(conn, %{'file' => file, 'payrollNumber' => payroll_number}) do
            {:ok, company} = Repo.get(Company, payroll_number)
            Employee.import_from_excel(file, company)
          end
        end
    language: elixir
    secure_code_example:
      description: The code below is secure because it uses the 'payrollNumber' stored
        in the session to get the company and update its employees. Even if an attacker
        changes the 'payrollNumber' in the request parameters, it won't affect which
        company's employees are updated because the 'payrollNumber' in the session
        is used.
      text: |-
        defmodule PayrollController do
          def upload(conn, %{'file' => file}) do
            payroll_number = get_session(conn, :payroll_number)
            {:ok, company} = Repo.get(Company, payroll_number)
            Employee.import_from_excel(file, company)
          end
        end
    steps:
    - Store the authenticated user's company identifier in the session after successful
      login.
    - Instead of getting the company identifier from request parameters, get it from
      the session.
    - Use the company identifier from the session to get the company and update its
      employees.
  title: Insecure object reference - Corporate information
  vulnerability_id: '287'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.12 and above) for building scalable and fault-tolerant
    applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Plug for session handling
  - Usage of Ecto for data persistence
  need: Prevent unauthorized modification of other user's information
  solution:
    considerations:
    - The session should be managed securely to prevent session theft.
    - Use HTTPS to protect the session id from being intercepted during transmission.
    insecure_code_example:
      description: The code below is insecure because it uses the user_id from the
        request parameters to fetch and update a user. An attacker can change the
        user_id parameter to update another user's information.
      text: |-
        defmodule UserController do
          def update(conn, %{'id' => id, 'user' => user_params}) do
            user = Repo.get(User, id)
            changeset = User.changeset(user, user_params)
            Repo.update(changeset)
          end
        end
    language: elixir
    secure_code_example:
      description: The code below is secure because it uses the user_id stored in
        the session to fetch and update the user. Even if an attacker changes the
        user_id in the request parameters, it won't affect which user is updated because
        the user_id in the session is used.
      text: |-
        defmodule UserController do
          def update(conn, %{'user' => user_params}) do
            id = get_session(conn, :user_id)
            user = Repo.get(User, id)
            changeset = User.changeset(user, user_params)
            Repo.update(changeset)
          end
        end
    steps:
    - Store the authenticated user's id in the session after successful login.
    - Instead of getting the user id from request parameters, get it from the session.
    - Use the user id from the session to fetch and update the user.
  title: Insecure object reference - Personal information
  vulnerability_id: '286'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications
  - Usage of Ecto for data persistence
  need: Ensure that only authorized fields can be updated by the user
  solution:
    considerations:
    - Always define a whitelist of fields that can be updated to prevent unauthorized
      updates.
    - Consider adding role-based access control to further secure the application.
    insecure_code_example:
      description: The code below is insecure because it allows any field of the user
        to be updated without checking if the field is allowed to be updated. This
        could lead to unauthorized updates to fields that should be read-only after
        account creation, like 'email', or worse, 'admin' status.
      text: |-
        defmodule UserController do
          def update(conn, %{'user' => user_params, 'id' => id}) do
            user = Repo.get(User, id)
            changeset = User.changeset(user, user_params)
            Repo.update(changeset)
          end
        end
    language: elixir
    secure_code_example:
      description: The code below is secure because it only allows 'username' and
        'age' to be updated. The 'admin' and 'email' fields are not included in the
        whitelist, so they cannot be updated even if they are included in the user_params
        map.
      text: |-
        defmodule UserController do
          def update(conn, %{'user' => user_params, 'id' => id}) do
            user = Repo.get(User, id)
            changeset = User.changeset(user, user_params, ~w(username age)a)
            Repo.update(changeset)
          end
        end
    steps:
    - Define a whitelist of fields that can be updated.
    - Use the `Ecto.Changeset.cast/4` function to only allow updates to the whitelisted
      fields.
  title: Insecure functionality - Fingerprint
  vulnerability_id: '273'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  need: Ensure confidentiality and integrity of sensitive user data
  solution:
    considerations:
    - Always ensure that sensitive data is masked or removed from responses before
      sending.
    - Consider using HTTPS to further secure the communication.
    insecure_code_example:
      description: The code below is insecure because it directly uses user input
        to construct the response. Sensitive data like password is included in the
        response without being masked, which exposes the data to potential eavesdroppers
        or data breaches.
      text: |-
        defmodule UserController do
          def show(conn, %{'id' => id}) do
            user = Repo.get(User, id)
            conn
            |> put_resp_content_type('application/json')
            |> send_resp(200, Poison.encode!(user))
          end
        end
    language: elixir
    secure_code_example:
      description: The code below is secure because it masks the password field when
        sending the user data in the response. The `Map.drop/2` function is used to
        remove the sensitive data from the map before it is sent in the response.
      text: |-
        defmodule UserController do
          def show(conn, %{'id' => id}) do
            user = Repo.get(User, id) |> Map.drop([:password])
            conn
            |> put_resp_content_type('application/json')
            |> send_resp(200, Poison.encode!(user))
          end
        end
    steps:
    - Use pattern matching to exclude sensitive data from the user map before sending
      it in the response.
    - Use a separate data model for response that doesn't include sensitive fields.
  title: Insecure functionality - Masking
  vulnerability_id: '272'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications
  - Usage of Phoenix framework for web application development
  need: Secure password management
  solution:
    considerations:
    - Always make sure to validate user permissions on the server side, not just on
      the client side.
    - Consider using a more advanced authorization system if your application needs
      to handle complex permissions.
    insecure_code_example:
      description: "\n            This example represents a password update function\
        \ in a web application written in Elixir using the Phoenix framework. \n \
        \           The function does not verify whether the current user has the\
        \ right to change the password for the user id provided in the params.\n \
        \           An attacker can use this function to change the password of any\
        \ user, knowing only their user id.\n            "
      text: "\n            def update_password(conn, %{\"id\" => id, \"password\"\
        \ => password}) do\n                user = Accounts.get_user!(id)\n      \
        \          user\n                |> User.changeset(%{password: password})\n\
        \                |> Repo.update!()\n                conn\n               \
        \ |> put_flash(:info, \"Password updated successfully.\")\n              \
        \  |> redirect(to: \"/\")\n            end\n            "
    language: elixir
    secure_code_example:
      description: "\n            This is the secure version of the previous code.\
        \ \n            It includes a check to verify that the current user (taken\
        \ from the session) is the same user for whom the password is being changed.\n\
        \            "
      text: "\n            def update_password(conn, %{\"id\" => id, \"password\"\
        \ => password}) do\n                current_user = get_session(conn, :current_user)\n\
        \                if current_user.id == id do\n                    user = Accounts.get_user!(id)\n\
        \                    user\n                    |> User.changeset(%{password:\
        \ password})\n                    |> Repo.update!()\n                    conn\n\
        \                    |> put_flash(:info, \"Password updated successfully.\"\
        )\n                    |> redirect(to: \"/\")\n                else\n    \
        \                conn\n                    |> put_flash(:error, \"You do not\
        \ have permission to change this user's password.\")\n                   \
        \ |> redirect(to: \"/\")\n                end\n            end\n         \
        \   "
    steps:
    - Check if the current user's id matches the id in the parameters.
    - If not, return an error response.
  title: Insecure functionality - Password management
  vulnerability_id: '271'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir for building scalable and fault-tolerant applications
  - Usage of Phoenix web framework for building web applications
  need: Prevent unauthorized users from creating files
  solution:
    considerations:
    - The specifics of the permission check function would depend on how user roles
      and permissions are managed in your application.
    - Ensure that the permission check function is kept up-to-date as roles and permissions
      evolve.
    insecure_code_example:
      description: This code is vulnerable because it does not perform any access
        control check before creating a file. If a malicious user could craft a request
        to this endpoint, they could create a file regardless of their authorization
        level.
      text: "\n            defmodule MyApp.FileController do\n              use MyApp,\
        \ :controller\n            \n              def create(conn, %{\"file\" =>\
        \ file_params}) do\n                # Create a new file\n                {:ok,\
        \ file} = MyApp.File.create_file(file_params)\n            \n            \
        \    conn\n                |> put_status(:created)\n                |> render(\"\
        show.json\", file: file)\n              end\n            end\n            "
    language: elixir
    secure_code_example:
      description: In the secure version, the application checks if the current user
        has the necessary permissions to create a file before performing the action.
        If they do not, the request is denied.
      text: "\n            defmodule MyApp.FileController do\n              use MyApp,\
        \ :controller\n            \n              def create(conn, %{\"file\" =>\
        \ file_params}) do\n                # Check if the user has the necessary\
        \ permissions\n                if MyApp.Authorization.check_permission(conn.assigns[:current_user],\
        \ :create_file) do\n                  # Create a new file\n              \
        \    {:ok, file} = MyApp.File.create_file(file_params)\n            \n   \
        \               conn\n                  |> put_status(:created)\n        \
        \          |> render(\"show.json\", file: file)\n                else\n  \
        \                conn\n                  |> put_status(:forbidden)\n     \
        \             |> json(%{error: \"You do not have the necessary permissions\
        \ to perform this action.\"})\n                end\n              end\n  \
        \          end\n            "
    steps:
    - Implement an authorization check function (e.g., MyApp.Authorization.check_permission/2)
      that verifies if a user has a specific permission.
    - Before performing any sensitive operations (like creating a file), use this
      function to check if the current user has the necessary permissions.
    - If the user does not have the necessary permissions, deny the request.
  title: Unauthorized File Creation
  vulnerability_id: '270'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.12 and above) for building scalable and fault-tolerant
    applications
  - Usage of Ecto.Repo for interacting with databases
  need: To prevent injection of potentially malicious characters into application
    fields
  solution:
    considerations:
    - Always validate user input on the server side
    - Check the validity of the changeset before updating the user data
    insecure_code_example:
      description: The Elixir code allows a user to update their data without performing
        any server-side validation or checks on the user input, which could lead to
        injection of potentially malicious characters into application fields.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def update(conn, params) do
            user = MyApp.Repo.get!(User, params["id"])
            user = MyApp.Repo.update!(User.changeset(user, params))

            send_resp(conn, 200, "User data updated successfully")
          end
        end
    language: elixir
    secure_code_example:
      description: The secure Elixir code checks the validity of the changeset before
        updating the user data. This prevents the injection of potentially malicious
        characters into application fields.
      text: "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n \
        \ def update(conn, params) do\n    user = MyApp.Repo.get!(User, params[\"\
        id\"])\n    \n    changeset = User.changeset(user, params)\n    \n    if changeset.valid?\
        \ do\n      user = MyApp.Repo.update!(changeset)\n      send_resp(conn, 200,\
        \ \"User data updated successfully\")\n    else\n      send_resp(conn, 400,\
        \ \"Invalid data\")\n    end\n  end\nend"
    steps:
    - Validate user input on the server side
    - Check the validity of the changeset before updating the user data
  title: Insufficient data authenticity validation
  vulnerability_id: '204'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications
  - Usage of Ecto.Repo for interacting with databases
  need: To prevent unauthorized access to files
  solution:
    considerations:
    - Ensure that you always validate user input
    - Always check whether the user is authenticated and is the same user that is
      trying to update the data before giving access to sensitive resources
    insecure_code_example:
      description: The Elixir code allows a user to update their data and get access
        to a specific path in the Sharepoint. However, it doesn't perform any validation
        or checks on the user input, which could lead to unauthorized access to files.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def update(conn, params) do
            user = MyApp.Repo.get!(User, params["id"])
            user = MyApp.Repo.update!(User.changeset(user, params))

            path = "/sharepoint/files/#{user.id}/"
            send_resp(conn, 200, "File updated at #{path}")
          end
        end
    language: elixir
    secure_code_example:
      description: The secure Elixir code checks whether the user is authenticated
        and is the same user that is trying to update the data before giving access
        to the specific path in the Sharepoint.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def update(conn, params) do
            user = MyApp.Repo.get!(User, params["id"])
            user = MyApp.Repo.update!(User.changeset(user, params))

            if user && conn.assigns.current_user && conn.assigns.current_user.id == user.id do
              path = "/sharepoint/files/#{user.id}/"
              send_resp(conn, 200, "File updated at #{path}")
            else
              send_resp(conn, 403, "Unauthorized")
            end
          end
        end
    steps:
    - Validate user input
    - Check whether the user is authenticated
    - Check whether the authenticated user is the same user that is trying to update
      the data
    - Only give access to the specific path in the Sharepoint if the user is authenticated
      and is the same user that is trying to update the data
  title: Unauthorized access to files
  vulnerability_id: '201'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications
  - Usage of Ecto.Repo for interacting with databases
  need: To prevent SQL injection attacks
  solution:
    considerations:
    - Ensure that you always use parameterized queries when interacting with databases
    - Never directly interpolate user input into SQL queries
    insecure_code_example:
      description: The Elixir code directly interpolates user input into a SQL query,
        which could lead to SQL injection attacks if the user input is not properly
        sanitized.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def index(conn, params) do
            users = MyApp.Repo.query!("SELECT * FROM users WHERE name = '#{params["name"]}'")
            render conn, "index.html", users: users
          end
        end
    language: elixir
    secure_code_example:
      description: The secure Elixir code uses parameterized queries to prevent SQL
        injection attacks. The user input is no longer directly interpolated into
        the SQL query, but instead, it is passed as a parameter to the query.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def index(conn, params) do
            users = MyApp.Repo.query!("SELECT * FROM users WHERE name = $1", [params["name"]])
            render conn, "index.html", users: users
          end
        end
    steps:
    - Use parameterized queries instead of directly interpolating user input into
      SQL queries
    - Pass the user input as a parameter to the query
  title: Time-based SQL Injection
  vulnerability_id: '154'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.12+) for building scalable and concurrent applications
  - Usage of Plug.Router for handling HTTP requests
  need: To prevent unexpected behaviors due to content type misinterpretations
  solution:
    considerations:
    - Ensure that your web server supports the Content-Type header
    - Test your web application thoroughly after making this change to ensure that
      it does not break any functionality
    insecure_code_example:
      description: The Elixir code does not set the Accept header or validate the
        Content-Type of the incoming requests. This could lead to unexpected behaviors
        when the application interprets incorrect content types.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          match _ do
            send_resp(conn, 200, "Hello, world!")
          end
        end
    language: elixir
    secure_code_example:
      description: The secure Elixir code checks the Content-Type of the incoming
        requests and only allows application/json. If the Content-Type is different,
        the application responds with a 406 Not Acceptable status code.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          match _ do
            case get_req_header(conn, "content-type") do
              ["application/json"] -> send_resp(conn, 200, "Hello, world!")
              _ -> send_resp(conn, 406, "Not Acceptable")
            end
          end
        end
    steps:
    - Check the Content-Type of the incoming requests
    - Only allow the application/json content type
    - Respond with a 406 Not Acceptable status code if the Content-Type is different
  title: Insecure or unset HTTP headers - Accept
  vulnerability_id: '153'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications
  - Usage of Plug.Router for handling HTTP requests
  need: To prevent clickjacking attacks
  solution:
    considerations:
    - Ensure that your web server supports the Content-Security-Policy header
    - Test your web application thoroughly after making this change to ensure that
      it does not break any functionality
    insecure_code_example:
      description: The Elixir code sets the X-Frame-Options header to SAMEORIGIN.
        This header is deprecated and can be bypassed using several iframe layers,
        making it vulnerable to clickjacking attacks.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          match _ do
            send_resp(conn, 200, "Hello, world!")
          end

          defp put_headers(conn) do
            put_resp_header(conn, "x-frame-options", "SAMEORIGIN")
          end
        end
    language: elixir
    secure_code_example:
      description: The secure Elixir code sets the Content-Security-Policy header
        with the frame-ancestors 'self' directive, which is a more secure replacement
        for the X-Frame-Options header.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          match _ do
            send_resp(conn, 200, "Hello, world!")
          end

          defp put_headers(conn) do
            put_resp_header(conn, "content-security-policy", "frame-ancestors 'self'")
          end
        end
    steps:
    - Replace the X-Frame-Options header with the Content-Security-Policy header
    - Set the frame-ancestors directive to 'self' to allow the page to be framed only
      by pages from the same origin
  title: Insecure or unset HTTP headers - X-Frame Options
  vulnerability_id: '152'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.12 and above) for building scalable and fault-tolerant
    applications
  - Usage of Phoenix framework for building real-time web applications
  - User authentication implementation
  need: To prevent unauthorized access to user data
  solution:
    considerations:
    - Ensure that the get_current_user and user_can_access_documents? functions are
      properly implemented
    - Consider using role-based access control (RBAC) or similar mechanism to manage
      user permissions
    insecure_code_example:
      description: The Elixir code directly uses the date parameter from the URL to
        fetch documents. There are no checks to verify if the current user has the
        rights to access these documents.
      text: |-
        defmodule PortalController do
          use PortalWeb, :controller

          def show(conn, %{"date" => date}) do
            docs = Portal.get_documents_by_date(date)
            render(conn, "show.html", docs: docs)
          end
        end
    language: elixir
    secure_code_example:
      description: The secure Elixir code first gets the current user. If the user
        exists and they have the necessary permissions to access the documents, we
        proceed as before. Otherwise, we display an error message and redirect the
        user to the home page.
      text: |-
        defmodule PortalController do
          use PortalWeb, :controller

          def show(conn, %{"date" => date}) do
            user = get_current_user(conn)
            if user and Portal.user_can_access_documents?(user) do
              docs = Portal.get_documents_by_date(date)
              render(conn, "show.html", docs: docs)
            else
              conn
              |> put_flash(:error, "You are not authorized to access this page.")
              |> redirect(to: "/")
            end
          end
        end
    steps:
    - Retrieve the current user
    - Check if the user has the necessary permissions to access the documents
    - If the user is authorized, proceed as before
    - If the user is not authorized, display an error message and redirect them to
      the home page
  title: Lack of Data Validation - URL
  vulnerability_id: '141'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of sweet_xml for parsing and manipulating XML data
  - Usage of XML data manipulation
  need: Prevent unauthorized data access through XPath Injection
  solution:
    considerations:
    - All user-supplied input should be properly sanitized
    - Consider using parameterized XPath queries to prevent injections
    - Never build dynamic XPath queries with string concatenation
    insecure_code_example:
      description: The code is vulnerable because it takes a user-provided value (`user_input`)
        directly to construct an XPath expression. An attacker could exploit this
        to modify the XPath query and potentially access sensitive information.
      text: |-
        def vulnerable(user_input) do
          {:ok, doc} = File.read('data.xml')
          xpath = "//user[username/text() = '" <> user_input <> "']"
          SweetXml.xpath(doc, xpath)
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it sanitizes the user input by escaping
        special characters before using it in the XPath expression. It ensures that
        the user input is treated as literal text, not part of the XPath expression,
        preventing injection attacks.
      text: |-
        def secure(user_input) do
          {:ok, doc} = File.read('data.xml')
          sanitized_input = String.replace(user_input, "'", "''")
          xpath = "//user[username/text() = '" <> sanitized_input <> "']"
          SweetXml.xpath(doc, xpath)
        end
    steps:
    - Upgrade to the latest version of Elixir and the sweet_xml library if not done
      already
    - Always sanitize user-provided input before using in XPath expressions
    - Use parameterized queries instead of string concatenation to build XPath expressions
  title: XPath Injection Vulnerability
  vulnerability_id: '021'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.13.0 for building scalable and fault-tolerant applications
  - Usage of Ecto for database query and manipulation
  - Usage of Phoenix.HTML for building HTML
  - Usage of application state management for dynamic content generation
  need: Prevent persistent injection of malicious scripts into application fields
  solution:
    insecure_code_example:
      description: This vulnerable code saves user-provided messages directly to the
        database without sanitizing the input first. Then it uses this data to generate
        dynamic content on the index page. An attacker can store a malicious script
        in the message, which will be executed by the user's browser when the index
        page is loaded.
      text: |-
        defmodule VulnerableController do
          use MyWeb, :controller

          def create(conn, %{"message" => message_params}) do
            %Message{} |> Message.changeset(message_params) |> Repo.insert()
            redirect(conn, to: message_path(conn, :index))
          end

          def index(conn, _params) do
            messages = Repo.all(Message)
            render(conn, "index.html", messages: messages)
          end
        end
    language: elixir
    secure_code_example:
      description: The secure code uses the 'h' function from the Phoenix.HTML package
        to sanitize user-provided input before saving it to the database. This ensures
        that any HTML special characters in the input are escaped, preventing them
        from being interpreted as part of the HTML markup. This mitigates the stored
        XSS vulnerability by preventing scripts from being stored and later executed
        in the user's browser.
      text: |-
        defmodule SecureController do
          use MyWeb, :controller
          use Phoenix.HTML

          def create(conn, %{"message" => message_params}) do
            sanitized_params = %{"content" => h(message_params["content"])}
            %Message{} |> Message.changeset(sanitized_params) |> Repo.insert()
            redirect(conn, to: message_path(conn, :index))
          end

          def index(conn, _params) do
            messages = Repo.all(Message)
            render(conn, "index.html", messages: messages)
          end
        end
    steps:
    - Use the functions provided by the Phoenix.HTML package to sanitize user input
      before storing it in the database.
    - Replace raw database data with the 'h' function from Phoenix.HTML when generating
      dynamic content.
  title: Stored Cross-Site Scripting (XSS)
  vulnerability_id: '010'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.13.0 for building scalable and fault-tolerant applications
  - Usage of Plug for request management
  - Dynamic content generation
  need: Prevent injection of malicious scripts into dynamically generated web content
  solution:
    insecure_code_example:
      description: The '/search' endpoint uses user-provided input directly in the
        output content. If an attacker provides a script as part of the 'query' parameter,
        this script will be reflected back in the response and executed by the user's
        browser, resulting in a reflected XSS vulnerability.
      text: |-
        defmodule VulnerableController do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/search" do
            results = Search.query(conn.params["query"])
            send_resp(conn, 200, "Search results for: #{conn.params["query"]}")
          end
        end
    language: elixir
    secure_code_example:
      description: This solution introduces the use of the 'h' function from the Phoenix.HTML
        package to sanitize user-provided input. It ensures that any HTML special
        characters in the input are escaped, preventing them from being interpreted
        as part of the HTML markup. This prevents scripts from being executed in the
        user's browser, mitigating the reflected XSS vulnerability.
      text: |-
        defmodule SecureController do
          use Plug.Router
          use Phoenix.HTML

          plug :match
          plug :dispatch

          get "/search" do
            results = Search.query(conn.params["query"])
            safe_query = Phoenix.HTML.raw(h(conn.params["query"]))
            send_resp(conn, 200, "Search results for: #{safe_query}")
          end
        end
    steps:
    - Use the functions provided by the Phoenix.HTML package to sanitize user input
      before including it in dynamic content.
    - Replace string interpolation with the 'h' function from Phoenix.HTML when generating
      dynamic content.
  title: Reflected Cross-Site Scripting (XSS)
  vulnerability_id: '008'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.13.0 for functional programming and building scalable applications
  - Usage of Plug for request management
  - Usage of Plug.CSRFProtection for protecting against CSRF attacks
  - Usage of cookie-based sessions for application authentication and state management
  need: Prevent attackers from tricking authenticated users into executing actions
    without their consent.
  solution:
    insecure_code_example:
      description: The endpoint '/change_password' changes the password of a user
        based on the provided parameters. However, it does not validate the authenticity
        of the request, making it vulnerable to CSRF attacks. An attacker can create
        a malicious site that sends a POST request to this endpoint, changing the
        password without the user's knowledge or consent.
      text: |-
        defmodule VulnerableController do
          use Plug.Router

          plug :match
          plug :dispatch

          post "/change_password" do
            # Change password logic here
            User.change_password(conn.params["new_password"])
            send_resp(conn, 200, "Password changed successfully")
          end
        end
    language: elixir
    secure_code_example:
      description: This solution introduces CSRF protection by including Plug.CSRFProtection
        in the controller. This plug will automatically generate and validate CSRF
        tokens in the session. Any state-modifying operation will require a valid
        CSRF token, otherwise, a 'Invalid CSRF token.' message is returned to the
        client, thus preventing CSRF attacks.
      text: |-
        defmodule SecureController do
          use Plug.Router
          use Plug.CSRFProtection

          plug :match
          plug :dispatch
          plug :put_secure_browser_headers

          post "/change_password" do
            with :ok <- check_csrf_token(conn) do
              User.change_password(conn.params["new_password"])
              send_resp(conn, 200, "Password changed successfully")
            else
              _ -> send_resp(conn, 403, "Invalid CSRF token.")
            end
          end
        end
    steps:
    - Import the Plug.CSRFProtection package in your controller.
    - Add a plug to the controller to use CSRF protection.
    - Ensure every form or action that modifies state on the server includes the CSRF
      token in the request.
  title: Cross-Site Request Forgery
  vulnerability_id: '007'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.13.0 for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for request management
  - Usage of a library for handling extensive data processing or resource-intensive
    tasks
  need: Prevent a sequence of repeated requests from consuming excessive resources,
    leading to denial of service.
  solution:
    insecure_code_example:
      description: The endpoint '/long_running_task' executes a long running task
        which can consume significant system resources. An attacker can exploit this
        by making repeated requests, causing the system to become overwhelmed and
        potentially leading to denial of service.
      text: |-
        defmodule VulnerableController do
          use Plug.Router

          plug :match
          plug :dispatch

          post "/long_running_task" do
            # Long running task here
            intensive_data_processing(conn.params["data"])
            send_resp(conn, 200, "Task completed")
          end
        end
    language: elixir
    secure_code_example:
      description: This solution implements rate limiting using the plug_attack package
        and adds a timeout to the long running task. These changes help ensure that
        no sequence of repeated requests can consume too many resources, thus mitigating
        the denial of service risk. If the task doesn't finish within the specified
        time, a 'Server is busy. Please try again later.' message is sent to the client.
      text: |-
        defmodule SecureController do
          use Plug.Router
          use PlugAttack

          plug :match
          plug :dispatch
          plug PlugAttack.Blocker, otp_app: :my_app

          plug PlugAttack.RateLimiter,
            name: "api/ip",
            interval: 60_000,
            allow: 100

          post "/long_running_task" do
            with {:ok, _result} <- Task.await(long_running_task(conn.params["data"]), 5000) do
              send_resp(conn, 200, "Task completed")
            else
              _ -> send_resp(conn, 503, "Server is busy. Please try again later.")
            end
          end
        end
    steps:
    - Implement rate limiting using the plug_attack package to limit the number of
      requests a single client can make in a given period of time.
    - Implement a timeout for long running tasks to prevent operations from consuming
      resources indefinitely.
    - Handle potential errors or exceptions during the data processing to prevent
      crashes.
  title: Symmetric Denial of Service
  vulnerability_id: '003'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir 1.13.0 for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for request management
  - Usage of a library for handling extensive data processing or resource-intensive
    tasks
  need: Prevent single requests from overwhelming the application by using excessive
    resources, thus causing denial of service.
  solution:
    insecure_code_example:
      description: The endpoint '/intensive_task' performs intensive data processing
        which can consume significant system resources. An attacker can exploit this
        by making repeated or specially crafted requests, causing the system to become
        overwhelmed and potentially resulting in denial of service.
      text: |-
        defmodule VulnerableController do
          use Plug.Router

          plug :match
          plug :dispatch

          post "/intensive_task" do
            # Some resource-intensive task here
            intensive_data_processing(conn.params["data"])
            send_resp(conn, 200, "Task completed")
          end
        end
    language: elixir
    secure_code_example:
      description: This solution implements rate limiting using the plug_attack package
        and adds a timeout to the resource-intensive task. These changes help ensure
        that no single request or user can consume too many resources, thus mitigating
        the denial of service risk. If the task doesn't finish within the specified
        time, a 'Server is busy. Please try again later.' message is sent to the client.
      text: |-
        defmodule SecureController do
          use Plug.Router
          use PlugAttack

          plug :match
          plug :dispatch
          plug PlugAttack.Blocker, otp_app: :my_app

          plug PlugAttack.RateLimiter,
            name: "api/ip",
            interval: 60_000,
            allow: 100

          post "/intensive_task" do
            with {:ok, _result} <- Task.await(intensive_data_processing(conn.params["data"]), 5000) do
              send_resp(conn, 200, "Task completed")
            else
              _ -> send_resp(conn, 503, "Server is busy. Please try again later.")
            end
          end
        end
    steps:
    - Implement rate limiting using the plug_attack package to limit the number of
      requests a single client can make in a given period of time.
    - Implement a timeout for intensive data processing task to prevent operations
      from consuming resources indefinitely.
    - Handle potential errors or exceptions during the data processing to prevent
      crashes.
  title: Asymmetric Denial of Service
  vulnerability_id: '002'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Logger module for logging and debugging purposes
  need: Prevent exposure of sensitive information through metadata.
  solution:
    considerations:
    - Always consider the sensitivity of the data being logged and who can access
      those logs.
    - Always comply with data protection regulations and company policies when handling
      sensitive data.
    insecure_code_example:
      description: This code can be vulnerable as it logs the entire connection object,
        including potentially sensitive information such as headers or parameters.
        If these logs are accessible, it could lead to an information leak.
      text: |-
        defmodule MyController do
          use Plug.Logger

          def handle_request(conn, _params) do
            Logger.debug(fn -> inspect(conn) end)
            send_resp(conn, 200, "OK")
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safer as it only logs a generic message, instead of
        the entire connection object. Thus, no sensitive information is logged.
      text: |-
        defmodule MyController do
          use Plug.Logger

          def handle_request(conn, _params) do
            Logger.debug(fn -> "Processing request" end)
            send_resp(conn, 200, "OK")
          end
        end
    steps:
    - Avoid logging sensitive information, such as keys, secrets or personally identifiable
      information.
    - If sensitive data needs to be logged for debugging purposes, ensure it is appropriately
      masked or anonymized.
    - Consider using a log management solution that provides access control, encryption
      and log retention capabilities.
  title: Metadata with Sensitive Information
  vulnerability_id: '119'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and concurrent applications
  - Usage of Mix for managing assets in Laravel
  need: Prevent installation of unsupported or vulnerable dependencies.
  solution:
    considerations:
    - Regularly updating dependencies can be a challenge due to potential incompatibilities
      and the need for testing.
    - Dependency management requires a balance between maintaining security, ensuring
      compatibility, and taking advantage of new features or performance improvements
      in newer versions.
    insecure_code_example:
      description: This code can be vulnerable as it specifies a minimum version for
        'plug', which means any version higher than 1.0.0 could be installed, including
        potentially incompatible or vulnerable versions. The cowboy dependency uses
        a version range which could potentially install a version with known vulnerabilities.
      text: |-
        defp deps do
          [
            {:plug, ">= 1.0.0"},
            {:cowboy, "~> 2.1"}
          ]
        end
    language: elixir
    secure_code_example:
      description: This code is safer as it specifies the exact versions of the dependencies
        to be used. This ensures that known, compatible versions are installed, reducing
        the risk of installing incompatible or vulnerable dependencies.
      text: |-
        defp deps do
          [
            {:plug, "1.12.1"},
            {:cowboy, "2.8.0"}
          ]
        end
    steps:
    - Specify the exact versions of the dependencies.
    - Regularly update the dependencies and thoroughly test the application after
      updates.
  title: Improper Dependency Pinning
  vulnerability_id: '120'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant
    applications
  - Usage of Bamboo library for sending emails
  need: Prevent uncontrolled email sending that can lead to inbox saturation or spamming.
  solution:
    considerations:
    - Even with rate limiting, be mindful of the total number of emails your application
      sends to avoid hitting email service provider limits or being marked as spam.
    - Rate limiting can potentially delay important emails if there are a lot of less
      important emails in the queue.
    insecure_code_example:
      description: In this example, the handle_request function sends an email to
        every user in a request without any rate limiting. This allows for potential
        email flooding if the users list is large or if requests are sent consecutively
        with little time in between.
      text: |-
        def send_email(user, message) do
          new_email(to: user.email, subject: "Alert", body: message)
          |> Mailer.deliver_now()
        end

        def handle_request(request) do
          Enum.each(request.users, &send_email(&1, request.message))
        end
    language: elixir
    secure_code_example:
      description: This code introduces rate limiting by using the deliver_later()
        function, which queues the emails for later delivery rather than sending them
        immediately. It also limits the number of users that can receive an email
        in a single request to 100.
      text: |-
        def send_email(user, message) do
          new_email(to: user.email, subject: "Alert", body: message)
          |> Mailer.deliver_later()
        end

        def handle_request(request) do
          request.users
          |> Enum.take(100)
          |> Enum.each(&send_email(&1, request.message))
        end
    steps:
    - Introduce a delay between each email send.
    - Limit the number of emails that can be sent in a given time period.
    - Validate and sanitize user input to prevent abuse.
  title: Email Flooding
  vulnerability_id: '122'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Plug.Static library for serving static files in Elixir
  need: Prevent unauthorized listing of directory contents that could reveal sensitive
    information or application structure.
  solution:
    considerations:
    - Even with the correct settings, ensure that sensitive files are not placed in
      the directories served statically as they may be accessible with a direct URL.
    - Ensure that your server software is up-to-date to avoid known vulnerabilities
      that could circumvent your settings.
    insecure_code_example:
      description: This configuration in the endpoint.ex file serves static assets
        from the root directory and its subdirectories. If the server is incorrectly
        configured or if an index file is not present, it allows anyone to list all
        files in these directories.
      text: "plug Plug.Static, \n  at: \"/\",\n  from: :app,\n  gzip: false,\n  only:\
        \ ~w(css fonts images js favicon.ico robots.txt)"
    language: elixir
    secure_code_example:
      description: The 'index' option is added to the configuration. This enforces
        the 'index.html' file to be served when a directory is accessed. Thus, the
        content of the directory is not listed and the vulnerability is mitigated.
      text: "plug Plug.Static, \n  at: \"/\",\n  from: :app,\n  gzip: false,\n  index:\
        \ 'index.html',\n  only: ~w(css fonts images js favicon.ico robots.txt)"
    steps:
    - Disable directory listing in the server settings.
    - Enforce an index file to be served when a directory is accessed.
    - Ensure that only necessary files are publicly accessible.
  title: Directory Listing
  vulnerability_id: '125'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Plug for HTTP request and response handling
  need: Prevent caching of sensitive data by client browsers and intermediate proxies
  solution:
    considerations:
    - Remember to set Cache-Control headers on all routes in your application, not
      just the ones shown in this example.
    - Consider using a framework or reverse proxy that can handle this for you automatically.
    insecure_code_example:
      description: In this code, the application responds to every request with 'Hello,
        world!' but does not set any Cache-Control headers. This could lead to sensitive
        data being cached by the client browser or intermediate proxies.
      text: |-
        defmodule MyApp do
          use Plug.Builder
          def start_link(_) do
            Plug.Adapters.Cowboy.http __MODULE__, []
          end
          plug :index
          def index(conn, _opts) do
            conn
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Hello, world!")
          end
        end
    language: elixir
    secure_code_example:
      description: In this revised code, the application sets a Cache-Control header
        with the value 'no-store, no-cache, must-revalidate' on all responses. This
        instructs the client browser and any intermediate proxies not to store the
        response, thereby preventing the caching of sensitive data.
      text: |-
        defmodule MyApp do
          use Plug.Builder
          def start_link(_) do
            Plug.Adapters.Cowboy.http __MODULE__, []
          end
          plug :index
          def index(conn, _opts) do
            conn
            |> put_resp_header("cache-control", "no-store, no-cache, must-revalidate")
            |> put_resp_content_type("text/plain")
            |> send_resp(200, "Hello, world!")
          end
        end
    steps:
    - Update the application to set appropriate Cache-Control headers on all responses.
      The specific value will depend on your application, but 'no-store, no-cache,
      must-revalidate' is a common secure value.
  title: Insecure or unset HTTP headers - Cache Control
  vulnerability_id: '136'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of HTTPoison for making HTTP requests in Elixir
  need: Prevent exposure of sensitive data in the source code
  solution:
    considerations:
    - Remember to actually set the environment variable in your server environment,
      with a value that is kept secret.
    - Consider using a secrets management service for more secure handling of API
      keys and other sensitive information.
    - Remember not to include actual API keys in your code or version control history.
    insecure_code_example:
      description: In this code, the application has a secret API key hardcoded directly
        in the source code. This is dangerous because anyone with access to the source
        code can see and potentially misuse the API key. Even if the source code is
        not intended to be public, it can be accidentally exposed, or access could
        be obtained through a breach.
      text: |-
        defmodule MyApp do
          @api_key "MySecretApiKey"
          def request_data do
            HTTPoison.get!("https://example.com/data", [], [params: ["api_key": @api_key]])
          end
        end
    language: elixir
    secure_code_example:
      description: In this revised code, the application loads the API key from an
        environment variable. This is safer because the actual value of the API key
        is not included in the source code, and can be managed securely on the server.
        This prevents the API key from being exposed if the source code is accidentally
        made public or accessed through a breach.
      text: |-
        defmodule MyApp do
          def request_data do
            api_key = System.get_env("API_KEY")
            HTTPoison.get!("https://example.com/data", [], [params: ["api_key": api_key]])
          end
        end
    steps:
    - Store the API key in an environment variable rather than hardcoding it in the
      source code.
    - Load the API key from the environment variable in your Elixir code.
  title: Sensitive information in source code - API Key
  vulnerability_id: '142'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications with Elixir
  need: Enhance maintainability and security of the code
  solution:
    considerations:
    - When decomposing complex functions, consider creating helper functions that
      encapsulate specific logic.
    - Remember that maintaining low cyclomatic complexity is not only about improving
      readability but also about making the code easier to test and less error-prone.
    insecure_code_example:
      description: In this code, the function `complex_function` has a high cyclomatic
        complexity due to multiple nested if-else statements. High cyclomatic complexity
        makes the code difficult to read, maintain, and test. It could also increase
        the probability of bugs or vulnerabilities, as it's harder to understand all
        possible execution paths.
      text: |-
        defmodule Unsafe do
          def complex_function(a, b, c, d) do
            if a do
              if b do
                if c do
                  if d do
                    IO.puts 'abcd'
                  else
                    IO.puts 'abc'
                  end
                else
                  IO.puts 'ab'
                end
              else
                IO.puts 'a'
              end
            else
              IO.puts 'none'
            end
          end
        end
    language: elixir
    secure_code_example:
      description: In this revised code, the function `simple_function` is much easier
        to read and understand. It uses the `cond` statement to clearly show the different
        conditions and their outcomes. This reduces the cyclomatic complexity and
        makes the function easier to test and maintain.
      text: |-
        defmodule Safe do
          def simple_function(a, b, c, d) do
            cond do
              a && b && c && d -> IO.puts 'abcd'
              a && b && c -> IO.puts 'abc'
              a && b -> IO.puts 'ab'
              a -> IO.puts 'a'
              true -> IO.puts 'none'
            end
          end
        end
    steps:
    - Decompose the function into smaller, simpler functions
    - Replace nested if-else statements with cleaner control structures, like pattern
      matching
  title: Inappropriate coding practices - Cyclomatic complexity
  vulnerability_id: '145'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of PostgreSQL database for data storage and retrieval
  - Usage of Ecto for database handling
  need: Prevent unauthorized extraction or manipulation of data in the database
  solution:
    considerations:
    - Even with the usage of Ecto's Query API, never trust user input - always sanitize
      and validate.
    - Avoid exposing detailed error messages to the user, as they can reveal information
      about the database schema.
    - Ensure to limit the database permissions for the application's database user.
    insecure_code_example:
      description: The code above is vulnerable to SQL Injection because it directly
        concatenates a user-provided string (id) into a SQL query. An attacker could
        provide a malicious string that alters the SQL query to expose sensitive data
        or execute unauthorized SQL commands.
      text: |-
        def get_user_data(conn, %{"id" => id}) do
         Repo.query("SELECT * FROM users WHERE id = " <> id)
        end
    language: elixir
    secure_code_example:
      description: The code above is secure because it uses Ecto's query API to construct
        the SQL query, which automatically escapes variables to prevent SQL Injection.
        It also converts the user input to an integer, providing an extra layer of
        security.
      text: |-
        def get_user_data(conn, %{"id" => id}) do
          id = String.to_integer(id)
          query = from u in "users", where: u.id == ^id
          Repo.one(query)
        end
    steps:
    - Utilize Ecto.Query API to create SQL queries instead of string concatenation.
    - Always validate and sanitize user inputs before using them in SQL queries.
    - Limit the permissions of the database user used by the application.
  title: SQL Injection
  vulnerability_id: '146'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Swoosh library for email sending
  need: Ensure confidentiality and integrity of data during transmission
  solution:
    considerations:
    - Ensure that the SMTP server has a valid SSL/TLS certificate.
    - Remember to keep the SSL/TLS versions up-to-date according to the latest security
      standards.
    - Avoid logging sensitive information sent over email.
    insecure_code_example:
      description: 'The code above is vulnerable because it sends an email using the
        Swoosh SMTP adapter without encryption (tls: :none). This means that all data
        sent in the email can be easily intercepted and read by any party that can
        listen on the network.'
      text: |-
        def send_email(email) do
          {:ok, pid} = Swoosh.Adapters.SMTP.start_link(port: 25, tls: :none)
          email |> MyApp.Mailer.deliver(pid)
        end
    language: elixir
    secure_code_example:
      description: The secure code uses the SMTPS protocol which operates on port
        465 and uses SSL/TLS to encrypt the communication channel. The 'ssl_opts'
        option is set to use TLS version 1.2 which is currently considered secure.
      text: |-
        def send_email(email) do
          {:ok, pid} = Swoosh.Adapters.SMTP.start_link(port: 465, tls: :always, ssl_opts: [{:versions, [:'tlsv1.2']}])
          email |> MyApp.Mailer.deliver(pid)
        end
    steps:
    - Enable SSL/TLS in the SMTP settings.
    - Ensure the use of valid and trusted certificates.
    - Perform periodic reviews and updates of security configurations.
  title: Use of Insecure SMTP Channel
  vulnerability_id: '149'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug.Conn for handling requests
  - Usage of Ecto for database operations
  need: Ensure integrity and confidentiality of data and prevent unauthorized database
    operations
  solution:
    considerations:
    - Always be wary of user inputs and where they are being used.
    - Stay updated with the latest security vulnerabilities and their solutions.
    - In addition to securing your application, secure your database as well by following
      the principle of least privilege.
    insecure_code_example:
      description: The code above is vulnerable as it uses the 'idClient' header value
        directly in a SQL query. This allows an attacker to inject arbitrary SQL code
        into the query through the 'idClient' header.
      text: |-
        def handle_req(%Plug.Conn{headers: headers} = conn, _) do
          id_client = List.keyfind(headers, "idClient", 0) |> elem(1)
          MyApp.Repo.query("SELECT * FROM clients WHERE id = #{id_client}")
        end
    language: elixir
    secure_code_example:
      description: The secure code uses query binding to create the SQL query, which
        ensures the input from 'idClient' header is properly escaped and treated as
        a value, not a part of the SQL command. This prevents SQL Injection attacks.
      text: |-
        def handle_req(%Plug.Conn{headers: headers} = conn, _) do
          id_client = List.keyfind(headers, "idClient", 0) |> elem(1)
          MyApp.Repo.query("SELECT * FROM clients WHERE id = ?", [id_client])
        end
    steps:
    - Use query binding instead of string interpolation to create SQL queries.
    - Ensure user input can't modify the intended SQL query structure.
    - Regularly update your dependencies to include patches for security vulnerabilities.
  title: SQL Injection via Headers
  vulnerability_id: '155'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug.Conn for handling requests
  need: Prevent unauthorized redirection to potentially malicious external sites
  solution:
    considerations:
    - Always be wary of user inputs and where they are being used.
    - Stay updated with the latest security vulnerabilities and their solutions.
    - Ensure proper error handling for edge cases such as when the 'redirect_to' parameter
      is not provided or is not in the whitelist.
    insecure_code_example:
      description: The code above is vulnerable as it takes a 'redirect_to' parameter
        from the request and uses it directly to redirect the user. An attacker can
        manipulate the 'redirect_to' parameter to redirect users to a malicious website.
      text: |-
        def handle_req(%Plug.Conn{params: params} = conn, _) do
          redirect_to = Map.get(params, "redirect_to")
          conn |> redirect(external: redirect_to)
        end
    language: elixir
    secure_code_example:
      description: The secure code checks the 'redirect_to' parameter against a list
        of allowed URLs before making the redirection. This ensures that the user
        can't be redirected to a malicious website even if they manipulate the 'redirect_to'
        parameter.
      text: |-
        def handle_req(%Plug.Conn{params: params} = conn, _) do
          redirect_to = Map.get(params, "redirect_to")
          allowed_urls = ["http://safe1.com", "http://safe2.com"]
          if redirect_to in allowed_urls, do: conn |> redirect(external: redirect_to)
        end
    steps:
    - Do not use user-provided inputs to set the 'external' option in the redirect
      function.
    - If you have to redirect based on user inputs, maintain a whitelist of allowed
      URLs and check against it.
    - Regularly update your dependencies to include patches for security vulnerabilities.
  title: Uncontrolled External Site Redirect
  vulnerability_id: '156'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug.Upload for file handling
  need: Prevent upload of files with double extensions or unsafe extensions
  solution:
    considerations:
    - Regularly update the list of allowed file extensions based on the application's
      requirements.
    - Keep the antivirus software or the antivirus API up-to-date to detect the latest
      threats.
    - Consider implementing a file size limit to prevent DoS attacks.
    insecure_code_example:
      description: The code above is vulnerable as it accepts any uploaded file without
        validating its extension or content. This can allow an attacker to upload
        a file with a double extension or an unsafe extension like .html, .php, .exe,
        or files containing malicious code.
      text: |-
        def upload_file(conn, %{"file" => %Plug.Upload{} = upload}) do
          {:ok, file_path} = File.cp(upload.path, "/uploads/#{upload.filename}")
          send_resp(conn, 200, "File Uploaded Successfully")
        end
    language: elixir
    secure_code_example:
      description: The secure code validates the uploaded file's extension and ensures
        it's in a list of allowed extensions. It also scans the file for any malicious
        content using an antivirus software API. This effectively mitigates the risk
        of uploading files with double extensions, unsafe extensions, or files containing
        malicious code.
      text: |-
        def upload_file(conn, %{"file" => %Plug.Upload{} = upload}) do
          allowed_extensions = ~w(.jpg .jpeg .png)
          file_extension = Path.extname(upload.filename)
          if file_extension in allowed_extensions and antivirus_scan(upload.path) do
            {:ok, file_path} = File.cp(upload.path, "/uploads/#{upload.filename}")
            send_resp(conn, 200, "File Uploaded Successfully")
          else
            send_resp(conn, 400, "Invalid File")
          end
        end

        defp antivirus_scan(file_path) do
          # Call antivirus API
        end
    steps:
    - Add a validation function to check the file's extension and ensure it's in a
      list of safe extensions.
    - Use an antivirus software API to scan the uploaded file for malicious content
      before saving it to the server.
    - Ensure the 'Content-Type' of the file matches the file's extension.
  title: Insecure File Upload
  vulnerability_id: '027'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug for request handling
  - Usage of Phoenix framework for building web applications
  need: Prevent automated attacks designed to guess credentials
  solution:
    considerations:
    - Ensure that the rate limiting and CAPTCHA systems are regularly updated and
      properly configured according to the application's needs.
    - Consider using a third-party service for CAPTCHA and rate limiting for added
      security and ease of implementation.
    - Remember that CAPTCHA and rate limiting mechanisms can sometimes interfere with
      the user experience, so it is important to strike a balance between security
      and usability.
    insecure_code_example:
      description: This code is vulnerable because it does not implement any control
        mechanism against brute force attacks. It simply checks if the credentials
        are valid and responds accordingly. This allows an attacker to try different
        combinations of usernames and passwords until they find a match.
      text: |-
        def handle_post(%{params: %{"username" => username, "password" => password}} = conn, _opts) do
          if Users.validate_credentials(username, password) do
            conn |> send_resp(200, "Logged in!")
          else
            conn |> send_resp(401, "Invalid credentials")
          end
        end
    language: elixir
    secure_code_example:
      description: The secure code integrates a rate limiting mechanism using the
        RateLimiter module, which limits the number of login attempts for the same
        username. It also includes a CAPTCHA system using the Captcha module. If either
        the rate limit has been reached or the CAPTCHA verification fails, the user
        is not allowed to attempt to log in.
      text: |-
        def handle_post(%{params: %{"username" => username, "password" => password}} = conn, _opts) do
          if RateLimiter.allow_request(username) and Captcha.verify(conn.params["captcha"]) and Users.validate_credentials(username, password) do
            conn |> send_resp(200, "Logged in!")
          else
            conn |> send_resp(401, "Invalid credentials or too many attempts")
          end
        end

        defmodule RateLimiter do
          def allow_request(username) do
            # Rate limiting logic here
          end
        end

        defmodule Captcha do
          def verify(captcha_response) do
            # Captcha verification logic here
          end
        end
    steps:
    - Integrate a rate limiting mechanism in your application to limit the number
      of login attempts from the same IP address or for the same username in a certain
      period.
    - Use a CAPTCHA system to prevent automated scripts from making login attempts.
    - Implement account lockout policy after a certain number of failed login attempts.
  title: Lack of Protection Against Brute Force Attacks
  vulnerability_id: '053'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug for request handling
  - Usage of Phoenix framework for building web applications
  - Usage of Logger for standard logging
  need: Prevent compromising log integrity or system safety by log injection
  solution:
    considerations:
    - While sanitizing user inputs for logging is a good defensive practice, it might
      not fully protect against log injection attacks. Always consider your logging
      practices as part of your overall security strategy.
    - Consider the security implications of your logging practices, such as where
      logs are stored and who can access them.
    - Remember that logging user input can reveal sensitive information, so avoid
      logging sensitive information whenever possible.
    insecure_code_example:
      description: This code is vulnerable because it directly logs user-provided
        input without sanitizing it. An attacker could inject malicious content into
        the logs via this input, potentially compromising the integrity of the logs
        or even the system of the person viewing the logs.
      text: |-
        def handle_post(%{params: %{"user_input" => input}} = conn, _opts) do
          Logger.info("User input: #{input}")
          # further code
        end
    language: elixir
    secure_code_example:
      description: The secure code example sanitizes the user input before logging
        it, helping prevent log injection attacks. The sanitize_input function would
        contain the appropriate logic for sanitizing the input, such as stripping
        control characters or escaping special characters.
      text: |-
        def handle_post(%{params: %{"user_input" => input}} = conn, _opts) do
          sanitized_input = sanitize_input(input)
          Logger.info("User input: #{sanitized_input}")
          # further code
        end

        def sanitize_input(input) do
          # Sanitization logic, e.g., escaping special characters
        end
    steps:
    - Sanitize user inputs before storing them in the log. This can be achieved by
      encoding special characters or stripping control characters.
    - Avoid using user-provided input directly in logs where possible.
    - Consider the use of structured logging, which can make injection attacks harder.
  title: Log Injection
  vulnerability_id: '091'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (version 1.10 and above) for building scalable and fault-tolerant
    applications
  - Usage of Plug for request handling
  - Usage of Phoenix framework for building web applications
  - Usage of Coherence for user management and authentication
  need: Prevent unauthorized privilege escalation
  solution:
    considerations:
    - While it's crucial to prevent users from escalating their privileges, be careful
      not to restrict legitimate actions. Make sure you understand the needs of your
      users and the tasks they need to perform.
    - Remember that the principle of least privilege extends beyond user management.
      It should also apply to system processes, network communication, file access,
      etc.
    - Always consider potential edge cases in your security measures. For example,
      how your system handles administrative users and superusers.
    insecure_code_example:
      description: This code is vulnerable because it directly updates user information,
        including their privileges, based on the provided parameters without any checks.
        An attacker could exploit this to grant themselves excessive permissions.
      text: |-
        def update_user(conn, %{"user" => user_params}) do
          user = Repo.get(User, user_params["id"])
          changeset = User.changeset(user, user_params)
          Repo.update!(changeset)
          # further code
        end
    language: elixir
    secure_code_example:
      description: The secure code example checks whether the current user is the
        same as the one being updated, and also checks that the 'role' parameter is
        not being changed. This helps to prevent privilege escalation attacks by not
        allowing users to modify their own privileges.
      text: |-
        def update_user(conn, %{"user" => user_params}) do
          user = Repo.get(User, user_params["id"])
          if conn.assigns.current_user.id == user.id and !user_params["role"] do
            changeset = User.changeset(user, user_params)
            Repo.update!(changeset)
          else
            # return error
          end
          # further code
        end
    steps:
    - Implement strict access controls, only allowing users to update their own profiles
      and not to modify their privileges.
    - Check the user role before executing any action and restrict updates to user
      roles.
    - Apply the principle of least privilege, ensuring users only have the permissions
      necessary to perform their tasks.
  title: Excessive Privileges in Applications
  vulnerability_id: '159'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug for request handling
  - Usage of Phoenix framework for building web applications
  need: Prevent unauthorized access to temporary files
  solution:
    considerations:
    - Always set appropriate file permissions to protect sensitive data, even when
      it is stored in a temporary file.
    - Remember that although the `/tmp` directory is commonly used for temporary files,
      it can be accessed by any user on the system. It's a best practice to use a
      safer alternative like `System.tmp_dir()` in Elixir.
    - When dealing with files that store sensitive data, even temporary ones, consider
      adding further security measures such as encryption.
    insecure_code_example:
      description: This code is vulnerable because it creates a temporary file in
        the default '/tmp' directory and writes sensitive data into it. Any other
        user on the same system can read the file and potentially misuse the data.
      text: |-
        File.mkdir("/tmp/my_temp_dir")
        File.write!({"/tmp/my_temp_dir", "my_temp_file"}, "sensitive data")
    language: elixir
    secure_code_example:
      description: "This secure code example creates a temporary directory in a way\
        \ that respects the operating system\u2019s conventions. It then sets the\
        \ file permissions to 0600, making the file only readable and writable by\
        \ the owner. Finally, it writes the sensitive data to the file."
      text: |-
        File.mkdir_p!({:ok, path} = File.mktemp(System.tmp_dir(), "my_temp_dir"))
        File.chmod!(path, 0o600)
        File.write!({path, "my_temp_file"}, "sensitive data")
    steps:
    - "Use a safer alternative like `Path.join(System.tmp_dir(), \"my_temp_dir\")`\
      \ to get a path to a temporary directory which respects the operating system\u2019\
      s conventions."
    - Make sure the directory is only readable and writable by the owner with a permission
      mask of 0600.
  title: Excessive Privileges in Temporary Files in Applications
  vulnerability_id: '160'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug for request handling
  - Usage of Phoenix framework for building scalable web applications
  - Usage of ftp module for FTP communication
  need: Secure transmission of customer information
  solution:
    considerations:
    - When dealing with the transmission of sensitive customer data, always use secure
      and encrypted channels like SFTP, HTTPS etc.
    - Although SFTP is secure, it's also important to manage and rotate your cryptographic
      keys regularly to further enhance security.
    - It's a best practice to not hardcode your credentials in your codebase, consider
      using secure environment variables or secure vaults to store these values.
    insecure_code_example:
      description: This code is vulnerable because it uses the FTP protocol to transmit
        customer information which does not use encryption. This means that the data
        can be easily intercepted and read in plain text during transit, which could
        potentially lead to unauthorized access or data leakage.
      text: |-
        {:ok, pid} = :ftp.open('ftp.example.com', [user: 'username', password: 'password'])
        :ftp.send_cmd(pid, 'RETR somefile.txt')
    language: elixir
    secure_code_example:
      description: This secure code example uses the SFTP protocol for file transfer
        which uses encryption to secure the data in transit. This ensures that even
        if the data is intercepted, it cannot be read in plain text.
      text: |-
        {:ok, conn} = :ssh.connect('sftp.example.com', 22, [user: 'username', password: 'password'])
        {:ok, channel} = :ssh_sftp.start_channel(conn)
        :ssh_sftp.download(channel, '/remote/path/to/somefile.txt', '/local/path/to/somefile.txt')
    steps:
    - Replace FTP (File Transfer Protocol) with SFTP (SSH File Transfer Protocol)
      for secure file transfer.
    - Use the :ssh_sftp module in Elixir for SFTP communication.
    - Make sure to include the necessary SSL certificate configurations for secure
      SFTP communication.
  title: Use of Insecure Channel - FTP in Applications
  vulnerability_id: '148'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug.Debugger for debugging Elixir applications
  need: Prevent sensitive information disclosure
  solution:
    considerations:
    - Never enable debugging in a production environment.
    - Always be cautious about what information you are displaying to end users.
    - Monitor logs for any suspicious activity.
    insecure_code_example:
      description: In this Elixir code, the application is using the Plug.Debugger
        middleware in a production environment (when Mix.env() == :prod). This means
        that in the event of a server error, detailed debugging information (like
        stack traces) will be displayed in the user's browser, which could expose
        sensitive information about the application's internals.
      text: |-
        defmodule MyApp do
          use Plug.Router

          if Mix.env() == :prod do
            use Plug.Debugger
          end

          plug :match
          plug :dispatch

          get "/" do
            send_resp(conn, 200, "Hello, world!")
          end
        end
    language: elixir
    secure_code_example:
      description: In the updated code, the application only uses the Plug.Debugger
        middleware when the Mix.env() is :dev, which means during development. In
        a production environment, no debugging information will be displayed to the
        user.
      text: |-
        defmodule MyApp do
          use Plug.Router

          if Mix.env() == :dev do
            use Plug.Debugger
          end

          plug :match
          plug :dispatch

          get "/" do
            send_resp(conn, 200, "Hello, world!")
          end
        end
    steps:
    - Ensure that the Plug.Debugger middleware is not used in a production environment.
    - Regularly review and update application configurations to ensure they are secure.
  title: Debugging Enabled in Production
  vulnerability_id: '183'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Phoenix framework for building web applications
  need: Prevent injection of malicious characters
  solution:
    considerations:
    - Never trust user input - always validate it.
    - Even if client-side validation is performed, always perform server-side validation
      as well.
    - Consider what kind of validation is appropriate for each field.
    insecure_code_example:
      description: In this Elixir code, the application takes user input directly
        from the request parameters and uses it to create a new User record. This
        is insecure because there's no validation on the user_params. An attacker
        could inject potentially malicious characters or pass in invalid data for
        certain fields.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def create(conn, %{"user" => user_params}) do
            %User{} |> User.changeset(user_params) |> Repo.insert!()
            send_resp(conn, 200, "User created")
          end
        end
    language: elixir
    secure_code_example:
      description: In this Elixir code, the application validates user input before
        using it to create a new User record. The changeset.valid? check ensures that
        the user_params data is valid before attempting to insert it into the database.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def create(conn, %{"user" => user_params}) do
            changeset = User.changeset(%User{}, user_params)

            if changeset.valid? do
              Repo.insert!(changeset)
              send_resp(conn, 200, "User created")
            else
              send_resp(conn, 400, "Invalid user data")
            end
          end
        end
    steps:
    - Always validate user input on the server-side before using it.
    - Use Ecto changesets or a similar mechanism for data validation.
  title: Lack of Data Validation
  vulnerability_id: '184'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for request handling and server management
  need: Prevent unauthorized or malicious data injection and Denial of Service (DoS)
    attacks through the x-amzn-RequestId Header
  solution:
    considerations:
    - This is a basic example. Depending on the nature of the application and expected
      header values, the validation function may need to be adjusted
    - This example uses simple character escaping for sanitization. For more complex
      scenarios, consider using a proper library or built-in functions
    insecure_code_example:
      description: This insecure code snippet represents a REST API endpoint written
        in Elixir. The code is vulnerable because it lacks input validation for the
        x-amzn-RequestId header. It directly takes the value from the header and logs
        it. An attacker can inject harmful strings or very long strings to cause injection
        attacks or service denial by exhausting system resources.
      text: |-
        defmodule InsecureApp do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/" do
            x_amzn_request_id = get_req_header(conn, "x-amzn-requestId")
            Logger.info "Received request with ID: #{x_amzn_request_id}"
            send_resp(conn, 200, "Hello, World!")
          end

          run InsecureApp
        end
    language: elixir
    secure_code_example:
      description: This secure code snippet represents a REST API endpoint written
        in Elixir with data validation for the x-amzn-RequestId header. The 'validate_header'
        function checks the length of the header value and uses 'String.replace' function
        to escape dangerous characters. This way, the possibility of injection attacks
        or service denial is significantly mitigated.
      text: |-
        defmodule SecureApp do
          use Plug.Router
          import Plug.Conn

          plug :match
          plug :dispatch

          defp validate_header(header_value) do
            if String.length(header_value) > 1000,
              do: {:error, "Header too long"}
            sanitized_value = String.replace(header_value, ~r/[<>"';()&]/, "")
            {:ok, sanitized_value}
          end

          get "/" do
            case get_req_header(conn, "x-amzn-requestId") |> validate_header do
              {:ok, valid_request_id} ->
                Logger.info "Received request with ID: #{valid_request_id}"
                send_resp(conn, 200, "Hello, World!")
              {:error, _reason} ->
                send_resp(conn, 400, "Invalid header")
            end
          end

          run SecureApp
        end
    steps:
    - Import and use 'Plug.Conn' for better handling of the request context
    - Create a new function to validate the x-amzn-RequestId header
    - In the validation function, check the length of the header and sanitize it to
      escape any dangerous characters
    - In the GET handler, call this validation function before using the header value
  title: Lack of data validation - Header x-amzn-RequestId
  vulnerability_id: '185'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of Plug and Cowboy for request handling and server management
  - Usage of Ecto for data persistence
  need: Prevent injection attacks, server resource exhaustion, and improve the overall
    security by applying server-side data validation
  solution:
    considerations:
    - This is a basic example. Depending on the nature of the application and expected
      user data, the validation function may need to be adjusted
    - This example uses simple character escaping for sanitization. For more complex
      scenarios, consider using a proper library or built-in functions
    insecure_code_example:
      description: This insecure code snippet represents a web service written in
        Elixir. The code is vulnerable because it lacks input validation for the data
        being sent to the server. It directly takes the user data from the request
        and inserts it into the database. An attacker can use special characters to
        inject harmful strings (like SQLi or XSS payloads) or large amounts of data
        to exhaust the server's resources.
      text: |-
        defmodule InsecureApp do
          use Plug.Router

          plug :match
          plug :dispatch

          post "/data" do
            user_data = conn.params["user_data"]
            Repo.insert(%Data{content: user_data})
            send_resp(conn, 200, "Data received")
          end

          run InsecureApp
        end
    language: elixir
    secure_code_example:
      description: This secure code snippet represents a web service written in Elixir
        with data validation. The 'validate_data' function checks the length of the
        user data and uses 'String.replace' function to escape dangerous characters.
        This way, the possibility of injection attacks or server resource exhaustion
        is significantly mitigated.
      text: |-
        defmodule SecureApp do
          use Plug.Router
          import Plug.Conn

          plug :match
          plug :dispatch

          defp validate_data(data) do
            if String.length(data) > 1000,
              do: {:error, "Data too long"}
            sanitized_data = String.replace(data, ~r/[<>"';()&]/, "")
            {:ok, sanitized_data}
          end

          post "/data" do
            case conn.params["user_data"] |> validate_data do
              {:ok, valid_data} ->
                Repo.insert(%Data{content: valid_data})
                send_resp(conn, 200, "Data received")
              {:error, _reason} ->
                send_resp(conn, 400, "Invalid data")
            end
          end

          run SecureApp
        end
    steps:
    - Import and use 'Plug.Conn' for better handling of the request context
    - Create a new function to validate the user data
    - In the validation function, check the length of the data and sanitize it to
      escape any dangerous characters
    - In the POST handler, call this validation function before using the user data
  title: Lack of data validation - Web Service
  vulnerability_id: '186'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications
  - Usage of custom-made text processing functionality
  need: Prevent server crashes caused by the use of dangerous regular expressions
  solution:
    considerations:
    - Always be careful when using regular expressions. Complex regular expressions
      can lead to high computational requirements, making the system vulnerable to
      ReDoS attacks
    - Test regular expressions with various string inputs to ensure they are working
      as expected
    - Consider using established libraries for common text processing tasks instead
      of custom-made solutions
    insecure_code_example:
      description: This insecure code snippet in Elixir uses a complex and potentially
        dangerous regular expression to parse a string. In certain circumstances,
        an attacker might send a specially crafted string that, when evaluated by
        this regular expression, would cause a server crash due to the high computational
        requirement, also known as a ReDoS (Regular Expression Denial of Service)
        attack.
      text: |-
        defmodule InsecureApp do
          def process(text) do
            regex = ~r/([a-z]+)*$/
            Regex.match?(regex, text)
          end
        end
    language: elixir
    secure_code_example:
      description: This secure code snippet in Elixir presents a fixed version of
        the regular expression. The regular expression has been simplified and avoids
        using quantifiers on groups, which reduces the risk of ReDoS attacks.
      text: |-
        defmodule SecureApp do
          def process(text) do
            regex = ~r/[a-z]+$/
            Regex.match?(regex, text)
          end
        end
    steps:
    - Refactor the regular expression to prevent potential ReDoS attacks
    - Avoid using quantifiers on groups or backreferences
    - Test the regular expression with different string inputs to ensure it works
      as expected
  title: Lack of data validation - Source Code
  vulnerability_id: '187'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12 and above) for building scalable and concurrent applications
  - Usage of Plug and Cowboy for HTTP request and response handling
  need: Prevent unauthorized file replacement
  solution:
    considerations:
    - This solution prevents files from being overwritten without consent, but it
      does not prevent users from attempting to overwrite files. Consider implementing
      additional protections such as user authentication or file name sanitization.
    - Also, storing user-uploaded files in the application's file system may not be
      the best option. Consider using a cloud storage service or a database for storing
      user-uploaded files.
    insecure_code_example:
      description: This controller allows a user to upload a file with any name to
        the 'uploads/' directory. If a file with the same name already exists, it
        will be overwritten without any checks or validations. This allows an attacker
        to upload arbitrary files, overwriting any existing files with the same name.
      text: |-
        defmodule FileUploadController do
          use MyApp.Web, :controller

          def create(conn, %{'file' => file_params}) do
            File.write!(Path.join("uploads/", file_params["name"]), file_params["content"])
            send_resp(conn, 200, "File uploaded successfully")
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, an additional check has been added
        to see if a file with the same name already exists before writing the file.
        If a file already exists with the same name, an error response is returned.
      text: |-
        defmodule FileUploadController do
          use MyApp.Web, :controller

          def create(conn, %{'file' => file_params}) do
            if File.exists?(Path.join("uploads/", file_params["name"])) do
              send_resp(conn, 400, "A file with the same name already exists.")
            else
              File.write!(Path.join("uploads/", file_params["name"]), file_params["content"])
              send_resp(conn, 200, "File uploaded successfully")
            end
          end
        end
    steps:
    - Add an additional check before writing the file to see if a file with the same
      name already exists.
    - If a file already exists with the same name, return an error response or ask
      for confirmation before overwriting.
  title: Lack of data validation - Content Spoofing
  vulnerability_id: '189'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12 and above) for building scalable and fault-tolerant applications
  - Usage of Plug for request handling
  - Usage of Plug.Session for HTTP session management
  need: Prevent unauthorized modification of session cookies
  solution:
    considerations:
    - This solution assumes you have a way to validate the session parameters. Depending
      on your application, this might involve checking the user_id against a list
      of valid users, verifying a signature, etc.
    - Also, consider using secure and httpOnly cookies to store the session id on
      the client side, which will protect it from being accessed by scripts or over
      unencrypted connections.
    insecure_code_example:
      description: In this code, the session value is set based on whatever value
        is received from the user, without any validation. This allows an attacker
        to set an arbitrary value for the user_id in the session, potentially impersonating
        another user.
      text: |-
        defmodule SessionController do
          use MyApp.Web, :controller

          def set_session(conn, %{'session' => session_params}) do
            conn
            |> put_session(:user_id, session_params["user_id"])
            |> send_resp(200, "Session has been set")
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the session parameters are validated
        before they are used to set the session. If the parameters are not valid,
        an error response is returned. This prevents an attacker from setting an arbitrary
        session value.
      text: |-
        defmodule SessionController do
          use MyApp.Web, :controller

          def set_session(conn, %{'session' => session_params}) do
            if valid_session_params?(session_params) do
              conn
              |> put_session(:user_id, session_params["user_id"])
              |> send_resp(200, "Session has been set")
            else
              send_resp(conn, 400, "Invalid session parameters")
            end
          end

          defp valid_session_params?(session_params) do
            # Implement validation logic here
          end
        end
    steps:
    - Validate the session parameters before using them to set the session.
    - If the session parameters are not valid, return an error response.
  title: Lack of data validation - Session Cookie
  vulnerability_id: '190'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12 and above) for building scalable and fault-tolerant applications
  - Usage of Plug for request handling
  need: Maintain data integrity by server-side validation of input data
  solution:
    considerations:
    - This solution assumes you have a way to validate the user data. Depending on
      your application, this might involve checking the data against a schema, using
      a validation library, etc.
    - Also, consider using HTTP status codes to indicate the result of the operation.
      For example, return a 400 Bad Request status code if the validation fails.
    insecure_code_example:
      description: This code fetches a user record and sends it in the response, then
        takes user data from a subsequent request and updates the user record without
        any validation. If the received data is invalid, it could lead to data integrity
        issues.
      text: |-
        defmodule UserController do
          use MyApp.Web, :controller

          def show(conn, params) do
            user = Repo.get(User, params["id"])
            render(conn, "show.json", user: user)
          end

          def update(conn, params) do
            user = Repo.get(User, params["id"])
            user_changes = Map.from_struct(params["user"])
            changeset = User.changeset(user, user_changes)
            case Repo.update(changeset) do
              {:ok, user} ->
                render(conn, "show.json", user: user)
              {:error, changeset} ->
                conn
                |> put_status(:unprocessable_entity)
                |> render(MyApp.ChangesetView, "error.json", changeset: changeset)
            end
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the incoming user data is validated
        before it is used to update the user record. If the data is not valid, an
        error response is returned. This prevents an attacker from submitting invalid
        data.
      text: |-
        defmodule UserController do
          use MyApp.Web, :controller

          def show(conn, params) do
            user = Repo.get(User, params["id"])
            render(conn, "show.json", user: user)
          end

          def update(conn, params) do
            user = Repo.get(User, params["id"])
            user_changes = Map.from_struct(params["user"])
            if valid_user_data?(user_changes) do
              changeset = User.changeset(user, user_changes)
              case Repo.update(changeset) do
                {:ok, user} ->
                  render(conn, "show.json", user: user)
                {:error, changeset} ->
                  conn
                  |> put_status(:unprocessable_entity)
                  |> render(MyApp.ChangesetView, "error.json", changeset: changeset)
              end
            else
              send_resp(conn, 400, "Invalid user data")
            end
          end

          defp valid_user_data?(data) do
            # Implement validation logic here
          end
        end
    steps:
    - Validate the incoming data before updating the record.
    - If the data is not valid, return an error response.
  title: Lack of data validation - Responses
  vulnerability_id: '191'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Phoenix framework for request handling
  need: Prevent XSS vulnerabilities due to unvalidated user input in server error
    responses
  solution:
    considerations:
    - While the 'html_escape/1' function can prevent most XSS attacks, it may not
      cover all potential security risks. Always stay updated with the latest security
      practices and keep your libraries updated.
    - Consider using Content Security Policy (CSP) headers to add an additional layer
      of security against XSS.
    insecure_code_example:
      description: This code is vulnerable because it directly includes the 'msg'
        parameter from the user input in the server error response without any validation
        or sanitization. This can lead to a Cross-Site Scripting (XSS) attack if a
        user includes malicious script in the 'msg' parameter.
      text: |-
        defmodule MyApp.ErrorHandlerController do
          use MyAppWeb, :controller

          def error(conn, %{'msg' => msg}) do
            send_resp(conn, 500, msg)
          end
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it uses the 'html_escape/1' function
        from the 'Phoenix.HTML' module to sanitize the 'msg' parameter. This function
        escapes potentially unsafe characters, thereby preventing any scripts included
        in the 'msg' parameter from being executed.
      text: |-
        defmodule MyApp.ErrorHandlerController do
          use MyAppWeb, :controller

          def error(conn, %{'msg' => msg}) do
            sanitized_msg = Phoenix.HTML.html_escape(msg)
            send_resp(conn, 500, sanitized_msg)
          end
        end
    steps:
    - Install the 'phoenix_html' library if it's not already included in your project.
      This library provides functions to escape potentially unsafe characters.
    - In the error function, use the 'Phoenix.HTML.html_escape/1' function to sanitize
      the 'msg' parameter before including it in the server response.
  title: Lack of Data Validation - Reflected Parameters
  vulnerability_id: '192'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug.Conn for request handling
  need: Prevent unintended redirects due to manipulation of the host header
  solution:
    considerations:
    - While the above solution can prevent most Host Header Injection attacks, it
      may not cover all potential security risks. Always stay updated with the latest
      security practices and keep your libraries updated.
    - Consider using additional measures such as using absolute URLs for redirection
      or using the 'Host' header only for generating content within the application
      but not for redirection.
    insecure_code_example:
      description: This code is vulnerable because it directly uses the 'host' header
        from the user request to construct the redirection URL without any validation.
        This can lead to Host Header Injection attacks if a user provides a malicious
        website as the 'host' header.
      text: |-
        defmodule MyApp.HeaderController do
          use MyAppWeb, :controller

          def redirect(conn, _params) do
            redirect_to = Map.get(conn.req_headers, "host")
            redirect(conn, external: redirect_to)
          end
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it validates the 'host' header against
        a whitelist of trusted domains before using it to construct the redirection
        URL. If the 'host' header is not in the trusted domains, it simply returns
        the connection without redirecting.
      text: |-
        defmodule MyApp.HeaderController do
          use MyAppWeb, :controller

          def redirect(conn, _params) do
            redirect_to = Map.get(conn.req_headers, "host")
            trusted_domains = Application.get_env(:my_app, :trusted_domains)
            if redirect_to in trusted_domains do
              redirect(conn, external: redirect_to)
            else
              conn
            end
          end
        end
    steps:
    - Define a whitelist of trusted domains in your application configuration.
    - In the redirect function, validate the 'host' header against the whitelist before
      using it to construct the redirection URL.
  title: Lack of Data Validation - Host Header Injection
  vulnerability_id: '193'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for request handling
  need: Prevent overlong content in user input, which can lead to resource exhaustion
    or other vulnerabilities
  solution:
    considerations:
    - The actual maximum length you should allow depends on the specific use case
      and resources available. The value '1000' used here is just an example.
    - Other parts of your application may also accept user input, and they should
      perform similar length validation.
    insecure_code_example:
      description: This code is vulnerable because it doesn't validate the length
        of the 'body' parameter. An attacker can provide a very long input, potentially
        causing resource exhaustion or other vulnerabilities.
      text: |-
        defmodule MyAppWeb.MyController do
          use MyAppWeb, :controller

          def create(conn, %{"body" => body}) do
            # No input length validation
            MyApp.create_item(body)
            send_resp(conn, 200, "Item created")
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it checks the length of the 'body' parameter
        before using it. If the length exceeds 1000, it returns an error response
        instead of passing the overlong input to 'MyApp.create_item'.
      text: |-
        defmodule MyAppWeb.MyController do
          use MyAppWeb, :controller

          def create(conn, %{"body" => body}) do
            if String.length(body) > 1000 do
              send_resp(conn, 400, "Body is too long")
            else
              MyApp.create_item(body)
              send_resp(conn, 200, "Item created")
            end
          end
        end
    steps:
    - Use the 'String.length' function to validate the length of the user input.
    - Before passing the 'body' parameter to 'MyApp.create_item', check whether the
      length of 'body' exceeds the acceptable limit. If it does, return an error response.
  title: Lack of Data Validation - Input Length
  vulnerability_id: '194'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for request handling
  need: Prevent potential attacks via HTTP headers by validating the data received
  solution:
    considerations:
    - The actual validation logic depends on your specific use case. The 'validate_token'
      function should implement appropriate checks.
    - Other headers received from the client should also be validated.
    insecure_code_example:
      description: This code is vulnerable because it doesn't validate the 'user-token'
        header. An attacker can inject potentially harmful content into this header
        to exploit potential vulnerabilities or achieve an XSS attack.
      text: |-
        defmodule MyAppWeb.MyController do
          use MyAppWeb, :controller

          def show(conn, _params) do
            # No header validation
            user_token = get_req_header(conn, "user-token")
            item = MyApp.get_item(user_token)
            json(conn, item)
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it validates the 'user-token' header
        before using it. If the header contains invalid data, it returns an error
        response instead of passing the harmful content to 'MyApp.get_item'.
      text: |-
        defmodule MyAppWeb.MyController do
          use MyAppWeb, :controller

          def show(conn, _params) do
            user_token = get_req_header(conn, "user-token")
            if validate_token(user_token) do
              item = MyApp.get_item(user_token)
              json(conn, item)
            else
              send_resp(conn, 400, "Invalid user-token header")
            end
          end

          defp validate_token(token) do
            # Implement your validation logic here
          end
        end
    steps:
    - Add a function to validate the 'user-token' header against a set of allowed
      patterns or values.
    - Before passing the 'user-token' header to 'MyApp.get_item', call this validation
      function. If the validation fails, return an error response.
  title: Lack of Data Validation - Headers
  vulnerability_id: '195'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for request handling
  need: Prevent unauthorized changes to product data by validating permissions and
    data before processing requests
  solution:
    considerations:
    - The actual permission check and date validation logic depend on your specific
      use case.
    - You should validate other sensitive fields in a similar manner.
    insecure_code_example:
      description: This code is vulnerable because it doesn't validate the permissions
        or the dates in 'params' before updating the product. An attacker can ignore
        frontend restrictions and send a request that the server processes as valid,
        potentially causing data integrity and availability issues.
      text: |-
        defmodule MyAppWeb.ProductController do
          use MyAppWeb, :controller

          def update(conn, params) do
            # No permissions or date validation
            MyApp.update_product(params)
            send_resp(conn, 200, "Product updated")
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it checks permissions and validates dates
        before updating the product. If the request fails these checks, it returns
        an error response instead of processing an invalid or unauthorized request.
      text: |-
        defmodule MyAppWeb.ProductController do
          use MyAppWeb, :controller

          def update(conn, params) do
            if MyApp.check_permissions(conn) && validate_dates(params) do
              MyApp.update_product(params)
              send_resp(conn, 200, "Product updated")
            else
              send_resp(conn, 403, "Invalid request")
            end
          end

          defp validate_dates(params) do
            # Implement your date validation logic here
          end
        end
    steps:
    - Add a function to check if the current user has permission to modify the product.
    - Add another function to validate the dates in 'params' before updating the product.
    - Before calling 'MyApp.update_product', call these two functions. If either check
      fails, return an error response.
  title: Lack of Data Validation - Dates
  vulnerability_id: '196'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for request handling
  need: Prevent transactions with invalid values to ensure business logic integrity
  solution:
    considerations:
    - The actual transaction value validation logic depends on your specific use case.
    - You should validate other sensitive fields in a similar manner.
    insecure_code_example:
      description: This code is vulnerable because it doesn't validate the transaction
        value in 'params' before creating the transaction. An attacker can send a
        request with a lower transaction value, negatively impacting the business.
      text: |-
        defmodule MyAppWeb.TransactionController do
          use MyAppWeb, :controller

          def create(conn, params) do
            # No transaction value validation
            MyApp.create_transaction(params)
            send_resp(conn, 200, "Transaction created")
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it validates the transaction value before
        creating the transaction. If the request contains an invalid transaction value,
        it returns an error response instead of creating a transaction with an incorrect
        value.
      text: |-
        defmodule MyAppWeb.TransactionController do
          use MyAppWeb, :controller

          def create(conn, params) do
            if validate_transaction_value(params) do
              MyApp.create_transaction(params)
              send_resp(conn, 200, "Transaction created")
            else
              send_resp(conn, 403, "Invalid transaction value")
            end
          end

          defp validate_transaction_value(params) do
            # Implement your transaction value validation logic here
          end
        end
    steps:
    - Add a function to validate the transaction value in 'params' before creating
      the transaction.
    - Before calling 'MyApp.create_transaction', call this validation function. If
      the validation fails, return an error response.
  title: Lack of Data Validation - Numbers
  vulnerability_id: '197'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Plug for request routing
  need: Prevent unauthorized access to restricted functionalities
  solution:
    considerations:
    - The actual domain validation logic depends on your specific use case.
    - You should validate other sensitive routes in a similar manner.
    insecure_code_example:
      description: This code is vulnerable because it doesn't validate if the user
        is authorized to access the employee management panel based on their domain.
        An attacker can bypass the restrictions by using absolute paths to the employee
        management panel.
      text: |-
        defmodule MyAppWeb.EmployeeController do
          use MyAppWeb, :controller

          def show(conn, params) do
            # No domain restriction validation
            employee = MyApp.get_employee(params["id"])
            render(conn, "show.html", employee: employee)
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it validates if the user is authorized
        to access the employee management panel based on their domain. If the user
        is not authorized, it returns an 'Access Denied' response.
      text: |-
        defmodule MyAppWeb.EmployeeController do
          use MyAppWeb, :controller

          def show(conn, params) do
            if authorized_domain?(conn) do
              employee = MyApp.get_employee(params["id"])
              render(conn, "show.html", employee: employee)
            else
              send_resp(conn, 403, "Access Denied")
            end
          end

          defp authorized_domain?(conn) do
            # Implement your domain validation logic here
          end
        end
    steps:
    - Add a function to validate if the user is authorized to access the employee
      management panel based on their domain.
    - Before calling 'MyApp.get_employee', call this validation function. If the validation
      fails, return an error response.
  title: Lack of Data Validation - Out of Range
  vulnerability_id: '198'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Ecto for data validation and changesets
  need: Prevent usage of disposable email addresses for user registration
  solution:
    considerations:
    - The actual implementation of the 'disposable_email?' function depends on your
      specific use case.
    - Consider using a service or library that maintains a list of disposable email
      services to improve the accuracy of your check.
    insecure_code_example:
      description: The code is vulnerable because it doesn't validate whether the
        provided email address belongs to a disposable email service. An attacker
        can register and potentially reset the password for users with disposable
        email addresses, thereby impersonating legitimate users.
      text: |-
        defmodule MyApp.Accounts.UserChangeset do
          use Ecto.Schema
          import Ecto.Changeset

          def changeset(user, attrs) do
            user
            |> cast(attrs, [:email])
            |> validate_required([:email])
            |> unique_constraint(:email)
          end
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it adds an additional validation step
        to check whether the provided email address belongs to a disposable email
        service. If it does, an error is added to the changeset, and the registration
        request is rejected.
      text: |-
        defmodule MyApp.Accounts.UserChangeset do
          use Ecto.Schema
          import Ecto.Changeset

          def changeset(user, attrs) do
            user
            |> cast(attrs, [:email])
            |> validate_required([:email])
            |> validate_email()
            |> unique_constraint(:email)
          end

          defp validate_email(changeset) do
            if changeset.valid? && disposable_email?(changeset.changes.email) do
              add_error(changeset, :email, "Disposable email addresses not allowed")
            else
              changeset
            end
          end

          defp disposable_email?(email) do
            # Implement your disposable email check here
          end
        end
    steps:
    - Create a function to validate whether an email address belongs to a disposable
      email service.
    - Use this function in the changeset to add an additional validation step.
  title: Lack of Data Validation - Emails
  vulnerability_id: '199'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Logger library for logging
  need: Traceability and monitoring of system events
  solution:
    considerations:
    - The Logger module is a built-in Elixir library. Make sure to require it before
      using it in your module.
    - It's crucial to not log sensitive information such as user passwords. Ensure
      that your logs don't contain such data.
    insecure_code_example:
      description: The code is vulnerable because it doesn't log any information about
        the outcome of the critical action. If a critical action fails or an error
        occurs, there is no record of this event, making it difficult to identify
        and analyze the issue.
      text: |-
        defmodule MyApp.Service do
          def critical_action(param1, param2) do
            case MyApp.Repo.transaction(fun -> do_critical_action(param1, param2) end) do
              {:ok, _result} -> :ok
              {:error, _reason} -> :error
            end
          end

          defp do_critical_action(param1, param2) do
            # Implementation of critical action
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it uses the Logger module to log the
        beginning and outcome of a critical action. If a critical action fails or
        an error occurs, there is a record of this event, making it easier to identify
        and analyze the issue.
      text: |-
        defmodule MyApp.Service do
          require Logger

          def critical_action(param1, param2) do
            Logger.info("Starting critical action with #{param1}, #{param2}")

            case MyApp.Repo.transaction(fun -> do_critical_action(param1, param2) end) do
              {:ok, result} ->
                Logger.info("Critical action succeeded with result: #{result}")
                :ok
              {:error, reason} ->
                Logger.error("Critical action failed with reason: #{reason}")
                :error
            end
          end

          defp do_critical_action(param1, param2) do
            # Implementation of critical action
          end
        end
    steps:
    - Use the Logger module to log information about system events.
    - Add logging statements at critical points in your code, such as before and after
      a critical action, and when an error occurs.
  title: Traceability Loss
  vulnerability_id: '200'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications
  - Usage of Regex module for regular expressions
  need: Prevent server crashes by avoiding expensive regular expression operations
  solution:
    considerations:
    - The Regex module is a built-in Elixir library used for regular expressions.
    - Be cautious while designing regular expressions. Avoid using greedy quantifiers
      and unnecessary capturing groups that could lead to extensive backtracking and
      excessive CPU usage.
    insecure_code_example:
      description: This code is vulnerable because it uses a regular expression that
        can be exploited in a ReDoS attack. An attacker can provide an email string
        that causes excessive backtracking, leading to an excessive consumption of
        CPU resources and potentially causing the server to crash.
      text: |-
        defmodule MyApp.Service do
          def check_email_format(email) do
            Regex.match?(~r/([a-z0-9]+)*@([a-z0-9]+)*(.com)*/, email)
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it uses a non-capturing regular expression
        to validate the email format, thus avoiding the risk of excessive backtracking
        and ReDoS attacks.
      text: |-
        defmodule MyApp.Service do
          def check_email_format(email) do
            Regex.match?(~r/[a-z0-9]+@[a-z0-9]+\.com/, email)
          end
        end
    steps:
    - Avoid using quantifiers in your regular expressions that could lead to excessive
      backtracking.
    - Use a simpler, non-capturing regular expression to validate the email format.
  title: Asymmetric Denial of Service - ReDoS
  vulnerability_id: '211'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Guardian for authentication and authorization
  need: Prevent leakage of sensitive business information through JWTs
  solution:
    considerations:
    - Always consider what information is being included in JWTs.
    - Avoid including sensitive information in JWTs.
    insecure_code_example:
      description: The code generates JWTs with sensitive user information like the
        username and password. An attacker obtaining the JWT can decode it to access
        this sensitive information.
      text: |-
        defmodule MyApp.Guardian do
          use Guardian, otp_app: :my_app

          def subject_for_token(user, _claims) do
            {:ok, "User:#{user.id}"}
          end

          def resource_from_claims(claims) do
            {:ok, %{username: claims["sub"], password: claims["password"]}}
          end
        end
    language: elixir
    secure_code_example:
      description: The code generates JWTs with just the user ID, and not other sensitive
        information like the username and password. Thus, even if an attacker obtains
        the JWT, they can't access sensitive business information.
      text: |-
        defmodule MyApp.Guardian do
          use Guardian, otp_app: :my_app

          def subject_for_token(user, _claims) do
            {:ok, "User:#{user.id}"}
          end

          def resource_from_claims(claims) do
            {:ok, %{user_id: claims["sub"]}}
          end
        end
    steps:
    - Remove sensitive information from the JWT.
    - Handle sensitive information on the server side and not include it in JWTs.
  title: Business Information Leak - JWT
  vulnerability_id: '213'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.11.0 and above) for building composable web applications in Elixir
  need: Prevent leakage of sensitive credentials
  solution:
    considerations:
    - Always store sensitive credentials securely.
    - Avoid hard-coding sensitive information in the source code.
    - Encrypt sensitive credentials at rest and in transit.
    insecure_code_example:
      description: The code hard-codes a sensitive API key, which exposes the key
        if the code is leaked. An attacker obtaining this key can misuse it to impersonate
        the application.
      text: |-
        defmodule MyApp.Config do
          @api_key "hard-coded-api-key"

          def get_api_key do
            @api_key
          end
        end
    language: elixir
    secure_code_example:
      description: The code retrieves the API key from an environment variable instead
        of hard-coding it. Even if the code is leaked, the sensitive API key remains
        secure.
      text: |-
        defmodule MyApp.Config do
          def get_api_key do
            System.get_env("API_KEY")
          end
        end
    steps:
    - Remove hard-coded sensitive credentials from the code.
    - Store sensitive credentials securely, such as in environment variables, or in
      encrypted configuration files.
  title: Business Information Leak - Credentials
  vulnerability_id: '214'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications (version 1.5.0 and above)
  need: Prevent credit card information from being exposed in responses
  solution:
    considerations:
    - Never include sensitive information in a response unless absolutely necessary
      and it is done securely.
    - Regularly review and update security measures to protect sensitive data.
    insecure_code_example:
      description: This code is returning the user's credit card information in the
        response to the 'show' request. If an attacker can access the responses to
        these requests, they can obtain sensitive credit card information.
      text: |-
        defmodule MyApp.UserController do
          use MyApp, :controller

          def show(conn, %{"id" => id}) do
            user = Repo.get!(User, id)
            render(conn, "show.json", user: user)
          end
        end

        defmodule MyApp.UserView do
          use MyApp, :view

          def render("show.json", %{user: user}) do
            %{id: user.id, name: user.name, credit_card: user.credit_card}
          end
        end
    language: elixir
    secure_code_example:
      description: The secure code does not include the user's credit card information
        in the response, thus protecting sensitive data.
      text: |-
        defmodule MyApp.UserController do
          use MyApp, :controller

          def show(conn, %{"id" => id}) do
            user = Repo.get!(User, id)
            render(conn, "show.json", user: user)
          end
        end

        defmodule MyApp.UserView do
          use MyApp, :view

          def render("show.json", %{user: user}) do
            %{id: user.id, name: user.name}
          end
        end
    steps:
    - Do not include sensitive information like credit card data in the response.
    - Always sanitize data before sending it in a response.
  title: Business Information Leak - Credit Cards
  vulnerability_id: '217'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.12.1 and above) for building composable web applications in Elixir
  - Usage of Guardian for authentication and authorization
  need: Prevent user information from being exposed in session tokens
  solution:
    considerations:
    - Never include sensitive information in a session token unless absolutely necessary
      and it is done securely.
    - Regularly review and update security measures to protect sensitive data.
    insecure_code_example:
      description: This code is including the user's email and name in the session
        token. If an attacker can decode this token, they can obtain the user's email
        and name.
      text: |-
        defmodule MyApp.GuardianSerializer do
          @behaviour Guardian.Serializer

          def for_token(user = %User{}), do: { :ok, "User:#{user.id}:#{user.email}:#{user.name}" }
          def from_token("User:" <> id <> ":" <> email <> ":" <> name), do: { :ok, %User{id: id, email: email, name: name} }
        end
    language: elixir
    secure_code_example:
      description: The secure code does not include the user's email and name in the
        session token, thus protecting sensitive data.
      text: |-
        defmodule MyApp.GuardianSerializer do
          @behaviour Guardian.Serializer

          def for_token(user = %User{}), do: { :ok, "User:#{user.id}" }
          def from_token("User:" <> id), do: { :ok, %User{id: id} }
        end
    steps:
    - Do not include sensitive information like email and name in the session token.
    - Always sanitize data before including it in a token.
  title: Business Information Leak - Token
  vulnerability_id: '220'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.12.1 and above) for building composable web applications in Elixir
  - Usage of Ecto for database query and manipulation (version 3.6.2 and above)
  need: Prevent exposure of valid users' list
  solution:
    considerations:
    - Always ensure sensitive information, like the list of valid users, is protected
      and only accessible to authorized users.
    - Regularly review and update access controls to safeguard user data.
    insecure_code_example:
      description: This insecure code is exposing the list of all users without any
        checks or restrictions. This could allow attackers to obtain information about
        valid users in the system.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def index(conn, _params) do
            users = Repo.all(User)
            render(conn, "index.json", users: users)
          end
        end
    language: elixir
    secure_code_example:
      description: The secure code only provides the list of users if the user is
        authorized. It ensures that only the right users can see the user list.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def index(conn, _params) do
            if authorized?(conn) do
              users = Repo.all(User)
              render(conn, "index.json", users: users)
            else
              send_resp(conn, :unauthorized, "")
            end
          end

          defp authorized?(conn) do
            # Add authorization checks here
          end
        end
    steps:
    - Restrict access to user lists and only expose it when necessary and to authorized
      users.
    - Include server-side checks to ensure only authorized users can access the data.
  title: Business Information Leak - Users
  vulnerability_id: '221'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Ecto (3.6.2 and above) for database query and manipulation
  - Usage of Postgrex for connecting to PostgreSQL databases (version 0.15.9 and above)
  need: Prevent exposure of sensitive business information from the database
  solution:
    considerations:
    - Always ensure sensitive business information is protected and only accessible
      to authorized users.
    - Regularly review and update access controls to safeguard user and business data.
    insecure_code_example:
      description: This insecure code is exposing all details of a user, including
        sensitive information such as transactions, wallet IDs, operating system names,
        transaction codes, endpoints, credit cards, and available balance. An attacker
        who can access this endpoint could retrieve all this sensitive business information.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def show(conn, %{"id" => id}) do
            user = Repo.get(User, id)
            render(conn, "show.json", user: user)
          end
        end
    language: elixir
    secure_code_example:
      description: The secure code only provides necessary user details and only if
        the user is authorized. It ensures that only the right users can see the user
        details and sensitive business information is protected.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def show(conn, %{"id" => id}) do
            if authorized?(conn) do
              user = Repo.get(User, id) |> Repo.preload([:minimal_required_fields])
              render(conn, "show.json", user: user)
            else
              send_resp(conn, :unauthorized, "")
            end
          end

          defp authorized?(conn) do
            # Add authorization checks here
          end
        end
    steps:
    - Restrict the fields that are returned by the API. Only provide necessary information.
    - Always use server-side checks to ensure that only authorized users can access
      the data.
  title: Business Information Leak - DB
  vulnerability_id: '222'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.12.0 and above) for building composable web application modules
  need: Avoid exposure of real user's personal information stored in the source code
  solution:
    considerations:
    - Avoid using real personal information during development. Consider using mock
      data or anonymized data for development and testing purposes.
    - Ensure your environment variables or configuration files are adequately secured
      and not accessible to unauthorized users.
    insecure_code_example:
      description: The insecure code directly uses real personal information (like
        ID numbers and phone numbers) within the source code. This could lead to a
        serious data breach, where personal information is leaked, and could be used
        for malicious purposes such as social engineering attacks.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def show(conn, %{"id" => id}) do
            user = %{id: "real_id", phone: "real_phone_number"}
            render(conn, "show.json", user: user)
          end
        end
    language: elixir
    secure_code_example:
      description: The secure code uses environment variables instead of hard-coding
        the personal information. It ensures that personal information is not directly
        exposed in the source code, thereby preventing potential data breaches.
      text: |-
        defmodule MyApp.UserController do
          use MyApp.Web, :controller

          def show(conn, %{"id" => id}) do
            user = %{id: System.get_env("USER_ID"), phone: System.get_env("PHONE_NUMBER")}
            render(conn, "show.json", user: user)
          end
        end
    steps:
    - Never hard-code real personal information within your source code.
    - Use environment variables or secure configuration files to store sensitive data
      if necessary.
  title: Business Information Leak - Personal Information
  vulnerability_id: '226'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.12.0 and above) for building composable web applications in Elixir
  need: Prevent unauthorized access to business analytics through exposed API key
  solution:
    considerations:
    - Never expose API keys or sensitive information in your code or URLs.
    - Regularly update and review access controls to ensure only authorized users
      can access sensitive information.
    - Always encrypt sensitive information during transmission and at rest.
    insecure_code_example:
      description: This insecure code exposes an API key in a Swagger URL that could
        be used to access business analytics. This can lead to a serious information
        breach, where unauthorized users could gain access to valuable business insights.
      text: |-
        defmodule MyApp.AnalyticsController do
          use MyApp.Web, :controller

          def show(conn, %{"apiKey" => apiKey}) do
            if apiKey == "exposed_api_key" do
              analytics = MyApp.Analytics.get()
              render(conn, "show.json", analytics: analytics)
            end
          end
        end
    language: elixir
    secure_code_example:
      description: The secure code compares the provided API key with a securely stored
        key, and only provides analytics if the user is authorized. This ensures that
        the API key and business analytics are not exposed to unauthorized users.
      text: |-
        defmodule MyApp.AnalyticsController do
          use MyApp.Web, :controller

          def show(conn, %{"apiKey" => apiKey}) do
            if apiKey == System.get_env("API_KEY") and authorized?(conn) do
              analytics = MyApp.Analytics.get()
              render(conn, "show.json", analytics: analytics)
            else
              send_resp(conn, :unauthorized, "")
            end
          end

          defp authorized?(conn) do
            # Add authorization checks here
          end
        end
    steps:
    - API keys should never be exposed in the code or URLs.
    - Use secure methods to store and access API keys, such as environment variables
      or secure configuration files.
    - Implement access controls to ensure that only authorized personnel can access
      the analytics.
  title: Business Information Leak - Analytics
  vulnerability_id: '228'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.12.0 and above) for building composable web application modules
  - Usage of Bamboo (1.7.0 and above) for Email handling
  need: Prevent mass messages from being sent to a single user, causing resource saturation.
  solution:
    considerations:
    - Rate limiting should be carefully configured to allow for legitimate use while
      preventing abuse.
    - False positives and negatives are possible in any rate limiting system, and
      the system should be monitored and adjusted as necessary.
    - Rate limiting can be circumvented by determined attackers, so additional layers
      of protection, such as user verification, should also be implemented.
    insecure_code_example:
      description: This code is insecure because it allows for repeated and rapid
        message sending to the same recipient without any form of rate limiting or
        restriction. This can lead to message flooding, causing the recipient's resources
        to be unnecessarily consumed and possibly causing important information to
        be lost in the flood.
      text: |-
        defmodule MyApp.MessageController do
          use MyApp.Web, :controller

          def send_message(conn, %{"recipient" => recipient, "message" => message}) do
            MyApp.Messaging.send_email(recipient, message)
            MyApp.Messaging.send_sms(recipient, message)
            send_resp(conn, :ok, "Message sent")
          end
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it implements a rate limiting mechanism
        that restricts the number of messages that can be sent to a single recipient
        in a given time frame. It checks if a message can be sent before actually
        sending the message and records the sent message for future checks. This prevents
        message flooding and conserves the recipient's resources.
      text: |-
        defmodule MyApp.MessageController do
          use MyApp.Web, :controller

          def send_message(conn, %{"recipient" => recipient, "message" => message}) do
            if MyApp.Messaging.can_send_message?(recipient) do
              MyApp.Messaging.send_email(recipient, message)
              MyApp.Messaging.send_sms(recipient, message)
              MyApp.Messaging.record_message_sent(recipient)
              send_resp(conn, :ok, "Message sent")
            else
              send_resp(conn, :too_many_requests, "Too many messages have been sent. Please wait before sending again.")
            end
          end
        end
    steps:
    - Implement a rate limiting mechanism to restrict the number of messages that
      can be sent to a single recipient in a given time frame.
    - Monitor message sending patterns to detect and block any attempts at message
      flooding.
    - Require users to confirm their email or phone number before allowing messages
      to be sent to them.
  title: Message Flooding
  vulnerability_id: '231'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.12.0 and above) for building composable web applications in Elixir
  need: Prevent exposing server details through HTTP response headers.
  solution:
    considerations:
    - While it's a good practice to avoid exposing technical details, remember that
      security through obscurity is not sufficient on its own.
    - In addition to obscuring technical details, make sure to keep your servers and
      applications up to date to protect against known vulnerabilities.
    - Using a security-oriented middleware or plug that removes or obfuscates these
      headers can make this process easier and more reliable.
    insecure_code_example:
      description: This code is insecure because it sets the 'Server' response header
        with information about the application and the server technology, potentially
        exposing the system to targeted attacks.
      text: |-
        defmodule MyApp.Plug.RemoveSensitiveHeaders do
          import Plug.Conn

          def init(opts), do: opts

          def call(conn, _opts) do
            conn
            |> put_resp_header("Server", "MyApp/1.0.0 (Elixir Plug/1.12.0)")
          end
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it doesn't reveal specific details
        about the application or the technology stack in the 'Server' header. Instead,
        it sets a generic value, reducing the risk of targeted attacks.
      text: |-
        defmodule MyApp.Plug.RemoveSensitiveHeaders do
          import Plug.Conn

          def init(opts), do: opts

          def call(conn, _opts) do
            conn
            |> put_resp_header("Server", "Secure Server")
          end
        end
    steps:
    - Avoid setting headers that reveal sensitive details about the server or the
      technology stack.
    - Review your application's response headers to ensure that no sensitive information
      is being exposed.
    - Use a security-oriented middleware or plug that removes or obfuscates these
      headers.
  title: Technical Information Leak - Headers
  vulnerability_id: '235'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Absinthe for building GraphQL APIs in Elixir
  need: Prevent exposing GraphQL API Schema Structure to unauthorized users.
  solution:
    considerations:
    - Always review and follow best practices for securing your GraphQL endpoint.
    - Consider using additional security mechanisms, such as authentication and authorization,
      to further protect your GraphQL API.
    - Regularly review your GraphQL schema and remove any unnecessary fields or types
      that might expose sensitive information.
    insecure_code_example:
      description: This code is insecure because it enables introspection queries,
        allowing anyone to retrieve the entire GraphQL API Schema Structure. This
        can lead to information leakage, helping an attacker to craft more targeted
        attacks.
      text: |-
        defmodule MyAppWeb.Schema do
          use Absinthe.Schema

          query do
            # Queries defined here
          end

          mutation do
            # Mutations defined here
          end
        end

        # Endpoint configuration
        defmodule MyAppWeb.Endpoint do
          use Phoenix.Endpoint, otp_app: :my_app

          socket "/graphiql", Absinthe.Plug.GraphiQL, schema: MyAppWeb.Schema
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it disables introspection queries in
        the production environment. The introspection queries are only available in
        non-production environments, reducing the risk of information leakage.
      text: |-
        defmodule MyAppWeb.Schema do
          use Absinthe.Schema

          query do
            # Queries defined here
          end

          mutation do
            # Mutations defined here
          end
        end

        # Endpoint configuration
        defmodule MyAppWeb.Endpoint do
          use Phoenix.Endpoint, otp_app: :my_app

          socket "/graphiql", Absinthe.Plug.GraphiQL, schema: MyAppWeb.Schema, interface: Mix.env() != :prod
        end
    steps:
    - Disable introspection queries in the production environment.
    - Configure Absinthe to conditionally enable introspection queries based on the
      environment or other criteria.
    - Review your GraphQL server's configuration to ensure that no sensitive schema
      information is exposed.
  title: Technical Information Leak - API
  vulnerability_id: '238'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications (version 1.6.0 and above)
  need: Prevent exposing technical information through server error messages.
  solution:
    considerations:
    - While obscuring error details is beneficial, also consider other security practices
      such as rate limiting to protect against brute force and DDoS attacks.
    - Always log the detailed error information server-side for debugging and auditing
      purposes.
    - Regularly review your error handling code to ensure it doesn't expose sensitive
      data.
    insecure_code_example:
      description: This code is insecure because it might reveal too much information
        in the error details when a server error (HTTP 500) occurs. Detailed error
        messages can potentially expose sensitive technical details about your system.
      text: |-
        defmodule MyAppWeb.ErrorView do
          use MyAppWeb, :view

          def render("500.json", _assigns) do
            %{errors: %{detail: 'Internal server error'}}
          end
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it uses a generic error message to
        indicate a server error, without revealing any technical details. The detailed
        error information is not exposed to the client, reducing the risk of information
        leaks.
      text: |-
        defmodule MyAppWeb.ErrorView do
          use MyAppWeb, :view

          def render("500.json", _assigns) do
            %{errors: %{detail: 'An error occurred. We are working to fix it.'}}
          end
        end
    steps:
    - Use generic error messages when responding to client requests, regardless of
      the type of error on the server.
    - Handle exceptions at the application level and log the detailed error information
      server-side for debugging.
    - Use a custom error handling plug to control what gets exposed in case of server
      errors.
  title: Technical Information Leak - Errors
  vulnerability_id: '239'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications (version 1.6.0 and above)
  need: Ensure that OTPs are validated properly during user registration.
  solution:
    considerations:
    - Always consider using libraries to handle OTP generation and verification.
    - OTP should be temporary and expire after a certain time or after it is used.
    - OTP should not be stored in plain text but should be hashed or encrypted.
    insecure_code_example:
      description: This code is insecure because it only checks if the length of the
        OTP is 6, but it doesn't verify if the OTP matches the one generated by the
        server. This allows an attacker to bypass the OTP verification by entering
        any six-digit number.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def verify_otp(conn, %{'otp' => otp}) do
            if String.length(otp) == 6 do
              json(conn, %{status: 'success'})
            else
              json(conn, %{status: 'error'})
            end
          end
        end
    language: elixir
    secure_code_example:
      description: This code is secure because it verifies the user's OTP against
        the one stored on the server, ensuring that only a correct OTP will pass the
        verification process.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def verify_otp(conn, %{'otp' => otp, 'user_id' => user_id}) do
            stored_otp = get_stored_otp_for_user(user_id)
            if otp == stored_otp do
              json(conn, %{status: 'success'})
            else
              json(conn, %{status: 'error'})
            end
          end
        end
    steps:
    - Implement server-side OTP generation and storage (temporary, expires after a
      certain time or after it is used).
    - Upon user OTP submission, verify it against the OTP stored on the server.
    - Consider using OTP validation libraries to handle this more securely and efficiently.
  title: Authentication Mechanism Absence or Evasion - OTP
  vulnerability_id: '240'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.12.0 and above) for building composable web applications in Elixir
  - Usage of Plug.Crypto library (version 1.2.0 and above) for cryptographic operations
  need: Ensure that credit card information is encrypted both during transport and
    at rest.
  solution:
    considerations:
    - Always use secure connections (HTTPS) to transport sensitive data.
    - Use strong and unique encryption keys.
    - Rotate encryption keys regularly.
    - Store encryption keys securely and separately from the data they encrypt.
    insecure_code_example:
      description: The code is insecure because it directly uses the credit card data
        without any form of encryption. This allows anyone who can intercept the data
        to have access to sensitive credit card information.
      text: |-
        defmodule MyAppWeb.PaymentController do
          use MyAppWeb, :controller

          def process_payment(conn, %{'card_number' => card_number, 'expiry_date' => expiry_date, 'cvv' => cvv}) do
            payment_successful = PaymentProcessor.process(card_number, expiry_date, cvv)
            if payment_successful do
              json(conn, %{status: 'success'})
            else
              json(conn, %{status: 'error'})
            end
          end
        end
    language: elixir
    secure_code_example:
      description: The code is secure because it decrypts the encrypted credit card
        data on the server side before processing the payment, which means the credit
        card information is encrypted during transport.
      text: |-
        defmodule MyAppWeb.PaymentController do
          use MyAppWeb, :controller
          alias Plug.Crypto.KeyGenerator

          def process_payment(conn, %{'card_number' => enc_card_number, 'expiry_date' => enc_expiry_date, 'cvv' => enc_cvv}) do
            key = KeyGenerator.generate(conn.private.salt, conn.private.iteration)
            card_number = KeyGenerator.stream_decrypt(key, enc_card_number)
            expiry_date = KeyGenerator.stream_decrypt(key, enc_expiry_date)
            cvv = KeyGenerator.stream_decrypt(key, enc_cvv)
            payment_successful = PaymentProcessor.process(card_number, expiry_date, cvv)
            if payment_successful do
              json(conn, %{status: 'success'})
            else
              json(conn, %{status: 'error'})
            end
          end
        end
    steps:
    - Install Plug.Crypto library to handle encryption and decryption of sensitive
      data.
    - Encrypt credit card data before sending it to the server.
    - Decrypt the data server-side before processing the payment.
    - Always use secure connections (HTTPS) to transport sensitive data.
  title: Non-encrypted Confidential Information - Credit Cards
  vulnerability_id: '245'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and concurrent applications
  - Usage of Ecto (3.7.1 and above) for database query and manipulation
  - Usage of Cloak (1.1.0 and above) for data encryption and protection
  need: Ensure that user query information stored in the database is encrypted.
  solution:
    considerations:
    - Use strong and unique encryption keys.
    - Rotate encryption keys regularly.
    - Store encryption keys securely and separately from the data they encrypt.
    insecure_code_example:
      description: The code is insecure because it directly stores the user's queries
        into the database without any form of encryption. This allows anyone who has
        access to the database to view sensitive user query information.
      text: |-
        defmodule MyApp.Repo.Migrations.CreateUser do
          use Ecto.Migration

          def change do
            create table(:users) do
              add :query, :string
              timestamps()
            end
          end
        end
    language: elixir
    secure_code_example:
      description: The code is secure because it encrypts the user's queries before
        storing them in the database. The query data is decrypted when accessed, ensuring
        the stored data is unreadable without the decryption key.
      text: |-
        defmodule MyApp.Repo.Migrations.CreateUser do
          use Ecto.Migration

          def change do
            create table(:users) do
              add :query, Cloak.Encrypted.Binary
              timestamps()
            end
          end
        end
    steps:
    - Install the Cloak library to handle encryption and decryption of sensitive data.
    - Encrypt user query data before storing it in the database.
    - Decrypt the data when accessing it.
  title: Non-encrypted Confidential Information - Database
  vulnerability_id: '246'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Exldap (0.5.7 and above) for LDAP integration
  - Usage of Cloak for data encryption and decryption
  need: Ensure that LDAP service credentials are encrypted.
  solution:
    considerations:
    - Use strong and unique encryption keys.
    - Rotate encryption keys regularly.
    - Store encryption keys securely and separately from the data they encrypt.
    insecure_code_example:
      description: The code is insecure because it exposes LDAP service credentials
        in plain text. This allows anyone who has access to the code to obtain the
        credentials and access the LDAP service.
      text: |-
        defmodule MyApp.Ldap do
          def ldap_config() do
            {:ok, 'ldap.myapp.com', 'admin', 'password'}
          end
        end
    language: elixir
    secure_code_example:
      description: The code is secure because it encrypts the LDAP service credentials
        before storing them in the code. The credentials are decrypted when accessed,
        ensuring the stored credentials are unreadable without the decryption key.
      text: |-
        defmodule MyApp.Ldap do
          def ldap_config() do
            encrypted_host = Cloak.Cipher.encrypt('ldap.myapp.com')
            encrypted_username = Cloak.Cipher.encrypt('admin')
            encrypted_password = Cloak.Cipher.encrypt('password')
            {:ok, encrypted_host, encrypted_username, encrypted_password}
          end
        end
    steps:
    - Install the Cloak library to handle encryption and decryption of sensitive data.
    - Encrypt LDAP service credentials before storing them in the code.
    - Decrypt the data when accessing it.
  title: Non-encrypted Confidential Information - LDAP
  vulnerability_id: '248'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Ecto (3.6.2 and above) for database query and manipulation
  - Usage of Cloak for data encryption and protection (version 1.1.0 and above)
  need: To ensure sensitive information such as API keys and passwords are not included
    in plain text in the source code.
  solution:
    considerations:
    - Avoid committing sensitive data to version control systems.
    - Use environment variables to handle sensitive data.
    - Never log sensitive data.
    insecure_code_example:
      description: This code is vulnerable because the database password is stored
        in plain text in the source code. Anyone with access to the source code can
        access the database, posing a serious security risk.
      text: |-
        defmodule MyApp.Repo do
          use Ecto.Repo,
            otp_app: :my_app,
            adapter: Ecto.Adapters.Postgres,
            password: 'plaintextpassword',
            username: 'admin'
        end
    language: elixir
    secure_code_example:
      description: In the secure code, the database credentials are encrypted and
        stored as environment variables. The Cloak library is used to decrypt the
        credentials when they are accessed. This prevents them from being exposed
        in plain text in the source code.
      text: |-
        defmodule MyApp.Repo do
          use Ecto.Repo,
            otp_app: :my_app,
            adapter: Ecto.Adapters.Postgres,
            password: System.get_env('DB_PASSWORD') |> Cloak.Cipher.decrypt(),
            username: System.get_env('DB_USERNAME') |> Cloak.Cipher.decrypt()
        end
    steps:
    - Install the Cloak library to handle encryption and decryption of sensitive data.
    - Encrypt credentials before storing them in the code.
    - Decrypt the credentials when accessing them.
  title: Non-encrypted Confidential Information - Credentials
  vulnerability_id: '249'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Ecto (3.6.2 and above) for database query and manipulation
  - Usage of Plug (1.11.1 and above) for building composable web applications in Elixir
  need: To prevent the listing and exposure of credit card information by implementing
    proper validation.
  solution:
    considerations:
    - Sensitive information should never be logged or exposed in any way.
    - It's recommended to use available libraries for credit card validation.
    - Remember to handle validation errors and return appropriate responses to the
      client.
    insecure_code_example:
      description: This code is vulnerable because there's no validation of the expiration
        date and security code of the credit card. This lack of validation could allow
        an attacker to list credit card information.
      text: |-
        defmodule MyApp.PaymentController do
          use MyApp.Web, :controller

          def create(conn, %{"card" => card_params}) do
            {:ok, card} = MyApp.Card.create_card(card_params)
            render(conn, "card.json", card: card)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, we've added a card validation step
        using the `validate_card` function. This function checks the expiration date
        and security code of the credit card before creating it.
      text: |-
        defmodule MyApp.PaymentController do
          use MyApp.Web, :controller

          def create(conn, %{"card" => card_params}) do
            with :ok <- MyApp.Card.validate_card(card_params),
                 {:ok, card} <- MyApp.Card.create_card(card_params) do
              render(conn, "card.json", card: card)
            else
              _ -> send_resp(conn, :bad_request, "Invalid card information.")
            end
          end
        end
    steps:
    - Implement validation for the expiration date and security code in the card creation
      function.
    - Install a credit card validation library if available.
  title: Automatic Information Enumeration - Credit Cards
  vulnerability_id: '254'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.11.1 and above) for building composable web applications in Elixir
  - Usage of Plug.Crypto for cryptographic operations (version 1.2.0 and above)
  need: To secure the information transmitted between the client and the server using
    cryptographically secure algorithms.
  solution:
    considerations:
    - Use the most secure and recent encryption algorithms.
    - Ensure to keep your encryption libraries up-to-date.
    - Store encryption keys securely and consider key management best practices.
    insecure_code_example:
      description: This code is vulnerable because it uses the DSA encryption algorithm
        which is considered insecure. It could allow an attacker to decrypt the information
        transmitted between the client and the server.
      text: |-
        defmodule MyApp.Encryption do
          def encrypt(data) do
            {:ok, key} = Plug.Crypto.KeyGenerator.generate(:dsa, {1024, 160}, :sha)
            {:ok, cipher} = :crypto.block_encrypt(:des, key, data)
            {:ok, cipher}
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, we've replaced the DSA encryption
        algorithm with RSA, which is considered secure. We've also switched the symmetric
        encryption algorithm from DES to AES.
      text: |-
        defmodule MyApp.Encryption do
          def encrypt(data) do
            {:ok, key} = Plug.Crypto.KeyGenerator.generate(:rsa, :sha256)
            {:ok, cipher} = :crypto.block_encrypt(:aes, key, data)
            {:ok, cipher}
          end
        end
    steps:
    - Replace the insecure DSA algorithm with a secure one like RSA or ECC.
    - Ensure to use the appropriate key length based on the encryption algorithm.
  title: Insecure Encryption Algorithm - DSA
  vulnerability_id: '261'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug (1.11.1 and above) for building composable web applications in Elixir
  - Usage of Plug.Crypto for cryptographic operations (version 1.2.0 and above)
  need: To secure the information transmitted between the client and the server using
    cryptographically secure algorithms.
  solution:
    considerations:
    - Use the most secure and recent encryption algorithms.
    - Ensure to keep your encryption libraries up-to-date.
    - Store encryption keys securely and consider key management best practices.
    insecure_code_example:
      description: This code is vulnerable because it uses the SHA1 encryption algorithm
        which is considered insecure. It could allow an attacker to reverse a summary
        function to find sensitive information.
      text: |-
        defmodule MyApp.Encryption do
          def generate_hash(data) do
            :crypto.hash(:sha, data)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, we've replaced the SHA1 encryption
        algorithm with SHA256, which is considered secure. This will effectively mitigate
        the risks associated with SHA1.
      text: |-
        defmodule MyApp.Encryption do
          def generate_hash(data) do
            :crypto.hash(:sha256, data)
          end
        end
    steps:
    - Replace the insecure SHA1 algorithm with a secure one like SHA256 or SHA3.
    - Ensure to use the appropriate hash function based on the encryption algorithm.
  title: Insecure Encryption Algorithm - SHA1
  vulnerability_id: '262'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Ecto (3.6.2 and above) for database query and manipulation
  - Usage of Comeonin for password hashing and encryption
  - Usage of Bcrypt_elixir for secure password hashing and verification
  need: To secure user passwords using cryptographically secure hashing algorithms.
  solution:
    considerations:
    - Store hashed passwords securely and consider best practices for password storage.
    - Regularly update your hashing libraries to ensure you are using the most secure
      and recent versions.
    - Consider adding other layers of security such as two-factor authentication.
    insecure_code_example:
      description: This code is vulnerable because it uses the MD5 hash function which
        is considered insecure. It could allow an attacker to easily crack captured
        credentials.
      text: |-
        defmodule MyApp.User do
          use Ecto.Schema

          schema "users" do
            field :password_hash, :string
          end

          def hash_password(password) do
            :crypto.hash(:md5, password)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, we've replaced the MD5 hash function
        with Bcrypt, which is considered secure. This will effectively mitigate the
        risks associated with MD5.
      text: |-
        defmodule MyApp.User do
          use Ecto.Schema
          import Comeonin.Bcrypt

          schema "users" do
            field :password_hash, :string
          end

          def hash_password(password) do
            hashpwsalt(password)
          end
        end
    steps:
    - Replace the insecure MD5 hash function with a secure one like PBKDF2 or Bcrypt.
    - Use the Bcrypt library provided by 'Comeonin' and 'Bcrypt_elixir' to hash passwords.
  title: Insecure Encryption Algorithm - MD5
  vulnerability_id: '263'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of crypto module for encryption
  need: To secure sensitive data using secure encryption algorithms.
  solution:
    considerations:
    - Ensure that the encryption key and initialization vector (iv) are securely generated
      and stored.
    - Regularly update your cryptographic libraries to ensure you are using the most
      secure and recent versions.
    - Always encrypt data using secure encryption algorithms and modes.
    insecure_code_example:
      description: The code is vulnerable because it uses TripleDES algorithm for
        encryption which is now considered insecure. The use of this algorithm can
        lead to exposure of sensitive data if the encrypted data is intercepted.
      text: |-
        defmodule MyApp.Crypto do
          def encrypt(data, key) do
            :crypto.block_encrypt(:des_ede3, key, data)
          end

          def decrypt(ciphertext, key) do
            :crypto.block_decrypt(:des_ede3, key, ciphertext)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, we've replaced the insecure TripleDES
        algorithm with AES, which is considered secure. This will effectively protect
        sensitive data from being exposed even if intercepted.
      text: |-
        defmodule MyApp.Crypto do
          def encrypt(data, key, iv) do
            :crypto.block_encrypt(:aes_cbc128, {key, iv}, data)
          end

          def decrypt(ciphertext, key, iv) do
            :crypto.block_decrypt(:aes_cbc128, {key, iv}, ciphertext)
          end
        end
    steps:
    - Use a secure encryption algorithm such as AES.
    - Replace the :des_ede3 atom with :aes_cbc128 or :aes_cbc256 in the :crypto.block_encrypt/3
      and :crypto.block_decrypt/3 functions.
  title: Insecure Encryption Algorithm - TripleDES
  vulnerability_id: '264'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of crypto module for encryption
  need: Secure encryption of sensitive data.
  solution:
    considerations:
    - Ensure that the encryption key, initialization vector (iv), and additional associated
      data (aad) are securely generated and stored.
    - Regularly update your cryptographic libraries to ensure you are using the most
      secure and recent versions.
    - Always encrypt data using secure encryption algorithms and modes.
    insecure_code_example:
      description: The code is vulnerable because it uses AES encryption in CBC mode,
        which is susceptible to padding oracle attacks. The encryption mode used does
        not ensure the authenticity of the data, which can lead to vulnerabilities.
      text: |-
        defmodule MyApp.Crypto do
          def encrypt(data, key, iv) do
            :crypto.block_encrypt(:aes_cbc128, {key, iv}, data)
          end

          def decrypt(ciphertext, key, iv) do
            :crypto.block_decrypt(:aes_cbc128, {key, iv}, ciphertext)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, AES encryption is used in GCM mode,
        which provides both data confidentiality and authenticity. This protects against
        padding oracle attacks and ensures that the encrypted data has not been tampered
        with.
      text: |-
        defmodule MyApp.Crypto do
          def encrypt(data, key, iv, aad) do
            :crypto.block_encrypt(:aes_gcm, {key, iv}, aad, data)
          end

          def decrypt(ciphertext, key, iv, aad, tag) do
            :crypto.block_decrypt(:aes_gcm, {key, iv}, aad, tag, ciphertext)
          end
        end
    steps:
    - Use a secure encryption mode like GCM which also provides data authenticity.
    - Replace the :aes_cbc128 atom with :aes_gcm in the :crypto.block_encrypt/3 and
      :crypto.block_decrypt/3 functions, and use an appropriate authentication tag.
  title: Insecure Encryption Algorithm - AES
  vulnerability_id: '265'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Ecto for data access and manipulation
  - Usage of Phoenix framework for web request handling
  need: Ensure data integrity and prevent unauthorized information updates.
  solution:
    considerations:
    - Ensure that all sensitive actions in your application include a permission check.
    - Regularly audit your code for authorization vulnerabilities.
    - Use tools and libraries that enforce good security practices.
    insecure_code_example:
      description: This Elixir/Phoenix code does not check if the current user has
        the correct permissions to update the employee data. As a result, an attacker
        can initiate a request to update the data of any employee, changing critical
        information.
      text: |-
        defmodule MyApp.EmployeeController do
          use MyApp, :controller

          def update(conn, %{"employee" => employee_params}) do
            {:ok, employee} = MyApp.EmployeeContext.update_employee(employee_params)
            render(conn, "show.html", employee: employee)
          end
        end
    language: elixir
    secure_code_example:
      description: This secure Elixir/Phoenix code example includes a permissions
        check before updating the employee data. The can_update_employee? function
        checks if the current user has the necessary permissions to update the specified
        employee. This prevents an attacker from updating the data of any employee.
      text: |-
        defmodule MyApp.EmployeeController do
          use MyApp, :controller

          def update(conn, %{"employee" => employee_params}) do
            current_user = get_current_user(conn)
            if MyApp.EmployeeContext.can_update_employee?(current_user, employee_params["id"]) do
              {:ok, employee} = MyApp.EmployeeContext.update_employee(employee_params)
              render(conn, "show.html", employee: employee)
            else
              send_resp(conn, :forbidden, "You are not allowed to update this employee.")
            end
          end
        end
    steps:
    - Implement user authentication and permission checks.
    - Before updating the employee data, ensure that the current user has the necessary
      permissions to do so.
  title: Restricted Fields Manipulation
  vulnerability_id: '274'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix framework for web request handling
  - Usage of Guardian for JWT session management
  need: Prevent unauthorized access to user sessions.
  solution:
    considerations:
    - Sensitive information such as JWTs should never be sent in the URL.
    - Always consider secure ways to transmit sensitive information.
    - Regularly review your code for potential security vulnerabilities.
    insecure_code_example:
      description: This Elixir/Phoenix code does not handle JWT session tokens securely.
        It sends the JWT as a URL parameter which can be cached by the browser or
        logged in server logs. This exposes the token to potential theft.
      text: |-
        defmodule MyApp.SessionController do
          use MyApp, :controller

          def create(conn, %{"user" => user_params}) do
            jwt = MyApp.SessionContext.create_jwt(user_params)
            redirect(conn, to: "/welcome?jwt=#{jwt}")
          end
        end
    language: elixir
    secure_code_example:
      description: This secure Elixir/Phoenix code example sends the JWT as an HTTP
        header. This prevents it from being exposed in the URL or cached by the browser.
      text: |-
        defmodule MyApp.SessionController do
          use MyApp, :controller

          def create(conn, %{"user" => user_params}) do
            jwt = MyApp.SessionContext.create_jwt(user_params)
            conn = put_resp_header(conn, "authorization", "Bearer #{jwt}")
            redirect(conn, to: "/welcome")
          end
        end
    steps:
    - Don't send sensitive information such as JWTs in the URL.
    - Instead, use secure mechanisms such as HTTP headers or cookies.
  title: Sensitive Information Sent Via URL Parameters - Session
  vulnerability_id: '276'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix framework for web request handling
  - Usage of Plug.Session for session management
  need: Prevent session hijacking by securing session cookies.
  solution:
    considerations:
    - Always regenerate the session after a privilege level change, such as login
      or logout.
    - Regularly review your code for potential security vulnerabilities.
    insecure_code_example:
      description: This Elixir/Phoenix code does not handle session cookies securely.
        The session cookie is not regenerated after login, which allows an attacker
        to fixate a session, and then hijack the user session once the victim logs
        in.
      text: |-
        defmodule MyApp.SessionController do
          use MyApp, :controller

          def create(conn, %{"user" => user_params}) do
            case MyApp.Authenticator.authenticate(user_params) do
              {:ok, user} ->
                conn
                |> put_session(:user_id, user.id)
                |> redirect(to: "/welcome")
              {:error, reason} ->
                render(conn, "login.html", error: reason)
            end
          end
        end
    language: elixir
    secure_code_example:
      description: 'This secure Elixir/Phoenix code example regenerates the session
        cookie after a successful login. The call to ''configure_session(renew: true)''
        ensures a new session is created, preventing session fixation.'
      text: |-
        defmodule MyApp.SessionController do
          use MyApp, :controller

          def create(conn, %{"user" => user_params}) do
            case MyApp.Authenticator.authenticate(user_params) do
              {:ok, user} ->
                conn
                |> configure_session(renew: true)
                |> put_session(:user_id, user.id)
                |> redirect(to: "/welcome")
              {:error, reason} ->
                render(conn, "login.html", error: reason)
            end
          end
        end
    steps:
    - Regenerate the session cookie after login to prevent session fixation.
    - This can be done by deleting the old session and creating a new one.
  title: Session Fixation
  vulnerability_id: '280'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of crypto module for encryption and decryption
  need: Securely encrypt sensitive information.
  solution:
    considerations:
    - The key and IV should be kept secret.
    - The IV should be unique for each encryption operation, but does not need to
      be kept secret.
    - The chosen encryption mode and practices should comply with current industry
      standards.
    insecure_code_example:
      description: The code uses the Electronic Code Book (ECB) mode for AES encryption,
        which is not secure. In ECB mode, the same plaintext block will always produce
        the same ciphertext block, creating patterns that could be exploited.
      text: |-
        defmodule MyApp.Crypto do
          def encrypt(text, key) do
            :crypto.block_encrypt(:aes_ecb, key, text)
          end

          def decrypt(ciphertext, key) do
            :crypto.block_decrypt(:aes_ecb, key, ciphertext)
          end
        end
    language: elixir
    secure_code_example:
      description: This secure Elixir code example uses the CBC mode for AES encryption,
        which is more secure than ECB mode. It also uses an Initialization Vector
        (IV) for encryption, which should be unique for each encryption operation.
      text: |-
        defmodule MyApp.Crypto do
          def encrypt(text, key, iv) do
            :crypto.block_encrypt(:aes_cbc128, key, iv, text)
          end

          def decrypt(ciphertext, key, iv) do
            :crypto.block_decrypt(:aes_cbc128, key, iv, ciphertext)
          end
        end
    steps:
    - Use a more secure encryption mode, such as Cipher Block Chaining (CBC) or Galois/Counter
      Mode (GCM).
    - Use an Initialization Vector (IV) for encryption, which should be unique for
      each encryption operation.
  title: Insecure encryption algorithm - ECB
  vulnerability_id: '282'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for web development
  - Usage of Ecto for database interactions
  need: To prevent unauthorized access to user's personal information.
  solution:
    considerations:
    - You need a mechanism for authenticating users and maintaining their session.
    - The ID comparison should be resistant to timing attacks.
    - Consider using role-based access control (RBAC) or similar for more fine-grained
      control over access to resources.
    insecure_code_example:
      description: This code is vulnerable because it fetches and returns user information
        based solely on the user ID provided in the request, without any authentication
        or authorization checks. An attacker could potentially iterate over user IDs
        to retrieve personal information about all users.
      text: |-
        defmodule MyApp.UserController do
          use MyApp, :controller

          def show(conn, %{'id' => id}) do
            user = MyApp.Repo.get(MyApp.User, id)
            render(conn, 'show.html', user: user)
          end
        end
    language: elixir
    secure_code_example:
      description: This secure code example introduces authentication and authorization
        checks. Before accessing a user's information, the current user is fetched
        from the session, and the user can only access their own information. If an
        unauthenticated user or a user trying to access someone else's information
        attempts to use the 'show' action, they receive an 'unauthorized' response.
      text: |-
        defmodule MyApp.UserController do
          use MyApp, :controller

          def show(conn, %{'id' => id}) do
            current_user = get_authenticated_user(conn)
            if current_user && current_user.id == id do
              render(conn, 'show.html', user: current_user)
            else
              send_resp(conn, :unauthorized, '')
            end
          end

          defp get_authenticated_user(conn) do
            # Fetch the current user from the session
          end
        end
    steps:
    - Authenticate the user before accessing the 'show' action.
    - Authorize the user to only access their own user information.
  title: Automatic information enumeration - Personal Information
  vulnerability_id: '283'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug for building modular web applications
  - Usage of Cowboy as the HTTP server
  need: To prevent exposure of internal technical information.
  solution:
    considerations:
    - Never expose internal technical information like IP addresses or server configuration
      details.
    - Make sure to review your application's headers, as they can unintentionally
      leak sensitive information.
    - Ensure that your team is trained on the risks of information leakage and the
      importance of data minimization.
    insecure_code_example:
      description: This code is vulnerable because it sets a response header (`X-Server-IP`)
        with the internal IP address of the server (`192.168.0.1`). This exposes internal
        technical information that could be exploited by an attacker.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/" do
            conn
            |> put_resp_header("X-Server-IP", "192.168.0.1")
            |> send_resp(200, "Welcome to MyApp!")
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, the response header setting the `X-Server-IP`
        has been removed. The application no longer exposes the server's internal
        IP address in its responses.
      text: |-
        defmodule MyApp.Router do
          use Plug.Router

          plug :match
          plug :dispatch

          get "/" do
            send_resp(conn, 200, "Welcome to MyApp!")
          end
        end
    steps:
    - Remove any code that sets response headers with sensitive technical information.
    - Review your codebase and remove any other instances of sensitive information
      leaks.
    - Ensure your team is aware of the risk of exposing technical information.
  title: Technical information leak - IPs
  vulnerability_id: '290'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Ecto for data persistence
  need: To prevent exposure of sensitive business information.
  solution:
    considerations:
    - Never expose sensitive business or financial information unless absolutely necessary.
    - Always consider the principle of least privilege when designing your application's
      data access policies.
    - Ensure your team is aware of the risks of information leakage and the importance
      of data minimization.
    insecure_code_example:
      description: This code is vulnerable because it retrieves a user from the database
        and exposes all of its associated information in the response, including potentially
        sensitive financial information. An attacker could exploit this by making
        requests to this endpoint and collecting the exposed data.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def show(conn, %{"id" => id}) do
            user = Repo.get!(User, id)
            render(conn, "show.html", user: user)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, the `Map.take/2` function is used
        to only include the `id`, `name`, and `email` fields in the response. Any
        potentially sensitive financial information associated with the user is not
        included.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def show(conn, %{"id" => id}) do
            user = Repo.get!(User, id)
            safe_user = Map.take(user, [:id, :name, :email])
            render(conn, "show.html", user: safe_user)
          end
        end
    steps:
    - Ensure that sensitive information is not included in API responses or rendered
      views.
    - Review your data models and remove or obfuscate sensitive fields as necessary.
    - Implement proper access controls to prevent unauthorized access to sensitive
      data.
  title: Business information leak - Financial Information
  vulnerability_id: '291'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Ecto for data persistence
  need: To prevent denial of service by repeatedly changing user's password.
  solution:
    considerations:
    - Rate limiting must be enforced across multiple instances of your application
      if it is distributed.
    - Keep in mind that rate limiting could potentially lock out users who legitimately
      need to change their password multiple times.
    - You should have a mechanism in place for users to contact support if they are
      locked out of their account.
    insecure_code_example:
      description: This code is vulnerable because it allows a user's password to
        be changed without any limit on the number of requests. If an attacker is
        able to authenticate as a user, they can lock the user out of their account
        by repeatedly changing the password.
      text: |-
        defmodule MyAppWeb.AccountController do
          use MyAppWeb, :controller

          def change_password(conn, %{"password" => password, "user_id" => id}) do
            user = Repo.get!(User, id)
            changeset = User.changeset(user, %{password: password})
            Repo.update!(changeset)
            render(conn, "password_changed.html")
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, the `can_change_password?` function
        checks if the user has already changed their password within the rate limit
        period. If they have, the password change request is rejected and a different
        view is rendered.
      text: |-
        defmodule MyAppWeb.AccountController do
          use MyAppWeb, :controller

          def change_password(conn, %{"password" => password, "user_id" => id}) do
            user = Repo.get!(User, id)
            if can_change_password?(user) do
              changeset = User.changeset(user, %{password: password})
              Repo.update!(changeset)
              update_last_password_change(user)
              render(conn, "password_changed.html")
            else
              render(conn, "password_change_limit.html")
            end
          end

          defp can_change_password?(user) do
            # check if user can change password
          end

          defp update_last_password_change(user) do
            # update the time of last password change
          end
        end
    steps:
    - Implement a rate limit on password change requests.
    - Consider using a library or built-in framework feature to enforce rate limiting.
    - Monitor account activity for suspicious behavior such as repeated password change
      requests.
  title: Weak credential policy - Password Change Limit
  vulnerability_id: '296'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Ecto for data persistence
  need: To prevent unauthorized database access and manipulation via SQL Injection.
  solution:
    considerations:
    - Even though Elixir's Ecto library helps prevent SQL injection, you should still
      always validate and sanitize user-supplied input to ensure data integrity.
    - While this code prevents SQL Injection, it does not prevent other types of attacks
      such as Cross-Site Scripting (XSS). Always consider all aspects of security
      in your application.
    insecure_code_example:
      description: This code is vulnerable because it's constructing a SQL query by
        directly appending user-supplied input (`id`) to the SQL statement. An attacker
        can manipulate the `id` input to execute arbitrary SQL queries against the
        database, leading to unauthorized access or data manipulation.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def show(conn, %{"id" => id}) do
            user = MyApp.Repo.one("SELECT * FROM users WHERE id = " <> id)
            render(conn, "show.html", user: user)
          end
        end
    language: elixir
    secure_code_example:
      description: This code is safe because it's using Ecto's query API to create
        a SQL query. The `^` operator is used to safely interpolate values in a query,
        which prevents SQL Injection attacks.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def show(conn, %{"id" => id}) do
            user = MyApp.Repo.one(from u in User, where: u.id == ^id)
            render(conn, "show.html", user: user)
          end
        end
    steps:
    - Avoid creating SQL queries by string concatenation with user-supplied input.
    - Use Ecto's query API or parameterized queries to safely interact with the database.
    - Always validate and sanitize user-supplied inputs.
  title: SQL Injection - Code
  vulnerability_id: '297'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Plug for request handling
  need: To sanitize and validate input data to prevent HTML injection attacks.
  solution:
    considerations:
    - Ensure that all user-provided data is validated and sanitized before use.
    - Remember that client-side validation can be bypassed and must always be complemented
      with server-side validation.
    - Always update your libraries to the latest versions as they often contain security
      patches.
    insecure_code_example:
      description: The above code is insecure as it directly uses the user-provided
        data in the 'data' parameter without any validation or sanitization. This
        allows an attacker to inject HTML code that will be rendered and potentially
        execute malicious scripts when viewed in a browser.
      text: |-
        defmodule MyAppWeb.PageController do
          use MyAppWeb, :controller

          def show(conn, %{"data" => data}) do
            render(conn, "show.html", data: data)
          end
        end
    language: elixir
    secure_code_example:
      description: The code is now secure as it uses the 'html_escape' function from
        the Phoenix.HTML module to sanitize the user-provided data before rendering
        it. This ensures that any HTML code provided by the user is escaped and rendered
        as plain text, preventing any potential HTML injection attacks.
      text: |-
        defmodule MyAppWeb.PageController do
          use MyAppWeb, :controller

          def show(conn, %{"data" => data}) do
            sanitized_data = Phoenix.HTML.html_escape(data)
            render(conn, "show.html", data: sanitized_data)
          end
        end
    steps:
    - Never trust user input and always sanitize it.
    - Use server-side validation to ensure that user-provided data is safe to use.
    - Consider using libraries that automatically escape HTML in text.
  title: Lack of data validation - HTML code
  vulnerability_id: '321'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and concurrent applications
  - Usage of Phoenix Framework for building web applications
  need: To protect the application against automated attacks aimed at guessing promotional
    codes.
  solution:
    considerations:
    - Setting rate limits too low may impact usability for legitimate users. Consider
      your user's typical usage patterns when setting limits.
    - While captchas can help deter automated attacks, they also add friction for
      users and can be bypassed by advanced attackers.
    insecure_code_example:
      description: The code above is vulnerable because it directly accepts and verifies
        promo codes without any rate limiting or captcha protection. This can be exploited
        by an attacker to conduct brute force attacks, i.e., trying different codes
        until a valid one is found.
      text: |-
        defmodule MyAppWeb.PromoController do
          use MyAppWeb, :controller

          def check_promo(conn, %{"promo_code" => promo_code}) do
            if PromoCode.valid?(promo_code) do
              render(conn, "success.html")
            else
              render(conn, "failure.html")
            end
          end
        end
    language: elixir
    secure_code_example:
      description: The updated code now includes a rate limiter which limits the number
        of requests that can be made to the 'check_promo' endpoint within a certain
        timeframe. This mitigates the risk of brute force attacks by making it infeasible
        to guess a valid promo code within a reasonable time.
      text: |-
        defmodule MyAppWeb.PromoController do
          use MyAppWeb, :controller

          plug MyAppWeb.Plugs.RateLimiter when action in [:check_promo]

          def check_promo(conn, %{"promo_code" => promo_code}) do
            if PromoCode.valid?(promo_code) do
              render(conn, "success.html")
            else
              render(conn, "failure.html")
            end
          end
        end
    steps:
    - Install a rate limiting package or use built-in features in your web framework.
    - Implement rate limiting on the 'check_promo' endpoint to limit the number of
      requests from an IP address within a certain period.
    - Consider adding a captcha to further prevent automated submissions.
  title: Lack of protection against brute force attacks - Credentials
  vulnerability_id: '330'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and concurrent applications
  - Usage of Cowboy HTTP server for handling HTTP requests
  need: To protect sensitive information during transmission over a network.
  solution:
    considerations:
    - Ensure that the TLS certificate for your domain is valid and renewed before
      it expires.
    - The use of HTTPS can slightly impact server performance due to the overhead
      of encryption. However, the security benefits generally outweigh this cost.
    insecure_code_example:
      description: The code above configures an HTTP server with no encryption. Any
        data sent between the server and clients is vulnerable to interception. This
        can be exploited by an attacker to capture sensitive information and credentials
        in plain text, or intercept communication and steal or forge requests and
        responses.
      text: |-
        defmodule MyAppWeb.Endpoint do
          use Phoenix.Endpoint, otp_app: :my_app

          socket "/socket", MyAppWeb.UserSocket,
            websocket: true,
            longpoll: false

          plug Plug.Static,
            at: "/",
            from: :my_app,
            gzip: false,
            only: ~w(css fonts images js favicon.ico robots.txt)

          plug Plug.RequestId
          plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

          plug Plug.Parsers,
            parsers: [:urlencoded, :multipart, :json],
            pass: ["*/*"],
            json_decoder: Phoenix.json_library()

          plug Plug.MethodOverride
          plug Plug.Head

          plug Plug.Session, store: :cookie

          plug MyAppWeb.Router
        end
    language: elixir
    secure_code_example:
      description: The updated code now includes the 'Plug.ForceSSL' plug, which redirects
        all non-HTTPS requests to HTTPS, ensuring that all data is transmitted over
        an encrypted channel. This mitigates the risk of data interception and forgery.
      text: |-
        defmodule MyAppWeb.Endpoint do
          use Phoenix.Endpoint, otp_app: :my_app

          socket "/socket", MyAppWeb.UserSocket,
            websocket: true,
            longpoll: false

          plug Plug.Static,
            at: "/",
            from: :my_app,
            gzip: false,
            only: ~w(css fonts images js favicon.ico robots.txt)

          plug Plug.RequestId
          plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

          plug Plug.Parsers,
            parsers: [:urlencoded, :multipart, :json],
            pass: ["*/*"],
            json_decoder: Phoenix.json_library()

          plug Plug.MethodOverride
          plug Plug.Head

          plug Plug.Session, store: :cookie

          plug Plug.ForceSSL
          plug MyAppWeb.Router
        end
    steps:
    - Acquire a valid TLS certificate for your domain.
    - Configure your server to use HTTPS with the TLS certificate.
    - Redirect all HTTP requests to HTTPS.
  title: Use of insecure channel - Source code
  vulnerability_id: '332'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for web development
  - Usage of Ecto for database interactions
  need: To secure sensitive information like service credentials.
  solution:
    considerations:
    - Always store sensitive data like service credentials securely, outside the application
      source code.
    - Ensure that your hosting environment is configured to securely handle environment
      variables.
    - Environment variables are often not enough for high-security environments, consider
      using a secure and encrypted key vault service.
    - After moving sensitive data out of source code, make sure to purge the data
      from your version control history.
    insecure_code_example:
      description: This code is vulnerable because it stores service credentials as
        Base64 encoded strings in the source code. While Base64 encoding might obscure
        the credentials at first glance, it is a reversible operation that does not
        provide any real security. Anyone with access to the code can easily decode
        the credentials.
      text: |-
        defmodule MyApp.Config do
          @db_username "c2VydmljZV91c2Vy"
          @db_password "c2VydmljZV9wYXNzd29yZA=="

          def get_db_credentials do
            username = Base.decode64!(@db_username)
            password = Base.decode64!(@db_password)
            {username, password}
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, environment variables are used to
        store the service credentials. This means that the credentials are no longer
        stored in the source code and can be managed securely outside the application,
        for example, through the settings of the hosting environment or using an encrypted
        key vault service.
      text: |-
        defmodule MyApp.Config do

          def get_db_credentials do
            username = System.get_env("DB_USERNAME")
            password = System.get_env("DB_PASSWORD")
            {username, password}
          end
        end
    steps:
    - Use environment variables to store service credentials.
    - Use a secure and encrypted key vault service to store sensitive data.
    - Purge sensitive data from version control history.
  title: Non-encrypted confidential information - Base 64
  vulnerability_id: '284'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  need: To prevent unexpected behavior and potential security risks from unvalidated
    user input.
  solution:
    considerations:
    - Always validate user inputs before processing them.
    - Be careful when defining the regular expressions for validation. Make sure they
      cover all the requirements and don't exclude valid input.
    insecure_code_example:
      description: In this example, the user's name is accepted without validation.
        If a special character is included in the name, it can cause unexpected behavior
        or security vulnerabilities.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def create(conn, %{"user" => %{"name" => name}}) do
            {:ok, user} = MyApp.Accounts.create_user(name)
            render(conn, "show.html", user: user)
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code, the user's name is validated using a regular
        expression, ensuring that it contains only alphanumeric characters and underscores.
        If the validation fails, an error is returned and can be handled by the controller.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def create(conn, %{"user" => %{"name" => name}}) do
            case MyApp.Accounts.create_user(name) do
              {:ok, user} ->
                render(conn, "show.html", user: user)
              {:error, changeset} ->
                render(conn, "new.html", changeset: changeset)
            end
          end
        end

        defmodule MyApp.Accounts.User do
          use Ecto.Schema
          import Ecto.Changeset

          schema "users" do
            field :name, :string
          end

          def changeset(user, attrs) do
            user
            |> cast(attrs, [:name])
            |> validate_format(:name, ~r/^[a-zA-Z0-9_]*$/)
          end
        end
    steps:
    - Implement data validation for all user inputs.
    - Use regular expressions to restrict the characters that can be included in the
      user's name.
    - Handle validation errors gracefully and inform the user of the requirements.
  title: Lack of data validation - Special Characters
  vulnerability_id: '340'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  need: To prevent unauthorized actions by ensuring the OTP used is valid and used
    only once.
  solution:
    considerations:
    - When invalidating the OTP, make sure to handle potential errors to avoid leaving
      the system in an inconsistent state.
    - Consider using a database transaction to ensure the OTP verification and invalidation
      occur atomically.
    insecure_code_example:
      description: In this example, the OTP is verified, but not invalidated after
        use. This means that the same OTP can be used multiple times, allowing for
        potential unauthorized access.
      text: |-
        defmodule MyAppWeb.AuthController do
          use MyAppWeb, :controller

          def verify_otp(conn, %{"otp" => otp}) do
            if MyApp.Auth.verify_otp(otp) do
              render(conn, "success.html")
            else
              render(conn, "error.html")
            end
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code, after the OTP is used, it is invalidated by
        the verify_and_invalidate_otp function in the Auth context. If an invalidated
        OTP is used again, it is treated as an invalid OTP.
      text: |-
        defmodule MyAppWeb.AuthController do
          use MyAppWeb, :controller

          def verify_otp(conn, %{"otp" => otp}) do
            case MyApp.Auth.verify_and_invalidate_otp(otp) do
              :ok ->
                render(conn, "success.html")
              _ ->
                render(conn, "error.html")
            end
          end
        end

        defmodule MyApp.Auth do
          def verify_and_invalidate_otp(otp) do
            if is_valid_and_not_invalidated(otp) do
              invalidate_otp(otp)
              :ok
            else
              :error
            end
          end
        end
    steps:
    - Add an additional step to invalidate the OTP after it has been used.
    - Update the verify_otp function in the Auth context to handle invalidating the
      OTP.
    - Update the controller to handle cases where the OTP is already invalidated.
  title: Lack of data validation - OTP
  vulnerability_id: '341'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of JOSE JWT library for JSON Web Token handling
  need: To ensure the integrity and validity of JWT access tokens used for authentication.
  solution:
    considerations:
    - Ensure the secret key used for JWT signing and verification is kept secure and
      is not hard-coded in your application code.
    - Consider handling additional errors that may arise during token verification.
    - Ensure your application handles the 'Invalid token' response appropriately.
    insecure_code_example:
      description: In this insecure code example, the JWT token is decoded, but its
        signature is not validated. This means that an attacker could modify the payload
        of the token, or even remove the signature entirely, and the server would
        still accept it as valid.
      text: |-
        defmodule MyAppWeb.TokenController do
          use MyAppWeb, :controller

          def verify_token(conn, %{"token" => token}) do
            {:ok, _} = JOSE.JWT.decode(token)
            send_resp(conn, 200, "Token is valid")
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, the application correctly verifies
        the JWT token using the JOSE.JWT.verify_strict function with the appropriate
        algorithm and secret key. This prevents attackers from modifying the token
        payload or removing the signature.
      text: |-
        defmodule MyAppWeb.TokenController do
          use MyAppWeb, :controller

          def verify_token(conn, %{"token" => token}) do
            case JOSE.JWT.verify_strict(token, ["HS256"], "secret") do
              {true, _, _} ->
                send_resp(conn, 200, "Token is valid")
              _ ->
                send_resp(conn, 401, "Invalid token")
            end
          end
        end
    steps:
    - Modify the verify_token function to validate the signature of the JWT token
      using the JOSE.JWT.verify function.
    - Ensure that the secret key used for verification is stored securely and is not
      exposed.
  title: Lack of data validation - Token
  vulnerability_id: '353'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Phoenix Framework for building web applications
  - Usage of Plug.Upload for handling file uploads in Elixir
  need: To prevent system resources exhaustion by limiting the number of files uploaded
    and replacing old files with new ones.
  solution:
    considerations:
    - Ensure your server has enough disk space to handle file uploads.
    - Consider adding more comprehensive checks for the type and size of the uploaded
      file.
    - The rate limiting mechanism in this example is basic and for illustrative purposes
      only. Consider using more advanced rate limiting techniques for production code.
    insecure_code_example:
      description: In this insecure code example, a new file is written to the server's
        storage every time the upload endpoint is hit. There is no limit to the number
        of files that can be uploaded, and old files are not replaced with new ones.
        This could potentially lead to resource exhaustion on the server.
      text: |-
        defmodule MyAppWeb.UploadController do
          use MyAppWeb, :controller

          def upload(conn, %{"file" => file}) do
            {:ok, _} = File.write("./uploads/" <> file.filename, file.read)
            send_resp(conn, 200, "File uploaded")
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, the server deletes old files before
        writing new ones. Additionally, a plug function limits the rate at which files
        can be uploaded, thus preventing resource exhaustion on the server.
      text: |-
        defmodule MyAppWeb.UploadController do
          use MyAppWeb, :controller

          def upload(conn, %{"file" => file}) do
            dir = "./uploads/"
            old_files = File.ls!(dir)
            Enum.each(old_files, &File.rm(dir <> &1))
            {:ok, _} = File.write(dir <> file.filename, file.read)
            send_resp(conn, 200, "File uploaded")
          end

          defp limit_rate(conn, _opts) do
            :timer.sleep(1000)
            conn
          end

          plug :limit_rate when action in [:upload]
        end
    steps:
    - Modify the upload function to delete old files before writing new ones.
    - Apply request throttling to limit the rate at which files can be uploaded.
  title: Insecure file upload - Files Limit
  vulnerability_id: '354'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of HTTPoison for making HTTP requests
  need: To validate the integrity of resources loaded from external sources.
  solution:
    considerations:
    - Ensure to use a secure and collision-resistant hash function for checksum generation.
    - Consider using HTTPS for transmitting the resource and its checksum to prevent
      Man-in-the-Middle (MITM) attacks.
    - Make sure to handle cases where the resource or its checksum could not be fetched
      from the external server.
    insecure_code_example:
      description: This insecure code example fetches a resource from an external
        server and sends it to the client without verifying its integrity. An attacker
        could potentially tamper with the resource on the external server or during
        transmission, and the client would receive a compromised resource.
      text: |-
        defmodule MyAppWeb.ExternalResourceController do
          use MyAppWeb, :controller

          def get_resource(conn, _) do
            {:ok, response} = HTTPoison.get("https://external-server/resource")
            send_resp(conn, 200, response.body)
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code example, the server fetches both the resource
        and its checksum from the external server. It then generates a new checksum
        for the received resource and compares it with the original. If the checksums
        match, the server sends the resource to the client. If not, it rejects the
        resource.
      text: |-
        defmodule MyAppWeb.ExternalResourceController do
          use MyAppWeb, :controller

          def get_resource(conn, _) do
            {:ok, response} = HTTPoison.get("https://external-server/resource")
            {:ok, checksum} = HTTPoison.get("https://external-server/resource_checksum")
            if :crypto.hash(:sha256, response.body) == checksum.body do
              send_resp(conn, 200, response.body)
            else
              send_resp(conn, 403, "Resource integrity compromised")
            end
          end
        end
    steps:
    - Use a cryptographic hash function to generate a checksum for the original resource.
    - Include the checksum alongside the resource when transmitting it.
    - On the receiving end, generate a new checksum for the received resource and
      compare it with the original. If they match, the resource's integrity is confirmed.
  title: Insufficient data authenticity validation - Checksum verification
  vulnerability_id: '355'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug package for handling requests and responses
  need: To prevent unauthorized disclosure of technical details which could be exploited
    for crafting new attack vectors.
  solution:
    considerations:
    - Check all parts of the application to ensure they don't leak technical information,
      not just the response headers.
    - Use tools like security linters or static code analysis tools to find and remove
      any potential leaks.
    insecure_code_example:
      description: In the insecure code, the server includes a 'server' response header
        that reveals the version of the Plug package it's using. This information
        could be used by an attacker to find vulnerabilities in that specific version
        and exploit them.
      text: |-
        defmodule MyAppWeb.MyController do
          use MyAppWeb, :controller

          def index(conn, _params) do
            conn
            |> put_resp_header("server", "Plug/1.12.0")
            |> send_resp(200, "Hello, world!")
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code, the server doesn't include any headers that
        reveal technical details about its configuration. This makes it harder for
        an attacker to find and exploit vulnerabilities.
      text: |-
        defmodule MyAppWeb.MyController do
          use MyAppWeb, :controller

          def index(conn, _params) do
            send_resp(conn, 200, "Hello, world!")
          end
        end
    steps:
    - Remove the code that adds the 'server' header with the version information.
    - Review the application to ensure it doesn't disclose any other technical details
      in its responses.
  title: Technical information leak - Content response
  vulnerability_id: '362'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Comeonin package for password hashing
  need: To prevent unauthorized account access due to weak passwords, which can be
    easily compromised by brute force or dictionary attacks.
  solution:
    considerations:
    - The strength check is a basic one and might not be sufficient for all use cases.
      Consider using a dedicated password strength estimation library.
    - Inform users about the password requirements on the account creation form to
      avoid unnecessary form submissions.
    insecure_code_example:
      description: In the insecure code, the application accepts any password provided
        by the user, without any strength checks. This can lead to weak passwords
        that can be easily cracked by an attacker.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def create(conn, %{"password" => password}) do
            hashed_password = Comeonin.Bcrypt.hashpwsalt(password)
            # ... rest of the code
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code, the application checks the strength of the
        password before accepting it. This prevents users from creating accounts with
        weak passwords.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def create(conn, %{"password" => password}) do
            if strong_password?(password) do
              hashed_password = Comeonin.Bcrypt.hashpwsalt(password)
              # ... rest of the code
            else
              # Respond with an error
            end
          end

          defp strong_password?(password) do
            String.length(password) >= 12 && Regex.match?(~r/[A-Z]/, password) && Regex.match?(~r/[a-z]/, password) && Regex.match?(~r/[0-9]/, password) && Regex.match?(~r/[!@#\$%\^&]/, password)
          end
        end
    steps:
    - Add a password strength check before hashing the password.
    - The check should ensure the password is a certain length, contains a mix of
      uppercase and lowercase letters, numbers, and special characters.
  title: Weak credential policy - Password strength
  vulnerability_id: '363'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Comeonin package for password hashing
  need: To prevent unauthorized account access due to weak temporary passwords, which
    can be easily compromised.
  solution:
    considerations:
    - The generated password could still be difficult for users to remember. Consider
      using a password generator that creates memorable but secure passwords.
    - Make sure to instruct users to change their temporary password immediately after
      logging in.
    insecure_code_example:
      description: In this insecure code, the application assigns a static, weak temporary
        password for all users who request it. This can lead to an attacker easily
        guessing the temporary password.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def create_temporary_password(conn, %{"username" => username}) do
            temporary_password = "password123"
            hashed_password = Comeonin.Bcrypt.hashpwsalt(temporary_password)
            # ... rest of the code
          end
        end
    language: elixir
    secure_code_example:
      description: In the secure code, the application generates a strong, random
        temporary password for each user request. This prevents an attacker from easily
        guessing the temporary password.
      text: |-
        defmodule MyAppWeb.UserController do
          use MyAppWeb, :controller

          def create_temporary_password(conn, %{"username" => username}) do
            temporary_password = :crypto.strong_rand_bytes(12) |> Base.encode64 |> binary_part(0, 12)
            hashed_password = Comeonin.Bcrypt.hashpwsalt(temporary_password)
            # ... rest of the code
          end
        end
    steps:
    - Generate a strong, random temporary password for each user request.
    - The temporary password should be a certain length, contain a mix of uppercase
      and lowercase letters, numbers, and special characters.
    - The temporary password should be unique for each request.
  title: Weak credential policy - Temporary passwords
  vulnerability_id: '364'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) with Phoenix Framework (1.5.7) for building
    web applications
  - Usage of Phoenix configuration file for configuring the Phoenix framework
  need: To secure the transmission of sensitive data between client and server by
    using encryption.
  solution:
    considerations:
    - Getting a trusted SSL certificate from a CA (Certificate Authority) is recommended
      for production deployments.
    - Ensure all your web pages are loaded over HTTPS to avoid mixed content issues.
    - Remember to redirect HTTP traffic to HTTPS.
    insecure_code_example:
      description: In this insecure code, the application is configured to communicate
        over HTTP (port 80) which is a non-encrypted, insecure communication protocol.
        This can expose sensitive data like user credentials to eavesdroppers.
      text: |-
        # In config/prod.exs
        config :my_app, MyAppWeb.Endpoint,
          http: [ip: {127, 0, 0, 1}, port: 80],
          url: [scheme: "http", host: "example.com", port: 80]
    language: elixir
    secure_code_example:
      description: In this secure code, the application is now configured to communicate
        over HTTPS (port 443) with the SSL certificate. This secures the transmission
        of sensitive data with encryption.
      text: |-
        # In config/prod.exs
        config :my_app, MyAppWeb.Endpoint,
          https: [ip: {127, 0, 0, 1}, port: 443, keyfile: "priv/ssl/selfsigned.key", certfile: "priv/ssl/selfsigned.crt"],
          url: [scheme: "https", host: "example.com", port: 443]
    steps:
    - Switch from HTTP to HTTPS. This means you will have to get an SSL certificate
      for your domain.
    - Update the server configuration in the Phoenix configuration file to use HTTPS
      instead of HTTP.
  title: Use of an insecure channel - HTTP
  vulnerability_id: '372'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Elixir's built-in Base module for encoding and decoding data
  need: To ensure the confidentiality and integrity of sensitive information by using
    secure encryption methods.
  solution:
    considerations:
    - Encryption is only as strong as the key. Ensure keys are generated securely
      and stored safely.
    - Make sure to use strong and proven encryption algorithms like AES.
    insecure_code_example:
      description: In this insecure code example, sensitive data is being encoded
        to hexadecimal using Base.encode16(). Although this does obfuscate the data,
        it does not provide any security because it can easily be decoded back into
        its original form.
      text: |-
        defmodule MyApp do
          def encode(data) do
            {:ok, hex_data} = data |> to_string() |> Base.encode16()
            hex_data
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, the AES encryption algorithm is used
        to encrypt the data. This provides both confidentiality and integrity for
        the data. It's important to manage the encryption keys securely, as the security
        of the encrypted data depends on the security of the key.
      text: |-
        defmodule MyApp do
          def encode(data) do
            # Here is an example key, but for real-world applications, you should use a secure way to store and access keys
            key = :crypto.strong_rand_bytes(32)
            iv = :crypto.strong_rand_bytes(16)
            {:ok, encrypted_data} = :crypto.block_encrypt(:aes_gcm, key, iv, to_string(data))
            encrypted_data
          end
        end
    steps:
    - Use a secure encryption method such as AES (Advanced Encryption Standard).
    - Use secure random keys for each encryption process.
    - Use a secure method to store and manage encryption keys.
  title: Non-encrypted confidential information - Hexadecimal
  vulnerability_id: '378'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Plug for building web applications in Elixir
  need: To securely generate OTP and protect it from interception by attackers
  solution:
    considerations:
    - Consider using two-factor authentication (2FA) for additional security.
    - Keep the lifetime of the OTP as short as feasible for your application.
    - Ensure communication between the client and the server is secured, e.g., using
      HTTPS.
    insecure_code_example:
      description: In this insecure code example, the OTP is generated on the client
        side, which means that it can be intercepted before it even reaches the server.
        If the OTP is intercepted, an attacker can continue the application flow without
        having access to the phone number.
      text: |-
        defmodule MyApp.ClientSideOTP do
          def generate_otp do
            otp = :rand.uniform(100000..999999)
            MyApp.Server.validate_otp(otp)
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, the OTP is generated and stored on
        the server side. When validating the OTP, it's compared directly with the
        OTP stored in the server-side session, which prevents interception and unauthorized
        application flow continuation.
      text: |-
        defmodule MyApp.ServerSideOTP do
          def generate_otp do
            otp = :rand.uniform(100000..999999)
            Plug.Conn.put_session(conn, :otp, otp)
          end

          def validate_otp(conn, input_otp) do
            session_otp = Plug.Conn.get_session(conn, :otp)
            input_otp == session_otp
          end
        end
    steps:
    - Generate the OTP on the server side, not on the client side.
    - Once generated, immediately store the OTP in a secure server-side session.
    - Validate the OTP directly from this secure server-side session.
  title: Insecurely generated token - OTP
  vulnerability_id: '383'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Elixir's LDAP library for LDAP integration
  need: Secure communication with LDAP server
  solution:
    considerations:
    - Always keep your SSL certificates up to date.
    - Regularly monitor the LDAP server for any suspicious activity.
    insecure_code_example:
      description: In this insecure code example, we're connecting to an LDAP server
        without any encryption. The password is sent in plaintext over the network.
        An attacker who can listen to the network traffic can intercept the password.
      text: |-
        defmodule MyApp.Insecure do
          @username 'username'
          @password 'password'
          def authenticate do
            :eldap.open(['ldap://example.com'])
            |> :eldap.simple_bind({@username, @password})
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, we're connecting to the LDAP server
        over SSL. The network traffic, including the password, is encrypted. This
        prevents attackers from intercepting the password.
      text: |-
        defmodule MyApp.Secure do
          @username 'username'
          @password 'password'
          def authenticate do
            :eldap.open(['ldaps://example.com'])
            |> :eldap.simple_bind({@username, @password})
          end
        end
    steps:
    - Use LDAP over SSL (LDAPS) to encrypt the network traffic.
    - Bind all blind authentication connections to a separate LDAP server.
    - When allowing connections from the internet, only allow blind authentication.
  title: Insecure authentication method - LDAP
  vulnerability_id: '397'
  last_update_time: 09/18/2023
- context:
  - Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications
  - Usage of Crypto package for cryptographic operations in Elixir
  need: Secure encryption
  solution:
    considerations:
    - Always use secure algorithms and keys when performing encryption.
    - Stay up-to-date with the latest security recommendations and standards.
    insecure_code_example:
      description: In this insecure code example, the :secp160r1 elliptic curve is
        used, which is considered weak and therefore insecure. The key generated using
        this curve is then used to encrypt the data using AES encryption. The weak
        key might make the encryption vulnerable to attacks.
      text: |-
        defmodule MyApp.Insecure do
          def encrypt_data(data) do
            private_key = :crypto.generate_key(:ecdh, :secp160r1)
            {:ok, cipher_text} = :crypto.private_encrypt(:ecdh, data, private_key, :aes_cbc128)
            cipher_text
          end
        end
    language: elixir
    secure_code_example:
      description: In this secure code example, the :secp384r1 elliptic curve is used,
        which is considered secure. The key generated using this curve is then used
        to encrypt the data using AES encryption. The secure key enhances the security
        of the encryption.
      text: |-
        defmodule MyApp.Secure do
          def encrypt_data(data) do
            private_key = :crypto.generate_key(:ecdh, :secp384r1)
            {:ok, cipher_text} = :crypto.private_encrypt(:ecdh, data, private_key, :aes_cbc128)
            cipher_text
          end
        end
    steps:
    - Use a secure elliptic curve when generating the key, such as :secp384r1.
    - Ensure that all the components of the encryption are secure, including the key,
      the algorithm, and the cipher mode.
  title: Insecure encryption algorithm - Insecure Elliptic Curve
  vulnerability_id: '421'
  last_update_time: 09/18/2023

- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of azurerm for managing resources in Azure
  need: Secure authentication method
  solution:
    insecure_code_example:
      description:
        "This code is vulnerable because it uses Basic authentication method,\
        \ which is insecure. Here, the Terraform provider for Azure (azurerm) is configured\
        \ using static values for `subscription_id`, `client_id`, `client_secret`,\
        \ and `tenant_id`. \n\nThese values are sensitive and should not be hardcoded\
        \ into the Terraform configuration file. If this file is committed to a public\
        \ repository, these secrets will be exposed to anyone who can access the repository,\
        \ leading to potential unauthorized access to the Azure resources.\n\nMoreover,\
        \ the communication channel is insecure which makes it vulnerable to Man-in-the-Middle\
        \ (MitM) attacks. In such attacks, an attacker intercepts the communication,\
        \ gaining access to the sensitive information.\n\n# Solution\nYou should use\
        \ a secure authentication method and secure communication channel. You can\
        \ store these secrets in Azure Key Vault and retrieve them in your Terraform\
        \ configuration. \n\n```hcl\ndata \"azurerm_key_vault_secret\" \"client_id\"\
        \ {\n  name         = \"client-id\"\n  key_vault_id = data.azurerm_key_vault.main.id\n\
        }\n\ndata \"azurerm_key_vault_secret\" \"client_secret\" {\n  name       \
        \  = \"client-secret\"\n  key_vault_id = data.azurerm_key_vault.main.id\n\
        }\n\nprovider \"azurerm\" {\n  features {}\n  subscription_id = \"your_subscription_id\"\
        \n  client_id       = data.azurerm_key_vault_secret.client_id.value\n  client_secret\
        \   = data.azurerm_key_vault_secret.client_secret.value\n  tenant_id     \
        \  = \"your_tenant_id\"\n}\n```\nIn this solution, `client_id` and `client_secret`\
        \ are stored in Azure Key Vault and retrieved dynamically in the Terraform\
        \ configuration. This way, the sensitive data is not exposed in the configuration\
        \ file."
      text: |-
        provider "azurerm" {
          features {}
          subscription_id = "your_subscription_id"
          client_id       = "your_client_id"
          client_secret   = "your_client_secret"
          tenant_id       = "your_tenant_id"
        }
    language: azure
    secure_code_example:
      description: |-
        The updated code removes the 'client_id', 'client_secret', and 'tenant_id' values from the provider block. Instead, it uses the 'azurerm_client_config' data source to automatically fetch the 'client_id' and 'tenant_id' from the Azure provider's configuration.

        The 'client_secret' is stored securely in an Azure Key Vault and retrieved using the 'azurerm_key_vault_secret' data source. This ensures that the 'client_secret' is not exposed in the Terraform code, providing a more secure authentication method.

        This approach adheres to best practices for managing sensitive data in Terraform and helps to prevent potential security vulnerabilities associated with insecure authentication methods.
      text: |-
        provider "azurerm" {
          features {}
          subscription_id = "your_subscription_id"
        }

        data "azurerm_client_config" "current" {}

        data "azuread_service_principal" "example" {
          application_id = data.azurerm_client_config.current.client_id
        }

        data "azurerm_key_vault_secret" "example" {
          name         = "client-secret"
          key_vault_id = data.azurerm_key_vault.example.id
        }
    steps:
      - 1. Remove the 'client_id', 'client_secret', and 'tenant_id' values from the
        code.
      - 2. Implement a more secure authentication mechanism like Bearer or OAuth.
      - 3. Store the sensitive authentication information securely, such as in Azure
        Key Vault.
      - 4. Update the code to retrieve the authentication information from the secure
        storage instead of hardcoding it.
  title: Insecure authentication method - Basic
  vulnerability_id: "015"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of Azure Resource Manager (azurerm) for managing Azure resources
  need: Protection against accidental deletion of critical objects
  solution:
    insecure_code_example:
      description: |-
        This Terraform configuration file creates an Azure resource group named "example-resources" in the "West Europe" region. However, there is a significant vulnerability in this configuration: there is no protection against accidental deletion of the resource group.

        In Terraform, the `prevent_destroy` lifecycle configuration block can be used to protect resources from being destroyed. If this block is not included in the configuration for a resource, anyone with access to the Terraform configuration and the necessary permissions in Azure can accidentally or intentionally delete the resource by running `terraform destroy` or `terraform apply` after removing the resource from the configuration.

        This lack of protection against deletion is a serious vulnerability, especially for critical resources that should not be deleted. If such a resource is deleted, it could lead to data loss, service disruption, and other negative impacts.

        To fix this vulnerability, the `prevent_destroy` lifecycle configuration block should be added to the configuration for the resource. This will cause Terraform to reject any plans that include destroying the resource, thus protecting it from accidental deletion.
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }
    language: azure
    secure_code_example:
      description:
        "The code above is a Terraform script for Azure Resource Manager\
        \ (azurerm) provider. It creates a resource group named \"example-resources\"\
        \ in the \"West Europe\" location. \n\nTo protect the resource group from\
        \ accidental deletion, a management lock is added. The `azurerm_management_lock`\
        \ resource creates a lock on the resource group. The `lock_level` is set to\
        \ \"CanNotDelete\", which means the resource group cannot be deleted when\
        \ the lock is in place. The `notes` field is used to provide a description\
        \ of the lock.\n\nPlease note that this lock will prevent all users from deleting\
        \ the resource group, regardless of their permissions. The lock can only be\
        \ removed by users with sufficient permissions.\n\nIn addition to this, it\
        \ is recommended to implement a backup strategy for the resources in the resource\
        \ group and regularly test the backup and restore process to ensure its effectiveness.\
        \ This will provide an additional layer of protection against data loss."
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_management_lock" "example" {
          name       = "example-lock"
          scope      = azurerm_resource_group.example.id
          lock_level = "CanNotDelete"
          notes      = "This lock prevents accidental deletion of the resource group"
        }
    steps:
      - Enable resource lock on the resource group to prevent accidental deletion
      - Implement a backup strategy for the resources in the resource group
      - Regularly test the backup and restore process to ensure its effectiveness
  title: Lack of protection against deletion
  vulnerability_id: "101"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of azurerm for managing resources in Microsoft Azure
    - Usage of the "var" keyword for declaring variables in JavaScript
  need:
    Implementation of safeguards for accidental or malicious deletion of secrets
    in Azure Key Vault
  solution:
    insecure_code_example:
      description:
        "This Terraform code creates an instance of Azure Key Vault with\
        \ the name 'examplekeyvault' in the 'westus' location and within the resource\
        \ group specified. \n\nHowever, the code is vulnerable due to the lack of\
        \ protection against deletion. This is indicated by the following two properties:\n\
        \n1. `soft_delete_retention_days = 0`: This property is used to keep the deleted\
        \ vaults for a specified number of days. Setting this value to 0 means that\
        \ the vaults will not be retained after deletion.\n\n2. `purge_protection_enabled\
        \ = false`: This property is used to prevent vaults from being permanently\
        \ deleted. When this property is set to false, it means that the vaults can\
        \ be permanently deleted.\n\nThe lack of these protections means that in the\
        \ event of accidental deletion or malicious actions, the secrets stored in\
        \ the vault cannot be recovered, leading to potential data loss and security\
        \ risks."
      text: |-
        resource "azurerm_key_vault" "example" {
          name                        = "examplekeyvault"
          location                    = "westus"
          resource_group_name         = azurerm_resource_group.example.name
          tenant_id                   = var.tenant_id
          sku_name                    = "standard"
          soft_delete_retention_days  = 0
          purge_protection_enabled    = false
        }
    language: azure
    secure_code_example:
      description: |-
        The updated code now includes two important properties: `soft_delete_retention_days` and `purge_protection_enabled`.

        The `soft_delete_retention_days` property is set to 7. This means that when a key vault or any of its contents are deleted, they are retained for 7 days. During this period, the deleted object can be recovered. This is a crucial feature to prevent accidental deletion of secrets, keys, or certificates.

        The `purge_protection_enabled` property is set to true. This means that once an object is deleted, it cannot be permanently purged until the retention period has passed. Even if an attacker gains access to the key vault, they cannot permanently delete its contents. This provides an additional layer of protection against malicious actions.

        By enabling these properties, we can ensure that the Azure Key Vault instance is protected against accidental deletion and malicious actions.
      text: |-
        resource "azurerm_key_vault" "example" {
          name                        = "examplekeyvault"
          location                    = "westus"
          resource_group_name         = azurerm_resource_group.example.name
          tenant_id                   = var.tenant_id
          sku_name                    = "standard"
          soft_delete_retention_days  = 7
          purge_protection_enabled    = true
        }
    steps:
      - Enable the properties EnableSoftDelete and EnablePurgeProtection in the Azure
        Key Vault instance.
      - Set the value of soft_delete_retention_days to a non-zero value to enable soft
        delete for the Key Vault.
      - Set the value of purge_protection_enabled to true to enable purge protection
        for the Key Vault.
  title: Lack of protection against deletion - Azure Key Vault
  vulnerability_id: "412"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of azurerm for managing Azure resources and services
  need: Implementation of secure encryption algorithms for SSL/TLS communication
  solution:
    insecure_code_example:
      description:
        "The above Terraform code is used to create an Azure App Service.\
        \ The vulnerability lies in the `site_config` block where the `min_tls_version`\
        \ is set to \"1.0\". \n\nTLS 1.0 is known to be insecure due to various known\
        \ attacks (like POODLE and BEAST), and it is recommended to use a more secure\
        \ version of the protocol. Using an insecure version of TLS can expose sensitive\
        \ data to attackers and also make the system susceptible to man-in-the-middle\
        \ attacks.\n\nIn this case, any data transmitted between the Azure App Service\
        \ and clients could potentially be intercepted and read by an attacker. This\
        \ is particularly concerning if the App Service is used to transmit sensitive\
        \ data, such as personally identifiable information (PII), credit card numbers,\
        \ or other confidential business data."
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_app_service" "example" {
          name                = "example-app-service"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name

          site_config {
            dotnet_framework_version = "v4.0"
            scm_type                 = "LocalGit"
            min_tls_version          = "1.0"
          }
        }
    language: azure
    secure_code_example:
      description: |-
        The original code was vulnerable due to the use of an insecure TLS protocol version (1.0). This version of the protocol is known to have several security issues and is not recommended for use.

        The updated code fixes this vulnerability by changing the minimum TLS version to 1.2 in the `azurerm_app_service` resource. This is done by modifying the `min_tls_version` property in the `site_config` block. The value "1.0" was replaced with "1.2", which is a secure version of the protocol.

        After making these changes, save the Terraform configuration file and apply it to update the infrastructure. This will ensure that the app service only uses secure versions of the TLS protocol, mitigating the risk of attacks that exploit vulnerabilities in older versions.
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_app_service" "example" {
          name                = "example-app-service"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name

          site_config {
            dotnet_framework_version = "v4.0"
            scm_type                 = "LocalGit"
            min_tls_version          = "1.2" // Updated from "1.0" to "1.2"
          }
        }
    steps:
      - Update the TLS protocol version to TLSv1.2 or TLSv1.3
      - Modify the 'min_tls_version' property in the 'site_config' block of the 'azurerm_app_service'
        resource
      - Remove or comment out the line 'min_tls_version = "1.0"'
      - Save the changes and apply the Terraform configuration
  title: Insecure encryption algorithm - SSL/TLS
  vulnerability_id: "016"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of AzureRM for managing Azure resources
  need: Enforce expiration dates for secrets stored in Azure Key Vault
  solution:
    insecure_code_example:
      description:
        "The above Terraform code is used to create a resource group, key\
        \ vault and a secret in Azure. The vulnerability lies in the `azurerm_key_vault_secret`\
        \ block where a secret is created without an expiration date. \n\nIn this\
        \ block:\n\n```hcl\nresource \"azurerm_key_vault_secret\" \"example\" {\n\
        \  name         = \"secret-sauce\"\n  value        = \"szechuan\"\n  key_vault_id\
        \ = azurerm_key_vault.example.id\n}\n```\n\nThe secret `secret-sauce` is being\
        \ stored in the key vault `examplevault` without an expiration date. This\
        \ is a security risk because if the secret is compromised, it can be used\
        \ indefinitely by an attacker. \n\nThe best practice is to always set an expiration\
        \ date for secrets to limit the time window in which a compromised secret\
        \ can be used."
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_key_vault" "example" {
          name                = "examplevault"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name
          tenant_id           = var.tenant_id
          sku_name            = "standard"
        }

        resource "azurerm_key_vault_secret" "example" {
          name         = "secret-sauce"
          value        = "szechuan"
          key_vault_id = azurerm_key_vault.example.id
        }
    language: azure
    secure_code_example:
      description:
        "The updated code includes an `expiration_date` property for the\
        \ `azurerm_key_vault_secret` resource. This property is set to a specific\
        \ date and time in the future, which represents when the secret will expire.\
        \ \n\nThe `expiration_date` is set in the format \"YYYY-MM-DDTHH:MM:SSZ\"\
        , which is the ISO 8601 format. In this example, the secret will expire on\
        \ April 1, 2023, at 01:02:03 UTC.\n\nBy setting an expiration date for the\
        \ secret, we ensure that the secret cannot be used indefinitely, reducing\
        \ the potential impact of a compromised secret. After the secret has expired,\
        \ it will need to be renewed before it can be used again, providing an opportunity\
        \ to review and potentially update the secret.\n\nAfter updating the Terraform\
        \ configuration with the `expiration_date` property, you will need to deploy\
        \ the configuration to apply the changes. This can be done using the `terraform\
        \ apply` command."
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_key_vault" "example" {
          name                = "examplevault"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name
          tenant_id           = var.tenant_id
          sku_name            = "standard"
        }

        resource "azurerm_key_vault_secret" "example" {
          name            = "secret-sauce"
          value           = "szechuan"
          key_vault_id    = azurerm_key_vault.example.id
          expiration_date = "2023-04-01T01:02:03Z" // Set the expiration date for the secret
        }
    steps:
      - 1. Set the `expiration_date` property for the Azure Key Vault secret.
      - 2. Determine an appropriate expiration date for the secret.
      - 3. Update the `azurerm_key_vault_secret` resource block to include the `expiration_date`
        property.
      - 4. Deploy the updated Terraform configuration to apply the changes.
  title: Insecure service configuration - AKV Secret Expiration
  vulnerability_id: "401"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of azurerm for managing resources in Microsoft Azure
    - Usage of Azure AD for authentication and authorization in Node.js applications
  need:
    Restrict access to Azure Active Directory Graph API services to authorized
    network segments
  solution:
    insecure_code_example:
      description: |-
        This Terraform script creates an Azure Active Directory application and a service principal associated with it. The service principal is granted a password, which is hardcoded as "example_password".

        The main vulnerability here lies in the unrestricted access to the Azure AD Graph API services. The service can be accessed from anywhere on the Internet, and the URL of the service and the credentials are found in the application code.

        This is a serious security concern because anyone who gains access to this code can potentially access and manipulate the Azure AD Graph API services. The hardcoded credentials (in this case, the service principal password) make the system even more vulnerable to unauthorized access and potential data breaches.

        Moreover, the `available_to_other_tenants` attribute is set to `false`, which means the application is available to users in any Azure AD tenant, not just the one where it's registered. This could potentially allow unauthorized users to access the application.

        Finally, the `oauth2_allow_implicit_flow` attribute is set to `true`, which enables the OAuth 2.0 implicit grant flow. This flow allows the application to obtain an access token directly from the Azure AD authorization endpoint, without needing to authenticate first. This could potentially allow an attacker to impersonate a legitimate user and gain unauthorized access to the application.
      text: |-
        provider "azurerm" {
          features {}
        }

        data "azurerm_client_config" "current" {}

        resource "azuread_application" "example" {
          name                       = "example-app"
          homepage                   = "https://homepage"
          identifier_uris            = ["https://uri"]
          reply_urls                 = ["https://replyurl"]
          available_to_other_tenants = false
          oauth2_allow_implicit_flow = true
        }

        resource "azuread_service_principal" "example" {
          application_id = azuread_application.example.application_id
        }

        resource "azuread_service_principal_password" "example" {
          service_principal_id = azuread_service_principal.example.id
          value                = "example_password"
          end_date             = "2020-01-01T01:02:03Z"
        }
    language: azure
    secure_code_example:
      description: |-
        The updated code removes the 'oauth2_allow_implicit_flow' attribute from the 'azuread_application' resource. This attribute was allowing the application to use the OAuth 2.0 implicit flow, which is less secure and has been deprecated.

        The 'azuread_service_principal_password' resource now references a variable for the password value instead of hardcoding it. This is a more secure practice as it prevents sensitive information from being exposed in the code. The actual password can be provided as a variable when running Terraform.

        Please note that this code update alone is not enough to fully address the vulnerability. Additional steps need to be taken outside of the code:

        1. Configure Conditional Access policies in Azure Active Directory to restrict access to the Azure AD Graph API services. This can be done in the Azure portal.

        2. Establish trusted locations for accessing the Azure AD Graph API services. This can be done by following the Azure documentation.

        3. Regularly review and update the access control configurations for the Azure AD Graph API services to ensure they are still appropriate and secure.
      text: |-
        provider "azurerm" {
          features {}
        }

        data "azurerm_client_config" "current" {}

        resource "azuread_application" "example" {
          name                       = "example-app"
          homepage                   = "https://homepage"
          identifier_uris            = ["https://uri"]
          reply_urls                 = ["https://replyurl"]
          available_to_other_tenants = false
        }

        resource "azuread_service_principal" "example" {
          application_id = azuread_application.example.application_id
        }

        resource "azuread_service_principal_password" "example" {
          service_principal_id = azuread_service_principal.example.id
          value                = var.service_principal_password
          end_date             = "2020-01-01T01:02:03Z"
        }
    steps:
      - 1. Remove the 'oauth2_allow_implicit_flow' attribute from the 'azuread_application'
        resource.
      - 2. Configure Conditional Access policies in Azure Active Directory to restrict
        access to the Azure AD Graph API services.
      - 3. Follow Azure documentation to establish trusted locations for accessing the
        Azure AD Graph API services.
      - 4. Avoid hardcoding sensitive information, such as credentials, in the application
        code.
      - 5. Regularly review and update the access control configurations for the Azure
        AD Graph API services.
  title: Unrestricted access between network segments - Azure AD
  vulnerability_id: "158"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of Azure Resource Manager (azurerm) for managing Azure resources
  need: Improved traceability and logging in Azure configurations
  solution:
    insecure_code_example:
      description:
        "The above code block sets up an Azure Log Analytics Workspace\
        \ with a basic configuration. It defines the location and name of the workspace,\
        \ sets the SKU to \"PerGB2018\", and configures the retention period to 30\
        \ days.\n\nHowever, this configuration does not include detailed logging,\
        \ which is essential for tracking and understanding activities within the\
        \ workspace. This omission can lead to loss of traceability, making it difficult\
        \ to detect anomalous behaviors or security breaches.\n\nThe vulnerability\
        \ lies in the lack of detailed logging settings. As a result, potentially\
        \ malicious activities might not be recorded, making it impossible to track\
        \ them down. This lack of traceability can hinder the detection of security\
        \ breaches and make incident response more challenging. \n\nTo fix this vulnerability,\
        \ it is recommended to enable detailed logging in the Azure Log Analytics\
        \ Workspace configuration. This can be done by enabling the 'diagnostic_settings'\
        \ block in the 'azurerm_log_analytics_workspace' resource. Detailed logging\
        \ should include all relevant data categories and logs should be retained\
        \ for a sufficient amount of time to allow for effective incident detection\
        \ and response."
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_log_analytics_workspace" "example" {
          name                = "example-workspace"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name
          sku                 = "PerGB2018"
          retention_in_days   = 30
        }
    language: azure
    secure_code_example:
      description:
        "The updated code includes the `azurerm_monitor_diagnostic_setting`\
        \ resource which is used to enable diagnostic settings for the Azure resource\
        \ group. The diagnostic settings include logs and metrics with a retention\
        \ policy of 365 days. \n\nThe `log` block is configured to capture \"Action\"\
        \ category logs. This category includes logs related to operations that modify\
        \ the resource group. The `metric` block is configured to capture all metrics\
        \ related to the resource group. Both the logs and metrics are enabled and\
        \ have a retention policy of 365 days.\n\nThe logs and metrics are sent to\
        \ the log analytics workspace specified by the `log_analytics_workspace_id`\
        \ property. This ensures that all logs and metrics are centrally stored and\
        \ can be analyzed for any anomalous behaviors or security breaches.\n\nThe\
        \ `retention_in_days` property of the `azurerm_log_analytics_workspace` resource\
        \ is also updated to 365 days to ensure that logs are retained for a sufficient\
        \ period of time for analysis."
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_log_analytics_workspace" "example" {
          name                = "example-workspace"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name
          sku                 = "PerGB2018"
          retention_in_days   = 365
        }

        resource "azurerm_monitor_diagnostic_setting" "example" {
          name                       = "example-setting"
          target_resource_id         = azurerm_resource_group.example.id
          log_analytics_workspace_id = azurerm_log_analytics_workspace.example.id

          log {
            category = "Action"
            enabled  = true

            retention_policy {
              enabled = true
              days    = 365
            }
          }

          metric {
            category = "AllMetrics"
            enabled  = true

            retention_policy {
              enabled = true
              days    = 365
            }
          }
        }
    steps:
      - Enable diagnostic settings for the relevant Azure resources
      - Configure the diagnostic settings to include the necessary log categories
      - Specify the desired retention period for the logs
      - Ensure that the logs are sent to a log analytics workspace
      - Regularly review and analyze the logs for any anomalous behaviors or security
        breaches
  title: Traceability Loss - Azure
  vulnerability_id: "402"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of AzureRM for managing Azure resources programmatically
  need: Protection of customer data and prevention of unauthorized access
  solution:
    insecure_code_example:
      description: |-
        The above Terraform code creates an Azure resource group and a storage account within that group. The issue lies in the `allow_blob_public_access` attribute of the `azurerm_storage_account` resource. This attribute is set to `true`, which means that the blobs within this storage account are accessible to the public.

        The `allow_blob_public_access` attribute controls whether or not public read access is allowed for the blobs in this storage account. If this is set to `true`, then anyone with the URL of the blob can access it.

        This is a serious vulnerability because it could potentially allow unauthorized users to access sensitive business information stored in the blobs. This is especially dangerous if the storage account contains information from multiple customers, as the access would not be limited to a single customer's data.

        This vulnerability could be exploited by malicious users who are aware of the public access setting and have the blob URLs. They could access the blobs, read the data, and potentially use it for malicious purposes.
      text:
        "provider \"azurerm\" {\n  version = \"=2.40.0\"\n  features {}\n}\n\n\
        resource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\
        \n  location = \"West Europe\"\n}\n\nresource \"azurerm_storage_account\"\
        \ \"example\" {\n  name                     = \"examplestoracc\"\n  resource_group_name\
        \      = azurerm_resource_group.example.name\n  location                 =\
        \ azurerm_resource_group.example.location\n  account_tier             = \"\
        Standard\"\n  account_replication_type = \"GRS\"\n  \n  allow_blob_public_access\
        \ = true\n}"
    language: azure
    secure_code_example:
      description: |-
        The updated code includes several changes to address the vulnerability:

        1. `allow_blob_public_access` is set to `false` to disable public access to the storage account. This ensures that the data stored in the account is not accessible to the public.

        2. A `network_rules` block is added to the `azurerm_storage_account` resource. This block includes a `default_action` of "Deny", which means that all requests are denied by default. Only the requests that match the rules specified in the `ip_rules` and `virtual_network_subnet_ids` are allowed. This is a form of access control that restricts user access to sensitive data.

        3. A `azurerm_virtual_network` and `azurerm_subnet` resources are created. The `virtual_network_subnet_ids` in the `network_rules` block includes the ID of this subnet. This means that only the requests from this subnet are allowed.

        Please note that this is a basic example and you might need to adjust the `ip_rules` and `virtual_network_subnet_ids` according to your needs. Also, remember to regularly rotate privileged credentials and implement strong authentication mechanisms for user login to further enhance the security.
      text:
        "provider \"azurerm\" {\n  version = \"=2.40.0\"\n  features {}\n}\n\n\
        resource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\
        \n  location = \"West Europe\"\n}\n\nresource \"azurerm_storage_account\"\
        \ \"example\" {\n  name                     = \"examplestoracc\"\n  resource_group_name\
        \      = azurerm_resource_group.example.name\n  location                 =\
        \ azurerm_resource_group.example.location\n  account_tier             = \"\
        Standard\"\n  account_replication_type = \"GRS\"\n  \n  allow_blob_public_access\
        \ = false\n\n  network_rules {\n    default_action             = \"Deny\"\n\
        \    virtual_network_subnet_ids = [azurerm_subnet.example.id]\n    ip_rules\
        \                   = [\"100.0.0.1\"]\n  }\n}\n\nresource \"azurerm_virtual_network\"\
        \ \"example\" {\n  name                = \"example-network\"\n  resource_group_name\
        \ = azurerm_resource_group.example.name\n  location            = azurerm_resource_group.example.location\n\
        \  address_space       = [\"10.0.0.0/16\"]\n}\n\nresource \"azurerm_subnet\"\
        \ \"example\" {\n  name                 = \"example-subnet\"\n  resource_group_name\
        \  = azurerm_resource_group.example.name\n  virtual_network_name = azurerm_virtual_network.example.name\n\
        \  address_prefix       = \"10.0.1.0/24\"\n}"
    steps:
      - Disable public access to the storage account
      - Implement access controls to restrict user access to sensitive data
      - Regularly rotate privileged credentials
      - Implement strong authentication mechanisms for user login
  title: Business information leak - Azure
  vulnerability_id: "225"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of Azure Resource Manager (azurerm) for managing Azure resources
  need: Implementation of robust and secure authentication mechanisms in Azure
  solution:
    insecure_code_example:
      description: |-
        The above Terraform code is used to spin up a virtual machine in Azure. It specifies the provider as Azure and sets the version. It then creates a resource of type `azurerm_virtual_machine` which represents a virtual machine in Azure.

        The vulnerability lies in the `os_profile` block of the code. The `admin_username` and `admin_password` are hardcoded into the Terraform script. This is a significant security risk as anyone with access to this script would have the username and password for the administrative account on the virtual machine.

        Additionally, the password is weak and easily guessable which makes it even more insecure. This could allow an attacker to gain unauthorized access to the virtual machine.

        Furthermore, the absence of an authentication mechanism for the provider block is another vulnerability. There's no mention of any service principal or client secret being used to authenticate to Azure. This means that the Terraform script is likely using the Azure CLI's logged in session, which is not a secure practice.

        This code is vulnerable to Authentication mechanism absence or evasion.
      text:
        "provider \"azurerm\" {\n  version = \"=2.40.0\"\n}\n\nresource \"azurerm_virtual_machine\"\
        \ \"vm\" {\n  name                  = \"myvm\"\n  location              =\
        \ \"West Europe\"\n  resource_group_name   = \"my-resource-group\"\n  network_interface_id\
        \  = \"my-network-interface-id\"\n  vm_size               = \"Standard_D2s_v3\"\
        \n  \n  delete_os_disk_on_termination = true\n  delete_data_disks_on_termination\
        \ = true\n\n  os_profile {\n    computer_name  = \"hostname\"\n    admin_username\
        \ = \"admin\"\n    admin_password = \"password\"\n  }\n\n  os_profile_windows_config\
        \ {}\n}"
    language: azure
    secure_code_example:
      description: |-
        The updated code now uses Azure Key Vault to securely store the admin password. The `azurerm_key_vault_secret` resource is used to create a secret in the Key Vault, which holds the admin password. This password is then retrieved and used in the `azurerm_virtual_machine` resource.

        This approach avoids hardcoding sensitive information like passwords in the code, which is a security best practice. It also leverages Azure's built-in services for secrets management, which provide additional features like access control, auditing, and automatic rotation of secrets.

        Please note that this is just one part of a secure authentication mechanism. You should also consider using Azure Active Directory (AAD) for authentication and authorization, implementing multi-factor authentication (MFA), and regularly reviewing and updating your authentication mechanisms to address any new vulnerabilities or weaknesses.
      text:
        "provider \"azurerm\" {\n  version = \"=2.40.0\"\n  features {}\n}\n\n\
        data \"azurerm_client_config\" \"current\" {}\n\nresource \"azurerm_key_vault\"\
        \ \"example\" {\n  name                        = \"mykeyvault\"\n  location\
        \                    = \"West Europe\"\n  resource_group_name         = \"\
        my-resource-group\"\n  enabled_for_disk_encryption = true\n  tenant_id   \
        \                = data.azurerm_client_config.current.tenant_id\n  soft_delete_retention_days\
        \  = 7\n  purge_protection_enabled    = false\n}\n\nresource \"azurerm_key_vault_secret\"\
        \ \"example\" {\n  name         = \"adminpassword\"\n  value        = \"SecurePassword123!\"\
        \n  key_vault_id = azurerm_key_vault.example.id\n}\n\nresource \"azurerm_virtual_machine\"\
        \ \"vm\" {\n  name                  = \"myvm\"\n  location              =\
        \ \"West Europe\"\n  resource_group_name   = \"my-resource-group\"\n  network_interface_id\
        \  = \"my-network-interface-id\"\n  vm_size               = \"Standard_D2s_v3\"\
        \n  \n  delete_os_disk_on_termination = true\n  delete_data_disks_on_termination\
        \ = true\n\n  os_profile {\n    computer_name  = \"hostname\"\n    admin_username\
        \ = \"admin\"\n    admin_password = azurerm_key_vault_secret.example.value\n\
        \  }\n\n  os_profile_windows_config {}\n}"
    steps:
      - Use a more secure authentication mechanism instead of using a plain text password.
      - Consider using Azure Active Directory (AAD) for authentication and authorization.
      - Implement multi-factor authentication (MFA) to add an extra layer of security.
      - Avoid hardcoding sensitive information like passwords in the code.
      - Use secrets management tools to securely store and retrieve authentication credentials.
      - Regularly review and update authentication mechanisms to address any new vulnerabilities
        or weaknesses.
  title: Authentication mechanism absence or evasion - Azure
  vulnerability_id: "300"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform 0.12 for Infrastructure as Code (IaC)
    - Usage of AzureRM for managing Azure resources programmatically
  need: Secure communication channel for client information transmission
  solution:
    insecure_code_example:
      description: |-
        This Terraform script sets up an Azure virtual machine and starts an HTTP server on port 80 without using HTTPS. The `custom_data` field in the `azurerm_linux_virtual_machine` resource contains a bash script that starts a simple HTTP server using busybox. This server listens on port 80, which is the default port for HTTP.

        The use of HTTP means that any data sent to or from the server is not encrypted and could potentially be intercepted by malicious parties. This is a security risk, especially if sensitive data such as login credentials or personal information is being transmitted.

        In addition, the use of HTTP instead of HTTPS can lead to other security vulnerabilities. For example, it could make the server more susceptible to man-in-the-middle attacks, where an attacker intercepts the communication between the client and the server.

        To fix this vulnerability, the server should be configured to use HTTPS instead of HTTP. This would involve setting up an SSL/TLS certificate for the server and modifying the server configuration to use HTTPS.
      text: |
        provider "azurerm" {
          version = "=2.40.0"
          features {}
        }

        resource "azurerm_virtual_network" "main" {
          name                = "acctvn"
          address_space       = ["10.0.0.0/16"]
          location            = "West US 2"
          resource_group_name = "my-resource-group"
        }

        resource "azurerm_subnet" "internal" {
          name                 = "internal"
          resource_group_name  = "my-resource-group"
          virtual_network_name = azurerm_virtual_network.main.name
          address_prefixes     = ["10.0.2.0/24"]
        }

        resource "azurerm_network_interface" "main" {
          name                = "acctni"
          location            = "West US 2"
          resource_group_name = "my-resource-group"

          ip_configuration {
            name                          = "testconfiguration1"
            subnet_id                     = azurerm_subnet.internal.id
            private_ip_address_allocation = "Dynamic"
          }
        }

        resource "azurerm_linux_virtual_machine" "main" {
          name                = "acctvm"
          resource_group_name = "my-resource-group"
          location            = "West US 2"
          size                = "Standard_F2"
          admin_username      = "adminuser"
          network_interface_id = azurerm_network_interface.main.id

          os_disk {
            caching              = "ReadWrite"
            storage_account_type = "Standard_LRS"
          }

          source_image_reference {
            publisher = "Canonical"
            offer     = "UbuntuServer"
            sku       = "16.04-LTS"
            version   = "latest"
          }

          admin_ssh_key {
            username   = "adminuser"
            public_key = file("~/.ssh/id_rsa.pub")
          }

          custom_data = <<-EOF
                          #!/bin/bash
                          echo "Hello, World!" > index.html
                          nohup busybox httpd -f -p 80 &
                        EOF
        }
    language: azure
    secure_code_example:
      description:
        "The above code is a fixed version of the original Terraform script.\
        \ The main change is in the `custom_data` field of the `azurerm_linux_virtual_machine`\
        \ resource. \n\nIn the original script, a simple HTTP server was started using\
        \ busybox. This server was insecure as it was transmitting data over HTTP,\
        \ which is not encrypted.\n\nIn the fixed script, we are installing and configuring\
        \ Nginx, a popular web server. We are also generating a self-signed SSL certificate\
        \ and configuring Nginx to use this certificate for HTTPS. \n\nThe Nginx configuration\
        \ includes a server block that listens on port 80 (HTTP) and redirects all\
        \ traffic to HTTPS. This ensures that even if a client tries to connect using\
        \ HTTP, they will be redirected to the secure HTTPS endpoint.\n\nPlease note\
        \ that in a production environment, you should use a certificate issued by\
        \ a trusted certificate authority instead of a self-signed certificate."
      text: |-
        provider "azurerm" {
          version = "=2.40.0"
          features {}
        }

        resource "azurerm_virtual_network" "main" {
          name                = "acctvn"
          address_space       = ["10.0.0.0/16"]
          location            = "West US 2"
          resource_group_name = "my-resource-group"
        }

        resource "azurerm_subnet" "internal" {
          name                 = "internal"
          resource_group_name  = "my-resource-group"
          virtual_network_name = azurerm_virtual_network.main.name
          address_prefixes     = ["10.0.2.0/24"]
        }

        resource "azurerm_network_interface" "main" {
          name                = "acctni"
          location            = "West US 2"
          resource_group_name = "my-resource-group"

          ip_configuration {
            name                          = "testconfiguration1"
            subnet_id                     = azurerm_subnet.internal.id
            private_ip_address_allocation = "Dynamic"
          }
        }

        resource "azurerm_linux_virtual_machine" "main" {
          name                = "acctvm"
          resource_group_name = "my-resource-group"
          location            = "West US 2"
          size                = "Standard_F2"
          admin_username      = "adminuser"
          network_interface_id = azurerm_network_interface.main.id

          os_disk {
            caching              = "ReadWrite"
            storage_account_type = "Standard_LRS"
          }

          source_image_reference {
            publisher = "Canonical"
            offer     = "UbuntuServer"
            sku       = "16.04-LTS"
            version   = "latest"
          }

          admin_ssh_key {
            username   = "adminuser"
            public_key = file("~/.ssh/id_rsa.pub")
          }

          custom_data = <<-EOF
                          #!/bin/bash
                          sudo apt-get update
                          sudo apt-get install -y nginx
                          sudo ufw allow 'Nginx Full'
                          sudo mkdir -p /etc/nginx/ssl
                          sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt -subj "/C=US/ST=Denial/L=Springfield/O=Dis/CN=www.example.com"
                          sudo sh -c 'echo "server {
                            listen 80 default_server;
                            listen [::]:80 default_server;
                            server_name _;
                            return 301 https://$host$request_uri;
                          }
                          server {
                            listen 443 ssl default_server;
                            listen [::]:443 ssl default_server;
                            ssl_certificate /etc/nginx/ssl/nginx.crt;
                            ssl_certificate_key /etc/nginx/ssl/nginx.key;
                            location / {
                              root /var/www/html;
                              index index.html index.htm index.nginx-debian.html;
                            }
                          }" > /etc/nginx/sites-available/default'
                          sudo systemctl restart nginx
                        EOF
        }
    steps:
      - Enable HTTPS for the application
      - Obtain an SSL/TLS certificate
      - Configure the web server to use HTTPS
      - Redirect HTTP traffic to HTTPS
      - Update the application code to use HTTPS endpoints
  title: Use of an insecure channel - HTTP
  vulnerability_id: "372"
  last_update_time: 09/18/2023
- context:
    - Usage of Terraform for Infrastructure as Code (IaC)
    - Usage of azurerm for managing resources in Azure
  need: Implementation of network segmentation and access controls
  solution:
    insecure_code_example:
      description: |-
        In the above code, a resource group is created, and within that resource group a virtual network is created with an address space of `10.0.0.0/16`. A subnet is also created within this virtual network with an address prefix of `10.0.2.0/24`. Finally, a network interface is created which is associated with the subnet.

        The vulnerability lies in the fact that there are no network security groups (NSGs) applied to the subnet or the network interface. NSGs contain security rules that allow or deny inbound or outbound traffic to resources connected to Azure Virtual Networks. Without these, there are no restrictions on the traffic that can flow between different resources within the virtual network, or between the virtual network and the internet. This means that an employee could potentially access database servers from the internet, which is a security risk.
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_virtual_network" "example" {
          name                = "example-network"
          address_space       = ["10.0.0.0/16"]
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name
        }

        resource "azurerm_subnet" "example" {
          name                 = "example-subnet"
          resource_group_name  = azurerm_resource_group.example.name
          virtual_network_name = azurerm_virtual_network.example.name
          address_prefix       = "10.0.2.0/24"
        }

        resource "azurerm_network_interface" "example" {
          name                = "example-nic"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name

          ip_configuration {
            name                          = "internal"
            subnet_id                     = azurerm_subnet.example.id
            private_ip_address_allocation = "Dynamic"
          }
        }
    language: azure
    secure_code_example:
      description: |-
        The updated code includes the creation of a Network Security Group (NSG) and a Network Security Rule. The NSG is associated with the subnet to enforce the security rule.

        The `azurerm_network_security_group` resource creates a new NSG named "example-nsg". This NSG is located in the same resource group and location as the other resources.

        The `azurerm_network_security_rule` resource creates a new security rule named "example-rule". This rule is configured to deny all inbound TCP traffic. The rule is associated with the "example-nsg" NSG.

        The `azurerm_subnet_network_security_group_association` resource associates the "example-nsg" NSG with the "example-subnet" subnet. This means that the security rule will be enforced for all resources in the subnet.

        The `azurerm_network_interface` resource is updated to use the "example-subnet" subnet, which is now associated with the NSG.

        This configuration ensures that all inbound TCP traffic to the subnet is denied by default, limiting access between network segments. This aligns with the principle of least privilege by only allowing necessary traffic.
      text: |-
        provider "azurerm" {
          features {}
        }

        resource "azurerm_resource_group" "example" {
          name     = "example-resources"
          location = "West Europe"
        }

        resource "azurerm_virtual_network" "example" {
          name                = "example-network"
          address_space       = ["10.0.0.0/16"]
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name
        }

        resource "azurerm_subnet" "example" {
          name                 = "example-subnet"
          resource_group_name  = azurerm_resource_group.example.name
          virtual_network_name = azurerm_virtual_network.example.name
          address_prefix       = "10.0.2.0/24"
        }

        resource "azurerm_network_security_group" "example" {
          name                = "example-nsg"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name
        }

        resource "azurerm_network_security_rule" "example" {
          name                        = "example-rule"
          priority                    = 100
          direction                   = "Inbound"
          access                      = "Deny"
          protocol                    = "Tcp"
          source_port_range           = "*"
          destination_port_range      = "*"
          source_address_prefix       = "*"
          destination_address_prefix  = "*"
          resource_group_name         = azurerm_resource_group.example.name
          network_security_group_name = azurerm_network_security_group.example.name
        }

        resource "azurerm_subnet_network_security_group_association" "example" {
          subnet_id                 = azurerm_subnet.example.id
          network_security_group_id = azurerm_network_security_group.example.id
        }

        resource "azurerm_network_interface" "example" {
          name                = "example-nic"
          location            = azurerm_resource_group.example.location
          resource_group_name = azurerm_resource_group.example.name

          ip_configuration {
            name                          = "internal"
            subnet_id                     = azurerm_subnet.example.id
            private_ip_address_allocation = "Dynamic"
          }
        }
    steps:
      - Implement network segmentation to restrict access between network segments
      - Identify the different network segments required for the application
      - Define access control policies to limit communication between network segments
      - Configure firewall rules or network security groups to enforce the access control
        policies
      - Regularly review and update the access control policies to ensure they align
        with the principle of least privilege
      - Monitor network traffic and logs to detect any unauthorized access attempts
  title: Unrestricted access between network segments
  vulnerability_id: "157"
  last_update_time: 09/18/2023

[
  {
    "vulnerability_id": "015",
    "title": "Insecure authentication method - Basic",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of azurerm for managing resources in Azure"
    ],
    "need": "Secure authentication method",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "This code is vulnerable because it uses Basic authentication method, which is insecure. Here, the Terraform provider for Azure (azurerm) is configured using static values for `subscription_id`, `client_id`, `client_secret`, and `tenant_id`. \n\nThese values are sensitive and should not be hardcoded into the Terraform configuration file. If this file is committed to a public repository, these secrets will be exposed to anyone who can access the repository, leading to potential unauthorized access to the Azure resources.\n\nMoreover, the communication channel is insecure which makes it vulnerable to Man-in-the-Middle (MitM) attacks. In such attacks, an attacker intercepts the communication, gaining access to the sensitive information.\n\n# Solution\nYou should use a secure authentication method and secure communication channel. You can store these secrets in Azure Key Vault and retrieve them in your Terraform configuration. \n\n```hcl\ndata \"azurerm_key_vault_secret\" \"client_id\" {\n  name         = \"client-id\"\n  key_vault_id = data.azurerm_key_vault.main.id\n}\n\ndata \"azurerm_key_vault_secret\" \"client_secret\" {\n  name         = \"client-secret\"\n  key_vault_id = data.azurerm_key_vault.main.id\n}\n\nprovider \"azurerm\" {\n  features {}\n  subscription_id = \"your_subscription_id\"\n  client_id       = data.azurerm_key_vault_secret.client_id.value\n  client_secret   = data.azurerm_key_vault_secret.client_secret.value\n  tenant_id       = \"your_tenant_id\"\n}\n```\nIn this solution, `client_id` and `client_secret` are stored in Azure Key Vault and retrieved dynamically in the Terraform configuration. This way, the sensitive data is not exposed in the configuration file.",
        "text": "provider \"azurerm\" {\n  features {}\n  subscription_id = \"your_subscription_id\"\n  client_id       = \"your_client_id\"\n  client_secret   = \"your_client_secret\"\n  tenant_id       = \"your_tenant_id\"\n}"
      },
      "secure_code_example": {
        "description": "The updated code removes the 'client_id', 'client_secret', and 'tenant_id' values from the provider block. Instead, it uses the 'azurerm_client_config' data source to automatically fetch the 'client_id' and 'tenant_id' from the Azure provider's configuration.\n\nThe 'client_secret' is stored securely in an Azure Key Vault and retrieved using the 'azurerm_key_vault_secret' data source. This ensures that the 'client_secret' is not exposed in the Terraform code, providing a more secure authentication method.\n\nThis approach adheres to best practices for managing sensitive data in Terraform and helps to prevent potential security vulnerabilities associated with insecure authentication methods.",
        "text": "provider \"azurerm\" {\n  features {}\n  subscription_id = \"your_subscription_id\"\n}\n\ndata \"azurerm_client_config\" \"current\" {}\n\ndata \"azuread_service_principal\" \"example\" {\n  application_id = data.azurerm_client_config.current.client_id\n}\n\ndata \"azurerm_key_vault_secret\" \"example\" {\n  name         = \"client-secret\"\n  key_vault_id = data.azurerm_key_vault.example.id\n}"
      },
      "steps": [
        "1. Remove the 'client_id', 'client_secret', and 'tenant_id' values from the code.",
        "2. Implement a more secure authentication mechanism like Bearer or OAuth.",
        "3. Store the sensitive authentication information securely, such as in Azure Key Vault.",
        "4. Update the code to retrieve the authentication information from the secure storage instead of hardcoding it."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "101",
    "title": "Lack of protection against deletion",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of Azure Resource Manager (azurerm) for managing Azure resources"
    ],
    "need": "Protection against accidental deletion of critical objects",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "This Terraform configuration file creates an Azure resource group named \"example-resources\" in the \"West Europe\" region. However, there is a significant vulnerability in this configuration: there is no protection against accidental deletion of the resource group.\n\nIn Terraform, the `prevent_destroy` lifecycle configuration block can be used to protect resources from being destroyed. If this block is not included in the configuration for a resource, anyone with access to the Terraform configuration and the necessary permissions in Azure can accidentally or intentionally delete the resource by running `terraform destroy` or `terraform apply` after removing the resource from the configuration.\n\nThis lack of protection against deletion is a serious vulnerability, especially for critical resources that should not be deleted. If such a resource is deleted, it could lead to data loss, service disruption, and other negative impacts.\n\nTo fix this vulnerability, the `prevent_destroy` lifecycle configuration block should be added to the configuration for the resource. This will cause Terraform to reject any plans that include destroying the resource, thus protecting it from accidental deletion.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}"
      },
      "secure_code_example": {
        "description": "The code above is a Terraform script for Azure Resource Manager (azurerm) provider. It creates a resource group named \"example-resources\" in the \"West Europe\" location. \n\nTo protect the resource group from accidental deletion, a management lock is added. The `azurerm_management_lock` resource creates a lock on the resource group. The `lock_level` is set to \"CanNotDelete\", which means the resource group cannot be deleted when the lock is in place. The `notes` field is used to provide a description of the lock.\n\nPlease note that this lock will prevent all users from deleting the resource group, regardless of their permissions. The lock can only be removed by users with sufficient permissions.\n\nIn addition to this, it is recommended to implement a backup strategy for the resources in the resource group and regularly test the backup and restore process to ensure its effectiveness. This will provide an additional layer of protection against data loss.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_management_lock\" \"example\" {\n  name       = \"example-lock\"\n  scope      = azurerm_resource_group.example.id\n  lock_level = \"CanNotDelete\"\n  notes      = \"This lock prevents accidental deletion of the resource group\"\n}"
      },
      "steps": [
        "Enable resource lock on the resource group to prevent accidental deletion",
        "Implement a backup strategy for the resources in the resource group",
        "Regularly test the backup and restore process to ensure its effectiveness"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "412",
    "title": "Lack of protection against deletion - Azure Key Vault",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of azurerm for managing resources in Microsoft Azure",
      "Usage of the \"var\" keyword for declaring variables in JavaScript"
    ],
    "need": "Implementation of safeguards for accidental or malicious deletion of secrets in Azure Key Vault",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "This Terraform code creates an instance of Azure Key Vault with the name 'examplekeyvault' in the 'westus' location and within the resource group specified. \n\nHowever, the code is vulnerable due to the lack of protection against deletion. This is indicated by the following two properties:\n\n1. `soft_delete_retention_days = 0`: This property is used to keep the deleted vaults for a specified number of days. Setting this value to 0 means that the vaults will not be retained after deletion.\n\n2. `purge_protection_enabled = false`: This property is used to prevent vaults from being permanently deleted. When this property is set to false, it means that the vaults can be permanently deleted.\n\nThe lack of these protections means that in the event of accidental deletion or malicious actions, the secrets stored in the vault cannot be recovered, leading to potential data loss and security risks.",
        "text": "resource \"azurerm_key_vault\" \"example\" {\n  name                        = \"examplekeyvault\"\n  location                    = \"westus\"\n  resource_group_name         = azurerm_resource_group.example.name\n  tenant_id                   = var.tenant_id\n  sku_name                    = \"standard\"\n  soft_delete_retention_days  = 0\n  purge_protection_enabled    = false\n}"
      },
      "secure_code_example": {
        "description": "The updated code now includes two important properties: `soft_delete_retention_days` and `purge_protection_enabled`.\n\nThe `soft_delete_retention_days` property is set to 7. This means that when a key vault or any of its contents are deleted, they are retained for 7 days. During this period, the deleted object can be recovered. This is a crucial feature to prevent accidental deletion of secrets, keys, or certificates.\n\nThe `purge_protection_enabled` property is set to true. This means that once an object is deleted, it cannot be permanently purged until the retention period has passed. Even if an attacker gains access to the key vault, they cannot permanently delete its contents. This provides an additional layer of protection against malicious actions.\n\nBy enabling these properties, we can ensure that the Azure Key Vault instance is protected against accidental deletion and malicious actions.",
        "text": "resource \"azurerm_key_vault\" \"example\" {\n  name                        = \"examplekeyvault\"\n  location                    = \"westus\"\n  resource_group_name         = azurerm_resource_group.example.name\n  tenant_id                   = var.tenant_id\n  sku_name                    = \"standard\"\n  soft_delete_retention_days  = 7\n  purge_protection_enabled    = true\n}"
      },
      "steps": [
        "Enable the properties EnableSoftDelete and EnablePurgeProtection in the Azure Key Vault instance.",
        "Set the value of soft_delete_retention_days to a non-zero value to enable soft delete for the Key Vault.",
        "Set the value of purge_protection_enabled to true to enable purge protection for the Key Vault."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "016",
    "title": "Insecure encryption algorithm - SSL/TLS",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of azurerm for managing Azure resources and services"
    ],
    "need": "Implementation of secure encryption algorithms for SSL/TLS communication",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "The above Terraform code is used to create an Azure App Service. The vulnerability lies in the `site_config` block where the `min_tls_version` is set to \"1.0\". \n\nTLS 1.0 is known to be insecure due to various known attacks (like POODLE and BEAST), and it is recommended to use a more secure version of the protocol. Using an insecure version of TLS can expose sensitive data to attackers and also make the system susceptible to man-in-the-middle attacks.\n\nIn this case, any data transmitted between the Azure App Service and clients could potentially be intercepted and read by an attacker. This is particularly concerning if the App Service is used to transmit sensitive data, such as personally identifiable information (PII), credit card numbers, or other confidential business data.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n\n  site_config {\n    dotnet_framework_version = \"v4.0\"\n    scm_type                 = \"LocalGit\"\n    min_tls_version          = \"1.0\"\n  }\n}"
      },
      "secure_code_example": {
        "description": "The original code was vulnerable due to the use of an insecure TLS protocol version (1.0). This version of the protocol is known to have several security issues and is not recommended for use.\n\nThe updated code fixes this vulnerability by changing the minimum TLS version to 1.2 in the `azurerm_app_service` resource. This is done by modifying the `min_tls_version` property in the `site_config` block. The value \"1.0\" was replaced with \"1.2\", which is a secure version of the protocol.\n\nAfter making these changes, save the Terraform configuration file and apply it to update the infrastructure. This will ensure that the app service only uses secure versions of the TLS protocol, mitigating the risk of attacks that exploit vulnerabilities in older versions.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_app_service\" \"example\" {\n  name                = \"example-app-service\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n\n  site_config {\n    dotnet_framework_version = \"v4.0\"\n    scm_type                 = \"LocalGit\"\n    min_tls_version          = \"1.2\" // Updated from \"1.0\" to \"1.2\"\n  }\n}"
      },
      "steps": [
        "Update the TLS protocol version to TLSv1.2 or TLSv1.3",
        "Modify the 'min_tls_version' property in the 'site_config' block of the 'azurerm_app_service' resource",
        "Remove or comment out the line 'min_tls_version = \"1.0\"'",
        "Save the changes and apply the Terraform configuration"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "401",
    "title": "Insecure service configuration - AKV Secret Expiration",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of AzureRM for managing Azure resources"
    ],
    "need": "Enforce expiration dates for secrets stored in Azure Key Vault",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "The above Terraform code is used to create a resource group, key vault and a secret in Azure. The vulnerability lies in the `azurerm_key_vault_secret` block where a secret is created without an expiration date. \n\nIn this block:\n\n```hcl\nresource \"azurerm_key_vault_secret\" \"example\" {\n  name         = \"secret-sauce\"\n  value        = \"szechuan\"\n  key_vault_id = azurerm_key_vault.example.id\n}\n```\n\nThe secret `secret-sauce` is being stored in the key vault `examplevault` without an expiration date. This is a security risk because if the secret is compromised, it can be used indefinitely by an attacker. \n\nThe best practice is to always set an expiration date for secrets to limit the time window in which a compromised secret can be used.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_key_vault\" \"example\" {\n  name                = \"examplevault\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  tenant_id           = var.tenant_id\n  sku_name            = \"standard\"\n}\n\nresource \"azurerm_key_vault_secret\" \"example\" {\n  name         = \"secret-sauce\"\n  value        = \"szechuan\"\n  key_vault_id = azurerm_key_vault.example.id\n}"
      },
      "secure_code_example": {
        "description": "The updated code includes an `expiration_date` property for the `azurerm_key_vault_secret` resource. This property is set to a specific date and time in the future, which represents when the secret will expire. \n\nThe `expiration_date` is set in the format \"YYYY-MM-DDTHH:MM:SSZ\", which is the ISO 8601 format. In this example, the secret will expire on April 1, 2023, at 01:02:03 UTC.\n\nBy setting an expiration date for the secret, we ensure that the secret cannot be used indefinitely, reducing the potential impact of a compromised secret. After the secret has expired, it will need to be renewed before it can be used again, providing an opportunity to review and potentially update the secret.\n\nAfter updating the Terraform configuration with the `expiration_date` property, you will need to deploy the configuration to apply the changes. This can be done using the `terraform apply` command.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_key_vault\" \"example\" {\n  name                = \"examplevault\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  tenant_id           = var.tenant_id\n  sku_name            = \"standard\"\n}\n\nresource \"azurerm_key_vault_secret\" \"example\" {\n  name            = \"secret-sauce\"\n  value           = \"szechuan\"\n  key_vault_id    = azurerm_key_vault.example.id\n  expiration_date = \"2023-04-01T01:02:03Z\" // Set the expiration date for the secret\n}"
      },
      "steps": [
        "1. Set the `expiration_date` property for the Azure Key Vault secret.",
        "2. Determine an appropriate expiration date for the secret.",
        "3. Update the `azurerm_key_vault_secret` resource block to include the `expiration_date` property.",
        "4. Deploy the updated Terraform configuration to apply the changes."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "158",
    "title": "Unrestricted access between network segments - Azure AD",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of azurerm for managing resources in Microsoft Azure",
      "Usage of Azure AD for authentication and authorization in Node.js applications"
    ],
    "need": "Restrict access to Azure Active Directory Graph API services to authorized network segments",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "This Terraform script creates an Azure Active Directory application and a service principal associated with it. The service principal is granted a password, which is hardcoded as \"example_password\".\n\nThe main vulnerability here lies in the unrestricted access to the Azure AD Graph API services. The service can be accessed from anywhere on the Internet, and the URL of the service and the credentials are found in the application code.\n\nThis is a serious security concern because anyone who gains access to this code can potentially access and manipulate the Azure AD Graph API services. The hardcoded credentials (in this case, the service principal password) make the system even more vulnerable to unauthorized access and potential data breaches.\n\nMoreover, the `available_to_other_tenants` attribute is set to `false`, which means the application is available to users in any Azure AD tenant, not just the one where it's registered. This could potentially allow unauthorized users to access the application.\n\nFinally, the `oauth2_allow_implicit_flow` attribute is set to `true`, which enables the OAuth 2.0 implicit grant flow. This flow allows the application to obtain an access token directly from the Azure AD authorization endpoint, without needing to authenticate first. This could potentially allow an attacker to impersonate a legitimate user and gain unauthorized access to the application.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\ndata \"azurerm_client_config\" \"current\" {}\n\nresource \"azuread_application\" \"example\" {\n  name                       = \"example-app\"\n  homepage                   = \"https://homepage\"\n  identifier_uris            = [\"https://uri\"]\n  reply_urls                 = [\"https://replyurl\"]\n  available_to_other_tenants = false\n  oauth2_allow_implicit_flow = true\n}\n\nresource \"azuread_service_principal\" \"example\" {\n  application_id = azuread_application.example.application_id\n}\n\nresource \"azuread_service_principal_password\" \"example\" {\n  service_principal_id = azuread_service_principal.example.id\n  value                = \"example_password\"\n  end_date             = \"2020-01-01T01:02:03Z\"\n}"
      },
      "secure_code_example": {
        "description": "The updated code removes the 'oauth2_allow_implicit_flow' attribute from the 'azuread_application' resource. This attribute was allowing the application to use the OAuth 2.0 implicit flow, which is less secure and has been deprecated.\n\nThe 'azuread_service_principal_password' resource now references a variable for the password value instead of hardcoding it. This is a more secure practice as it prevents sensitive information from being exposed in the code. The actual password can be provided as a variable when running Terraform.\n\nPlease note that this code update alone is not enough to fully address the vulnerability. Additional steps need to be taken outside of the code:\n\n1. Configure Conditional Access policies in Azure Active Directory to restrict access to the Azure AD Graph API services. This can be done in the Azure portal.\n\n2. Establish trusted locations for accessing the Azure AD Graph API services. This can be done by following the Azure documentation.\n\n3. Regularly review and update the access control configurations for the Azure AD Graph API services to ensure they are still appropriate and secure.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\ndata \"azurerm_client_config\" \"current\" {}\n\nresource \"azuread_application\" \"example\" {\n  name                       = \"example-app\"\n  homepage                   = \"https://homepage\"\n  identifier_uris            = [\"https://uri\"]\n  reply_urls                 = [\"https://replyurl\"]\n  available_to_other_tenants = false\n}\n\nresource \"azuread_service_principal\" \"example\" {\n  application_id = azuread_application.example.application_id\n}\n\nresource \"azuread_service_principal_password\" \"example\" {\n  service_principal_id = azuread_service_principal.example.id\n  value                = var.service_principal_password\n  end_date             = \"2020-01-01T01:02:03Z\"\n}"
      },
      "steps": [
        "1. Remove the 'oauth2_allow_implicit_flow' attribute from the 'azuread_application' resource.",
        "2. Configure Conditional Access policies in Azure Active Directory to restrict access to the Azure AD Graph API services.",
        "3. Follow Azure documentation to establish trusted locations for accessing the Azure AD Graph API services.",
        "4. Avoid hardcoding sensitive information, such as credentials, in the application code.",
        "5. Regularly review and update the access control configurations for the Azure AD Graph API services."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "402",
    "title": "Traceability Loss - Azure",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of Azure Resource Manager (azurerm) for managing Azure resources"
    ],
    "need": "Improved traceability and logging in Azure configurations",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "The above code block sets up an Azure Log Analytics Workspace with a basic configuration. It defines the location and name of the workspace, sets the SKU to \"PerGB2018\", and configures the retention period to 30 days.\n\nHowever, this configuration does not include detailed logging, which is essential for tracking and understanding activities within the workspace. This omission can lead to loss of traceability, making it difficult to detect anomalous behaviors or security breaches.\n\nThe vulnerability lies in the lack of detailed logging settings. As a result, potentially malicious activities might not be recorded, making it impossible to track them down. This lack of traceability can hinder the detection of security breaches and make incident response more challenging. \n\nTo fix this vulnerability, it is recommended to enable detailed logging in the Azure Log Analytics Workspace configuration. This can be done by enabling the 'diagnostic_settings' block in the 'azurerm_log_analytics_workspace' resource. Detailed logging should include all relevant data categories and logs should be retained for a sufficient amount of time to allow for effective incident detection and response.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_log_analytics_workspace\" \"example\" {\n  name                = \"example-workspace\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  sku                 = \"PerGB2018\"\n  retention_in_days   = 30\n}"
      },
      "secure_code_example": {
        "description": "The updated code includes the `azurerm_monitor_diagnostic_setting` resource which is used to enable diagnostic settings for the Azure resource group. The diagnostic settings include logs and metrics with a retention policy of 365 days. \n\nThe `log` block is configured to capture \"Action\" category logs. This category includes logs related to operations that modify the resource group. The `metric` block is configured to capture all metrics related to the resource group. Both the logs and metrics are enabled and have a retention policy of 365 days.\n\nThe logs and metrics are sent to the log analytics workspace specified by the `log_analytics_workspace_id` property. This ensures that all logs and metrics are centrally stored and can be analyzed for any anomalous behaviors or security breaches.\n\nThe `retention_in_days` property of the `azurerm_log_analytics_workspace` resource is also updated to 365 days to ensure that logs are retained for a sufficient period of time for analysis.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_log_analytics_workspace\" \"example\" {\n  name                = \"example-workspace\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n  sku                 = \"PerGB2018\"\n  retention_in_days   = 365\n}\n\nresource \"azurerm_monitor_diagnostic_setting\" \"example\" {\n  name                       = \"example-setting\"\n  target_resource_id         = azurerm_resource_group.example.id\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.example.id\n\n  log {\n    category = \"Action\"\n    enabled  = true\n\n    retention_policy {\n      enabled = true\n      days    = 365\n    }\n  }\n\n  metric {\n    category = \"AllMetrics\"\n    enabled  = true\n\n    retention_policy {\n      enabled = true\n      days    = 365\n    }\n  }\n}"
      },
      "steps": [
        "Enable diagnostic settings for the relevant Azure resources",
        "Configure the diagnostic settings to include the necessary log categories",
        "Specify the desired retention period for the logs",
        "Ensure that the logs are sent to a log analytics workspace",
        "Regularly review and analyze the logs for any anomalous behaviors or security breaches"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "225",
    "title": "Business information leak - Azure",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of AzureRM for managing Azure resources programmatically"
    ],
    "need": "Protection of customer data and prevention of unauthorized access",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "The above Terraform code creates an Azure resource group and a storage account within that group. The issue lies in the `allow_blob_public_access` attribute of the `azurerm_storage_account` resource. This attribute is set to `true`, which means that the blobs within this storage account are accessible to the public.\n\nThe `allow_blob_public_access` attribute controls whether or not public read access is allowed for the blobs in this storage account. If this is set to `true`, then anyone with the URL of the blob can access it.\n\nThis is a serious vulnerability because it could potentially allow unauthorized users to access sensitive business information stored in the blobs. This is especially dangerous if the storage account contains information from multiple customers, as the access would not be limited to a single customer's data.\n\nThis vulnerability could be exploited by malicious users who are aware of the public access setting and have the blob URLs. They could access the blobs, read the data, and potentially use it for malicious purposes.",
        "text": "provider \"azurerm\" {\n  version = \"=2.40.0\"\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_storage_account\" \"example\" {\n  name                     = \"examplestoracc\"\n  resource_group_name      = azurerm_resource_group.example.name\n  location                 = azurerm_resource_group.example.location\n  account_tier             = \"Standard\"\n  account_replication_type = \"GRS\"\n  \n  allow_blob_public_access = true\n}"
      },
      "secure_code_example": {
        "description": "The updated code includes several changes to address the vulnerability:\n\n1. `allow_blob_public_access` is set to `false` to disable public access to the storage account. This ensures that the data stored in the account is not accessible to the public.\n\n2. A `network_rules` block is added to the `azurerm_storage_account` resource. This block includes a `default_action` of \"Deny\", which means that all requests are denied by default. Only the requests that match the rules specified in the `ip_rules` and `virtual_network_subnet_ids` are allowed. This is a form of access control that restricts user access to sensitive data.\n\n3. A `azurerm_virtual_network` and `azurerm_subnet` resources are created. The `virtual_network_subnet_ids` in the `network_rules` block includes the ID of this subnet. This means that only the requests from this subnet are allowed.\n\nPlease note that this is a basic example and you might need to adjust the `ip_rules` and `virtual_network_subnet_ids` according to your needs. Also, remember to regularly rotate privileged credentials and implement strong authentication mechanisms for user login to further enhance the security.",
        "text": "provider \"azurerm\" {\n  version = \"=2.40.0\"\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_storage_account\" \"example\" {\n  name                     = \"examplestoracc\"\n  resource_group_name      = azurerm_resource_group.example.name\n  location                 = azurerm_resource_group.example.location\n  account_tier             = \"Standard\"\n  account_replication_type = \"GRS\"\n  \n  allow_blob_public_access = false\n\n  network_rules {\n    default_action             = \"Deny\"\n    virtual_network_subnet_ids = [azurerm_subnet.example.id]\n    ip_rules                   = [\"100.0.0.1\"]\n  }\n}\n\nresource \"azurerm_virtual_network\" \"example\" {\n  name                = \"example-network\"\n  resource_group_name = azurerm_resource_group.example.name\n  location            = azurerm_resource_group.example.location\n  address_space       = [\"10.0.0.0/16\"]\n}\n\nresource \"azurerm_subnet\" \"example\" {\n  name                 = \"example-subnet\"\n  resource_group_name  = azurerm_resource_group.example.name\n  virtual_network_name = azurerm_virtual_network.example.name\n  address_prefix       = \"10.0.1.0/24\"\n}"
      },
      "steps": [
        "Disable public access to the storage account",
        "Implement access controls to restrict user access to sensitive data",
        "Regularly rotate privileged credentials",
        "Implement strong authentication mechanisms for user login"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "300",
    "title": "Authentication mechanism absence or evasion - Azure",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of Azure Resource Manager (azurerm) for managing Azure resources"
    ],
    "need": "Implementation of robust and secure authentication mechanisms in Azure",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "The above Terraform code is used to spin up a virtual machine in Azure. It specifies the provider as Azure and sets the version. It then creates a resource of type `azurerm_virtual_machine` which represents a virtual machine in Azure.\n\nThe vulnerability lies in the `os_profile` block of the code. The `admin_username` and `admin_password` are hardcoded into the Terraform script. This is a significant security risk as anyone with access to this script would have the username and password for the administrative account on the virtual machine.\n\nAdditionally, the password is weak and easily guessable which makes it even more insecure. This could allow an attacker to gain unauthorized access to the virtual machine.\n\nFurthermore, the absence of an authentication mechanism for the provider block is another vulnerability. There's no mention of any service principal or client secret being used to authenticate to Azure. This means that the Terraform script is likely using the Azure CLI's logged in session, which is not a secure practice.\n\nThis code is vulnerable to Authentication mechanism absence or evasion.",
        "text": "provider \"azurerm\" {\n  version = \"=2.40.0\"\n}\n\nresource \"azurerm_virtual_machine\" \"vm\" {\n  name                  = \"myvm\"\n  location              = \"West Europe\"\n  resource_group_name   = \"my-resource-group\"\n  network_interface_id  = \"my-network-interface-id\"\n  vm_size               = \"Standard_D2s_v3\"\n  \n  delete_os_disk_on_termination = true\n  delete_data_disks_on_termination = true\n\n  os_profile {\n    computer_name  = \"hostname\"\n    admin_username = \"admin\"\n    admin_password = \"password\"\n  }\n\n  os_profile_windows_config {}\n}"
      },
      "secure_code_example": {
        "description": "The updated code now uses Azure Key Vault to securely store the admin password. The `azurerm_key_vault_secret` resource is used to create a secret in the Key Vault, which holds the admin password. This password is then retrieved and used in the `azurerm_virtual_machine` resource.\n\nThis approach avoids hardcoding sensitive information like passwords in the code, which is a security best practice. It also leverages Azure's built-in services for secrets management, which provide additional features like access control, auditing, and automatic rotation of secrets.\n\nPlease note that this is just one part of a secure authentication mechanism. You should also consider using Azure Active Directory (AAD) for authentication and authorization, implementing multi-factor authentication (MFA), and regularly reviewing and updating your authentication mechanisms to address any new vulnerabilities or weaknesses.",
        "text": "provider \"azurerm\" {\n  version = \"=2.40.0\"\n  features {}\n}\n\ndata \"azurerm_client_config\" \"current\" {}\n\nresource \"azurerm_key_vault\" \"example\" {\n  name                        = \"mykeyvault\"\n  location                    = \"West Europe\"\n  resource_group_name         = \"my-resource-group\"\n  enabled_for_disk_encryption = true\n  tenant_id                   = data.azurerm_client_config.current.tenant_id\n  soft_delete_retention_days  = 7\n  purge_protection_enabled    = false\n}\n\nresource \"azurerm_key_vault_secret\" \"example\" {\n  name         = \"adminpassword\"\n  value        = \"SecurePassword123!\"\n  key_vault_id = azurerm_key_vault.example.id\n}\n\nresource \"azurerm_virtual_machine\" \"vm\" {\n  name                  = \"myvm\"\n  location              = \"West Europe\"\n  resource_group_name   = \"my-resource-group\"\n  network_interface_id  = \"my-network-interface-id\"\n  vm_size               = \"Standard_D2s_v3\"\n  \n  delete_os_disk_on_termination = true\n  delete_data_disks_on_termination = true\n\n  os_profile {\n    computer_name  = \"hostname\"\n    admin_username = \"admin\"\n    admin_password = azurerm_key_vault_secret.example.value\n  }\n\n  os_profile_windows_config {}\n}"
      },
      "steps": [
        "Use a more secure authentication mechanism instead of using a plain text password.",
        "Consider using Azure Active Directory (AAD) for authentication and authorization.",
        "Implement multi-factor authentication (MFA) to add an extra layer of security.",
        "Avoid hardcoding sensitive information like passwords in the code.",
        "Use secrets management tools to securely store and retrieve authentication credentials.",
        "Regularly review and update authentication mechanisms to address any new vulnerabilities or weaknesses."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "372",
    "title": "Use of an insecure channel - HTTP",
    "context": [
      "Usage of Terraform 0.12 for Infrastructure as Code (IaC)",
      "Usage of AzureRM for managing Azure resources programmatically"
    ],
    "need": "Secure communication channel for client information transmission",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "This Terraform script sets up an Azure virtual machine and starts an HTTP server on port 80 without using HTTPS. The `custom_data` field in the `azurerm_linux_virtual_machine` resource contains a bash script that starts a simple HTTP server using busybox. This server listens on port 80, which is the default port for HTTP.\n\nThe use of HTTP means that any data sent to or from the server is not encrypted and could potentially be intercepted by malicious parties. This is a security risk, especially if sensitive data such as login credentials or personal information is being transmitted.\n\nIn addition, the use of HTTP instead of HTTPS can lead to other security vulnerabilities. For example, it could make the server more susceptible to man-in-the-middle attacks, where an attacker intercepts the communication between the client and the server.\n\nTo fix this vulnerability, the server should be configured to use HTTPS instead of HTTP. This would involve setting up an SSL/TLS certificate for the server and modifying the server configuration to use HTTPS.",
        "text": "provider \"azurerm\" {\n  version = \"=2.40.0\"\n  features {}\n}\n\nresource \"azurerm_virtual_network\" \"main\" {\n  name                = \"acctvn\"\n  address_space       = [\"10.0.0.0/16\"]\n  location            = \"West US 2\"\n  resource_group_name = \"my-resource-group\"\n}\n\nresource \"azurerm_subnet\" \"internal\" {\n  name                 = \"internal\"\n  resource_group_name  = \"my-resource-group\"\n  virtual_network_name = azurerm_virtual_network.main.name\n  address_prefixes     = [\"10.0.2.0/24\"]\n}\n\nresource \"azurerm_network_interface\" \"main\" {\n  name                = \"acctni\"\n  location            = \"West US 2\"\n  resource_group_name = \"my-resource-group\"\n\n  ip_configuration {\n    name                          = \"testconfiguration1\"\n    subnet_id                     = azurerm_subnet.internal.id\n    private_ip_address_allocation = \"Dynamic\"\n  }\n}\n\nresource \"azurerm_linux_virtual_machine\" \"main\" {\n  name                = \"acctvm\"\n  resource_group_name = \"my-resource-group\"\n  location            = \"West US 2\"\n  size                = \"Standard_F2\"\n  admin_username      = \"adminuser\"\n  network_interface_id = azurerm_network_interface.main.id\n\n  os_disk {\n    caching              = \"ReadWrite\"\n    storage_account_type = \"Standard_LRS\"\n  }\n\n  source_image_reference {\n    publisher = \"Canonical\"\n    offer     = \"UbuntuServer\"\n    sku       = \"16.04-LTS\"\n    version   = \"latest\"\n  }\n\n  admin_ssh_key {\n    username   = \"adminuser\"\n    public_key = file(\"~/.ssh/id_rsa.pub\")\n  }\n\n  custom_data = <<-EOF\n                  #!/bin/bash\n                  echo \"Hello, World!\" > index.html\n                  nohup busybox httpd -f -p 80 &\n                EOF\n}\n"
      },
      "secure_code_example": {
        "description": "The above code is a fixed version of the original Terraform script. The main change is in the `custom_data` field of the `azurerm_linux_virtual_machine` resource. \n\nIn the original script, a simple HTTP server was started using busybox. This server was insecure as it was transmitting data over HTTP, which is not encrypted.\n\nIn the fixed script, we are installing and configuring Nginx, a popular web server. We are also generating a self-signed SSL certificate and configuring Nginx to use this certificate for HTTPS. \n\nThe Nginx configuration includes a server block that listens on port 80 (HTTP) and redirects all traffic to HTTPS. This ensures that even if a client tries to connect using HTTP, they will be redirected to the secure HTTPS endpoint.\n\nPlease note that in a production environment, you should use a certificate issued by a trusted certificate authority instead of a self-signed certificate.",
        "text": "provider \"azurerm\" {\n  version = \"=2.40.0\"\n  features {}\n}\n\nresource \"azurerm_virtual_network\" \"main\" {\n  name                = \"acctvn\"\n  address_space       = [\"10.0.0.0/16\"]\n  location            = \"West US 2\"\n  resource_group_name = \"my-resource-group\"\n}\n\nresource \"azurerm_subnet\" \"internal\" {\n  name                 = \"internal\"\n  resource_group_name  = \"my-resource-group\"\n  virtual_network_name = azurerm_virtual_network.main.name\n  address_prefixes     = [\"10.0.2.0/24\"]\n}\n\nresource \"azurerm_network_interface\" \"main\" {\n  name                = \"acctni\"\n  location            = \"West US 2\"\n  resource_group_name = \"my-resource-group\"\n\n  ip_configuration {\n    name                          = \"testconfiguration1\"\n    subnet_id                     = azurerm_subnet.internal.id\n    private_ip_address_allocation = \"Dynamic\"\n  }\n}\n\nresource \"azurerm_linux_virtual_machine\" \"main\" {\n  name                = \"acctvm\"\n  resource_group_name = \"my-resource-group\"\n  location            = \"West US 2\"\n  size                = \"Standard_F2\"\n  admin_username      = \"adminuser\"\n  network_interface_id = azurerm_network_interface.main.id\n\n  os_disk {\n    caching              = \"ReadWrite\"\n    storage_account_type = \"Standard_LRS\"\n  }\n\n  source_image_reference {\n    publisher = \"Canonical\"\n    offer     = \"UbuntuServer\"\n    sku       = \"16.04-LTS\"\n    version   = \"latest\"\n  }\n\n  admin_ssh_key {\n    username   = \"adminuser\"\n    public_key = file(\"~/.ssh/id_rsa.pub\")\n  }\n\n  custom_data = <<-EOF\n                  #!/bin/bash\n                  sudo apt-get update\n                  sudo apt-get install -y nginx\n                  sudo ufw allow 'Nginx Full'\n                  sudo mkdir -p /etc/nginx/ssl\n                  sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/nginx.key -out /etc/nginx/ssl/nginx.crt -subj \"/C=US/ST=Denial/L=Springfield/O=Dis/CN=www.example.com\"\n                  sudo sh -c 'echo \"server {\n                    listen 80 default_server;\n                    listen [::]:80 default_server;\n                    server_name _;\n                    return 301 https://$host$request_uri;\n                  }\n                  server {\n                    listen 443 ssl default_server;\n                    listen [::]:443 ssl default_server;\n                    ssl_certificate /etc/nginx/ssl/nginx.crt;\n                    ssl_certificate_key /etc/nginx/ssl/nginx.key;\n                    location / {\n                      root /var/www/html;\n                      index index.html index.htm index.nginx-debian.html;\n                    }\n                  }\" > /etc/nginx/sites-available/default'\n                  sudo systemctl restart nginx\n                EOF\n}"
      },
      "steps": [
        "Enable HTTPS for the application",
        "Obtain an SSL/TLS certificate",
        "Configure the web server to use HTTPS",
        "Redirect HTTP traffic to HTTPS",
        "Update the application code to use HTTPS endpoints"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "157",
    "title": "Unrestricted access between network segments",
    "context": [
      "Usage of Terraform for Infrastructure as Code (IaC)",
      "Usage of azurerm for managing resources in Azure"
    ],
    "need": "Implementation of network segmentation and access controls",
    "solution": {
      "language": "azure",
      "insecure_code_example": {
        "description": "In the above code, a resource group is created, and within that resource group a virtual network is created with an address space of `10.0.0.0/16`. A subnet is also created within this virtual network with an address prefix of `10.0.2.0/24`. Finally, a network interface is created which is associated with the subnet.\n\nThe vulnerability lies in the fact that there are no network security groups (NSGs) applied to the subnet or the network interface. NSGs contain security rules that allow or deny inbound or outbound traffic to resources connected to Azure Virtual Networks. Without these, there are no restrictions on the traffic that can flow between different resources within the virtual network, or between the virtual network and the internet. This means that an employee could potentially access database servers from the internet, which is a security risk.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_virtual_network\" \"example\" {\n  name                = \"example-network\"\n  address_space       = [\"10.0.0.0/16\"]\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n}\n\nresource \"azurerm_subnet\" \"example\" {\n  name                 = \"example-subnet\"\n  resource_group_name  = azurerm_resource_group.example.name\n  virtual_network_name = azurerm_virtual_network.example.name\n  address_prefix       = \"10.0.2.0/24\"\n}\n\nresource \"azurerm_network_interface\" \"example\" {\n  name                = \"example-nic\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n\n  ip_configuration {\n    name                          = \"internal\"\n    subnet_id                     = azurerm_subnet.example.id\n    private_ip_address_allocation = \"Dynamic\"\n  }\n}"
      },
      "secure_code_example": {
        "description": "The updated code includes the creation of a Network Security Group (NSG) and a Network Security Rule. The NSG is associated with the subnet to enforce the security rule.\n\nThe `azurerm_network_security_group` resource creates a new NSG named \"example-nsg\". This NSG is located in the same resource group and location as the other resources.\n\nThe `azurerm_network_security_rule` resource creates a new security rule named \"example-rule\". This rule is configured to deny all inbound TCP traffic. The rule is associated with the \"example-nsg\" NSG.\n\nThe `azurerm_subnet_network_security_group_association` resource associates the \"example-nsg\" NSG with the \"example-subnet\" subnet. This means that the security rule will be enforced for all resources in the subnet.\n\nThe `azurerm_network_interface` resource is updated to use the \"example-subnet\" subnet, which is now associated with the NSG.\n\nThis configuration ensures that all inbound TCP traffic to the subnet is denied by default, limiting access between network segments. This aligns with the principle of least privilege by only allowing necessary traffic.",
        "text": "provider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"West Europe\"\n}\n\nresource \"azurerm_virtual_network\" \"example\" {\n  name                = \"example-network\"\n  address_space       = [\"10.0.0.0/16\"]\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n}\n\nresource \"azurerm_subnet\" \"example\" {\n  name                 = \"example-subnet\"\n  resource_group_name  = azurerm_resource_group.example.name\n  virtual_network_name = azurerm_virtual_network.example.name\n  address_prefix       = \"10.0.2.0/24\"\n}\n\nresource \"azurerm_network_security_group\" \"example\" {\n  name                = \"example-nsg\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n}\n\nresource \"azurerm_network_security_rule\" \"example\" {\n  name                        = \"example-rule\"\n  priority                    = 100\n  direction                   = \"Inbound\"\n  access                      = \"Deny\"\n  protocol                    = \"Tcp\"\n  source_port_range           = \"*\"\n  destination_port_range      = \"*\"\n  source_address_prefix       = \"*\"\n  destination_address_prefix  = \"*\"\n  resource_group_name         = azurerm_resource_group.example.name\n  network_security_group_name = azurerm_network_security_group.example.name\n}\n\nresource \"azurerm_subnet_network_security_group_association\" \"example\" {\n  subnet_id                 = azurerm_subnet.example.id\n  network_security_group_id = azurerm_network_security_group.example.id\n}\n\nresource \"azurerm_network_interface\" \"example\" {\n  name                = \"example-nic\"\n  location            = azurerm_resource_group.example.location\n  resource_group_name = azurerm_resource_group.example.name\n\n  ip_configuration {\n    name                          = \"internal\"\n    subnet_id                     = azurerm_subnet.example.id\n    private_ip_address_allocation = \"Dynamic\"\n  }\n}"
      },
      "steps": [
        "Implement network segmentation to restrict access between network segments",
        "Identify the different network segments required for the application",
        "Define access control policies to limit communication between network segments",
        "Configure firewall rules or network security groups to enforce the access control policies",
        "Regularly review and update the access control policies to ensure they align with the principle of least privilege",
        "Monitor network traffic and logs to detect any unauthorized access attempts"
      ]
    },
    "last_update_time": "09/18/2023"
  }
]
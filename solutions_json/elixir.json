[
  {
    "vulnerability_id": "107",
    "title": "LDAP Injection",
    "context": [
      "Usage of Elixir (v1.11+) with Erlang/OTP (v23+)",
      "Usage of eldap library for LDAP operations in Erlang"
    ],
    "need": "To prevent unauthorized data access and manipulation through LDAP Injection attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code, the Elixir application accepts a username from user input and uses it directly in an LDAP query. This can be exploited for an LDAP Injection attack, leading to unauthorized data access or manipulation.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def index(conn, %{\"username\" => username}) do\n    :eldap.open([\"ldap.example.com\"])\n    search_filter = {:substrings, 'uid', [{:initial, username}]}\n    {:ok, result} = :eldap.search([base: 'ou=Users,dc=example,dc=com', filter: search_filter])\n    json(conn, result)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code, the application now sanitizes the user input by replacing potential LDAP Injection attack characters '('. The sanitized input is then used in the LDAP query.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def index(conn, %{\"username\" => username}) do\n    :eldap.open([\"ldap.example.com\"])\n    username = String.replace(username, \"(\", \"\") |> String.replace(\")\", \"\")\n    search_filter = {:substrings, 'uid', [{:initial, username}]}\n    {:ok, result} = :eldap.search([base: 'ou=Users,dc=example,dc=com', filter: search_filter])\n    json(conn, result)\n  end\nend"
      },
      "steps": [
        "Don't use user input directly in LDAP queries.",
        "Sanitize user input before using it in a query.",
        "Use parameterized queries or prepared statements if available."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "106",
    "title": "NoSQL Injection",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of MongoDB driver for interacting with MongoDB database"
    ],
    "need": "To prevent unauthorized data access and manipulation through NoSQL Injection attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code, the Elixir/Phoenix application accepts an ID from user input and uses it directly in a MongoDB query. This can be exploited for a NoSQL Injection attack, leading to unauthorized data access or manipulation.",
        "text": "defmodule MyAppWeb.PageController do\n  use MyAppWeb, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    page = Mongo.find(:mongo, \"pages\", %{\"_id\" => id}) |> Enum.to_list()\n    json(conn, page)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code, the application now sanitizes the user input by replacing potential NoSQL Injection attack characters '$' and '.'. The sanitized input is then used in the MongoDB query.",
        "text": "defmodule MyAppWeb.PageController do\n  use MyAppWeb, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    id = String.replace(id, \"$\", \"\") |> String.replace(\".\", \"\")\n    page = Mongo.find(:mongo, \"pages\", %{\"_id\" => id}) |> Enum.to_list()\n    json(conn, page)\n  end\nend"
      },
      "steps": [
        "Don't use user input directly in NoSQL queries.",
        "Sanitize user input before using it in a query.",
        "Use parameterized queries or prepared statements if available."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "100",
    "title": "Server-side Request Forgery (SSRF)",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Plug.Adapters.Cowboy2.Http module for handling HTTP requests in Elixir",
      "Usage of httpc module for making HTTP requests"
    ],
    "need": "To prevent unauthorized network requests performed by the server due to user input manipulation",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code, the Elixir/Phoenix application accepts a URL from user input and makes a HTTP request to it using the :httpc.request function. This is a server-side request forgery (SSRF) vulnerability, as a malicious user could manipulate the input to make the server perform unauthorized requests.",
        "text": "defmodule MyAppWeb.PageController do\n  use MyAppWeb, :controller\n\n  def external_request(conn, %{\"url\" => url} = _params) do\n    {:ok, response} = :httpc.request(url)\n    text(response)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code, the application still accepts a URL from user input. However, it now validates the input with a validate_url function, which checks if the input is part of a list of approved domains. This mitigates the SSRF vulnerability by preventing the server from making requests to unapproved domains.",
        "text": "defmodule MyAppWeb.PageController do\n  use MyAppWeb, :controller\n\n  def external_request(conn, %{\"url\" => url} = _params) do\n    if validate_url(url) do\n      {:ok, response} = :httpc.request(url)\n      text(response)\n    else\n      send_resp(conn, 400, \"Invalid URL\")\n    end\n  end\n\n  defp validate_url(url), do: Enum.member?([\"http://approved1.com\", \"http://approved2.com\"], url)\nend"
      },
      "steps": [
        "Don't allow user input to dictate the server's network requests directly.",
        "If user input must be used to make network requests, implement strict input validation and only allow requests to approved domains.",
        "Consider using a safe-list of approved domains that the server can make requests to."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "094",
    "title": "Insecure Encryption Algorithm - Cipher Block Chaining",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Elixir's :crypto module for cryptographic operations"
    ],
    "need": "To ensure that data encryption and decryption processes are secure, minimizing the risk of data being compromised",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code snippet is using the :aes_cbc128 mode for the block cipher which is considered insecure due to vulnerabilities like the padding oracle attack. It makes it possible for an attacker to decrypt data without knowing the key.",
        "text": "defmodule InsecureCipher do\n  def encrypt(data, key, iv) do\n    :crypto.block_encrypt(:aes_cbc128, key, iv, data)\n  end\n  def decrypt(ciphertext, key, iv) do\n    :crypto.block_decrypt(:aes_cbc128, key, iv, ciphertext)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This secure code example uses the AES GCM mode for the block cipher which provides authenticated encryption. It also adds data integrity through the use of additional authenticated data (AAD). This makes it secure against attacks like the padding oracle attack.",
        "text": "defmodule SecureCipher do\n  def encrypt(data, key, iv, aad) do\n    :crypto.crypto_one_time(:aes_gcm, key, iv, {aad, data}, :encrypt)\n  end\n  def decrypt(ciphertext_with_tag, key, iv, aad) do\n    :crypto.crypto_one_time(:aes_gcm, key, iv, {aad, ciphertext_with_tag}, :decrypt)\n  end\nend"
      },
      "steps": [
        "Switch from CBC mode to GCM mode.",
        "Make sure to use a secure source of random numbers for the IV (Initialization Vector).",
        "Always use secure and updated cryptographic libraries."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "093",
    "title": "Hidden Fields Manipulation",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications"
    ],
    "need": "To prevent users from manipulating hidden fields in the application that could lead to undesired behaviors",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code snippet is vulnerable because it accepts all the parameters from the client-side, including the id field. An attacker could manipulate this id field in a hidden form input, thus potentially altering data they do not have access to.",
        "text": "def update(conn, %{\"user\" => user_params}) do\n  user = Repo.get!(User, user_params[\"id\"])\n  case Accounts.update_user(user, user_params) do\n    {:ok, user} -> redirect(conn, to: user_path(conn, :show, user))\n    {:error, _changeset} -> :error\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure version, instead of getting the user's id from the client-side, it's obtained from the server-side using the authenticated user's session. This prevents attackers from manipulating the id field.",
        "text": "def update(conn, %{\"user\" => user_params}) do\n  user = Accounts.get_user!(conn.assigns.current_user.id)\n  case Accounts.update_user(user, user_params) do\n    {:ok, user} -> redirect(conn, to: user_path(conn, :show, user))\n    {:error, _changeset} -> :error\n  end\nend"
      },
      "steps": [
        "Do not expose sensitive information such as the user id to the client side.",
        "Always validate the user input at the server side, never trust user input blindly.",
        "Enforce authorization checks to ensure that the user is allowed to perform the action."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "092",
    "title": "Insecure Encryption Algorithm - Anonymous Cipher Suites",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Erlang/OTP's ssl application for secure communication"
    ],
    "need": "To ensure secure encrypted connections that are not vulnerable to MitM attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code snippet creates an SSL server that accepts connections using anonymous cipher suites. This means that it does not authenticate the server to the client, allowing potential MitM attacks.",
        "text": "{:ok, _} = :ssl.listen(4001, [:inet6, {:packet, 0}, {:active, false}, {:keyfile, 'key.pem'}, {:certfile, 'cert.pem'}, {:versions, ['tlsv1.2']}, {:ciphers, [:'ECDH-ECDSA-AES128-GCM-SHA256', :anonymous] }])"
      },
      "secure_code_example": {
        "description": "This code snippet creates an SSL server that does not accept connections using anonymous cipher suites. By only allowing secure cipher suites, it ensures that all connections are authenticated and resistant to MitM attacks.",
        "text": "{:ok, _} = :ssl.listen(4001, [:inet6, {:packet, 0}, {:active, false}, {:keyfile, 'key.pem'}, {:certfile, 'cert.pem'}, {:versions, ['tlsv1.2']}, {:ciphers, [:'ECDH-ECDSA-AES128-GCM-SHA256'] }])"
      },
      "steps": [
        "Identify where your application is setting up SSL connections and allowing anonymous cipher suites.",
        "Remove any anonymous cipher suites from the list of allowed ciphers.",
        "Ensure that all connections require authentication, rejecting anonymous cipher suites."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "080",
    "title": "Business Information Leak - Customers or Providers",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Plug for creating middleware",
      "Usage of Phoenix Framework for web interface development"
    ],
    "need": "Ensure the privacy and security of sensitive business information",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code retrieves all customer information from the database and renders it without any authentication or authorization check. This can lead to exposure of sensitive customer data, which can be used to craft new attack vectors.",
        "text": "defmodule UnsecuredController do\n  use Phoenix.Controller\n\n  def list_customers(conn, _params) do\n    customers = Repo.all(Customer)\n    render(conn, \"index.html\", customers: customers)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code checks if the user is authenticated and authorized before retrieving and rendering customer data. This prevents unauthorized users from accessing sensitive customer data.",
        "text": "defmodule SecuredController do\n  use Phoenix.Controller\n\n  plug :authenticate_user\n\n  def list_customers(conn, _params) do\n    customers = Repo.all(Customer)\n    render(conn, \"index.html\", customers: customers)\n  end\n\n  defp authenticate_user(conn, _opts) do\n    # Check if user is authenticated and authorized\n    #... code ...\n    # If not authenticated or authorized, redirect or send error response\n    #... code ...\n  end\nend"
      },
      "steps": [
        "Use a middleware like Plug to handle authentication and authorization.",
        "Create a function to check if the user is authenticated and authorized before allowing access to the customer data.",
        "Wrap your sensitive routes with this middleware."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "079",
    "title": "Non-upgradable Dependencies",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Mix as the package manager"
    ],
    "need": "Use a dependency manager to ensure smooth updates and maintainability",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The `generate_uuid` function uses code directly copied from a package (UUID package for instance). This makes it hard to update and maintain the code. Also, if a vulnerability is found in the original package, the code here will also be vulnerable and would need a manual update.",
        "text": "defmodule InsecureDependencies do\n  # Here the user is using the copied code of the UUID package directly into the file\n  def generate_uuid do\n    #...Code copied from UUID package...\n  end\nend"
      },
      "secure_code_example": {
        "description": "Now, the UUID package is declared as a dependency in the mix.exs file and fetched using `mix deps.get`. This way, it's easier to update and maintain the code. Moreover, if a vulnerability is found in the original package, you just need to update the version in the mix.exs file and run `mix deps.get` again.",
        "text": "# mix.exs file\n\ndefp deps do\n  [\n    {:uuid, \"~> 1.8\"}\n  ]\nend\n\n# Using the UUID package in your code\n\ndefmodule SecureDependencies do\n  def generate_uuid do\n    UUID.uuid4()\n  end\nend"
      },
      "steps": [
        "Define all dependencies in your mix.exs file.",
        "Run `mix deps.get` in your command line to fetch the defined dependencies."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "078",
    "title": "Insecurely Generated Token",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix.Token for token generation and verification"
    ],
    "need": "Create secure, unpredictable session tokens to prevent reuse",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The `generate_token` function is insecure because it simply reverses the user_id and uses it as a token. This approach is predictable and can easily be reverse-engineered, which could allow an attacker to reuse a session token after 14 days.",
        "text": "defmodule InsecureToken do\n  def generate_token(user_id) do\n    user_id\n    |> Integer.to_string\n    |> String.reverse\n  end\nend"
      },
      "secure_code_example": {
        "description": "The `generate_token` function now uses `Phoenix.Token.sign/3` to generate a secure token, and `verify_token` uses `Phoenix.Token.verify/4` to verify the token's integrity and timeliness. The token is cryptographically secure and unpredictable, and it cannot be reused after 14 days.",
        "text": "defmodule SecureToken do\n  @secret_key_base \"s3cr3t\"\n\n  def generate_token(user_id) do\n    Phoenix.Token.sign(@secret_key_base, \"user salt\", user_id)\n  end\n\n  def verify_token(token, user_id) do\n    Phoenix.Token.verify(@secret_key_base, \"user salt\", token, max_age: 14 * 24 * 60 * 60)\n  end\nend"
      },
      "steps": [
        "Install the Phoenix.Token package if it's not already installed.",
        "Use `Phoenix.Token.sign/3` to generate a secure token, providing the user_id as the salt.",
        "Use `Phoenix.Token.verify/4` to verify tokens before use."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "067",
    "title": "Improper Resource Allocation",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and concurrent applications"
    ],
    "need": "Prevent unnecessary resource consumption due to inefficient algorithms or improper programming practices",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The `huge_list` function creates a list from 1 to `n`. If `n` is a large number, this function could consume a large amount of memory, possibly leading to an OutOfMemory error or significantly slowing down the system.",
        "text": "defmodule Vulnerable do\n  def huge_list(n) when is_integer(n) do\n    Enum.to_list(1..n)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure example, a guard clause has been added to limit `n` to 10,000, preventing the creation of extremely large lists. The actual limit should be determined based on the specific requirements and resources of your system.",
        "text": "defmodule Secure do\n  def huge_list(n) when is_integer(n) and n <= 10000 do\n    Enum.to_list(1..n)\n  end\nend"
      },
      "steps": [
        "Consider the nature of the problem you're trying to solve and choose the appropriate data structure.",
        "If possible, use lazy evaluation to avoid creating large data structures in memory.",
        "Apply a limit to the input size if it's under external control.",
        "If the function is intended to create large data structures, consider alternative strategies like writing the data to disk."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "066",
    "title": "Technical Information Leak - Console Functions",
    "context": [
      "Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of IO library for input/output operations"
    ],
    "need": "Avoid leaking technical information via console functions",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The `IO.inspect` function is used to print the data to the console. This could expose sensitive information in a production environment.",
        "text": "defmodule Vulnerable do\n  def process(data) do\n    IO.inspect(data)\n    # Process data\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure example, the `IO.inspect` function has been commented out to prevent information leakage. Logging to files or using proper logging libraries would be a more secure approach.",
        "text": "defmodule Secure do\n  def process(data) do\n    # IO.inspect(data)\n    # Process data\n  end\nend"
      },
      "steps": [
        "Remove or comment out IO functions in production code.",
        "Use a proper logging library that writes to log files instead of stdout.",
        "Implement a logging level feature where debug-level messages aren't logged in production."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "064",
    "title": "Traceability Loss - Server's Clock",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Logger module for logging"
    ],
    "need": "Accurate timestamping for traceability",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This function logs an event with a timestamp that is based on the system's internal clock, which may not be synchronized with an NTP server. If the internal clock is wrong, the logged timestamps will also be wrong, causing a loss of traceability.",
        "text": "def log_event(event) do\n  Logger.info(\"{#{DateTime.utc_now()}} - #{event}\")\nend"
      },
      "secure_code_example": {
        "description": "In the corrected code, the function's behavior doesn't change because the NTP synchronization happens at the system level. The function still uses `DateTime.utc_now()`, but now the underlying system time is correctly synchronized with an NTP server. This ensures accurate timestamps in logs.",
        "text": "def log_event(event) do\n  Logger.info(\"{#{DateTime.utc_now()}} - #{event}\")\nend"
      },
      "steps": [
        "Make sure your server's clock is synchronized with an NTP server.",
        "Ensure the application relies on this synchronized time for timestamping logs."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "059",
    "title": "Sensitive Information Stored in Logs",
    "context": [
      "Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug library for request handling"
    ],
    "need": "Prevent unauthorized access to sensitive data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This function handles all incoming requests. It first reads the body of the request and then logs it using IO.inspect. This is problematic because the body of the request can contain sensitive user information like usernames, passwords, and other personal data. Logging this data in plain text can expose it to unauthorized users who might have access to the log files.",
        "text": "def handle_request(request) do\n  {:ok, body, conn} = read_body(request.conn)\n  IO.inspect(body)\n  case Router.dispatch(request) do\n    {:ok, response} -> send_resp(conn, 200, response)\n    _ -> send_resp(conn, 404, 'Not found')\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure version of the function, we only log non-sensitive parts of the request. In this case, we remove the password from the body before logging it.",
        "text": "def handle_request(request) do\n  {:ok, body, conn} = read_body(request.conn)\n  IO.inspect(Map.delete(body, 'password'))\n  case Router.dispatch(request) do\n    {:ok, response} -> send_resp(conn, 200, response)\n    _ -> send_resp(conn, 404, 'Not found')\n  end\nend"
      },
      "steps": [
        "Stop logging the entire request body.",
        "If necessary, only log non-sensitive parts of the request."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "052",
    "title": "Insecure Encryption Algorithm",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of crypto library for encryption"
    ],
    "need": "Prevent unauthorized access and tampering of encrypted data.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir function uses the DES algorithm to encrypt data. DES is considered insecure due to its small key size, making it susceptible to brute-force attacks.",
        "text": "def encrypt(data, key) do\n  :crypto.block_encrypt(:des_ecb, key, data)\nend"
      },
      "secure_code_example": {
        "description": "This Elixir function uses the AES algorithm to encrypt data. AES is a secure encryption algorithm that is resistant to brute-force attacks due to its large key size.",
        "text": "def encrypt(data, key) do\n  :crypto.block_encrypt(:aes_ecb, key, data)\nend"
      },
      "steps": [
        "Replace the DES encryption function with the AES encryption function.",
        "Ensure that the key size is at least 128 bits, which is the minimum key size for AES."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "051",
    "title": "Cracked Weak Credentials",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Comeonin library for hashing"
    ],
    "need": "Prevent unauthorized access by securely hashing and storing passwords.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir function hashes passwords with the SHA-256 function before storing them. While SHA-256 is not inherently insecure, it is not suitable for password hashing due to its speed, which makes it susceptible to brute-force attacks.",
        "text": "def register_user(username, password) do\n  hashed_password = :crypto.hash(:sha256, password)\n  User.changeset(%User{}, %{username: username, password: hashed_password})\n  |> Repo.insert()\nend"
      },
      "secure_code_example": {
        "description": "This Elixir function hashes passwords with bcrypt before storing them. bcrypt is a secure hashing function that is resistant to brute-force attacks due to its configurable computational cost.",
        "text": "def register_user(username, password) do\n  hashed_password = Comeonin.Bcrypt.hashpwsalt(password)\n  User.changeset(%User{}, %{username: username, password: hashed_password})\n  |> Repo.insert()\nend"
      },
      "steps": [
        "Replace the SHA-256 hashing function with bcrypt.",
        "Ensure that the bcrypt work factor is appropriately high to increase the computational cost of cracking the hashes."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "050",
    "title": "Guessed Weak Credentials",
    "context": [
      "Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of Ecto library for data validation"
    ],
    "need": "Prevent brute force attacks by enforcing a strong password policy.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir function allows a user to register with any password, regardless of its length or complexity. This makes it easy for an attacker to guess weak passwords.",
        "text": "def register_user(username, password) do\n  User.changeset(%User{}, %{username: username, password: password})\n  |> Repo.insert()\nend"
      },
      "secure_code_example": {
        "description": "This Elixir function enforces a strong password policy during user registration. The password must be at least 8 characters long and include a lower-case letter, an upper-case letter, and a number.",
        "text": "def changeset(user, attrs) do\n  user\n  |> cast(attrs, [:username, :password])\n  |> validate_length(:password, min: 8)\n  |> validate_format(:password, ~r/[a-z]/, message: \"must include a lower-case letter\")\n  |> validate_format(:password, ~r/[A-Z]/, message: \"must include an upper-case letter\")\n  |> validate_format(:password, ~r/[0-9]/, message: \"must include a number\")\nend\n\ndef register_user(username, password) do\n  User.changeset(%User{}, %{username: username, password: password})\n  |> Repo.insert()\nend"
      },
      "steps": [
        "Add password validation in the changeset function. This should enforce a minimum length and complexity requirements.",
        "Test the application to ensure the password policy is being enforced correctly."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "042",
    "title": "Insecurely Generated Cookies",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and concurrent applications",
      "Usage of Plug library for handling HTTP requests"
    ],
    "need": "Prevent cookie exposure over insecure channels or to unauthorized users.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir function sets a 'session' cookie without secure flags. Without the secure flag, the cookie could be sent over an insecure HTTP connection. Without the HttpOnly flag, the cookie could be accessed by client-side scripts.",
        "text": "def set_cookie(conn) do\n  conn\n  |> put_resp_cookie(\"session\", \"session_value\")\nend"
      },
      "secure_code_example": {
        "description": "This Elixir function sets a 'session' cookie with the secure and HttpOnly flags. The secure flag ensures the cookie is only sent over HTTPS. The HttpOnly flag prevents the cookie from being accessed by client-side scripts.",
        "text": "def set_cookie(conn) do\n  conn\n  |> put_resp_cookie(\"session\", \"session_value\", secure: true, http_only: true)\nend"
      },
      "steps": [
        "Add the :secure and :http_only options when setting the cookie.",
        "Test the application to ensure the cookies are being set correctly and that the application still functions as expected."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "041",
    "title": "Enabled Default Credentials",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of PostgreSQL Database for data storage and retrieval"
    ],
    "need": "Prevent unauthorized access to system resources using default credentials.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This is the configuration for a PostgreSQL database in an Elixir application. The username and password are set to 'postgres', which are commonly used default credentials. If an attacker knows or guesses that the application is using these default credentials, they can gain unauthorized access to the database.",
        "text": "config :my_app, MyApp.Repo,\n  database: \"my_app_prod\",\n  username: \"postgres\",\n  password: \"postgres\",\n  hostname: \"localhost\""
      },
      "secure_code_example": {
        "description": "In the secure example, the username and password are not hard-coded into the application. Instead, the application retrieves them from environment variables. This helps to keep the credentials secure.",
        "text": "config :my_app, MyApp.Repo,\n  database: \"my_app_prod\",\n  username: System.get_env(\"DB_USERNAME\"),\n  password: System.get_env(\"DB_PASSWORD\"),\n  hostname: \"localhost\""
      },
      "steps": [
        "Change the default credentials to a unique, strong username and password.",
        "Store the new credentials securely. Do not hard-code them into your application. Consider using environment variables or a secure credential storage solution."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "039",
    "title": "Improper Authorization Control for Web Services",
    "context": [
      "Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications"
    ],
    "need": "Proper validation of user sessions or tokens to secure web services.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code sample is a simple controller action in a Phoenix API that retrieves and sends user data based on the user id received from the request parameters. The problem here is there are no authorization checks in place, meaning any authenticated user or even unauthenticated users can retrieve any user's information just by changing the id parameter. This poses a significant risk as it can lead to unauthorized access to confidential user information.",
        "text": "def show(conn, %{\"id\" => id}) do\n  user = Repo.get(User, id)\n  render(conn, \"show.json\", user: user)\nend"
      },
      "secure_code_example": {
        "description": "In the secure code sample, before fetching the user data, an authorization check is added to ensure that the requester is the same as the user they are trying to access. If the check fails, a 403 Forbidden response is returned, thus preventing unauthorized access.",
        "text": "def show(conn, %{\"id\" => id}) do\n  requester = get_current_user(conn)\n  if requester && requester.id == id do\n    user = Repo.get(User, id)\n    render(conn, \"show.json\", user: user)\n  else\n    conn |> put_status(:forbidden) |> json(%{message: 'Forbidden'})\n  end\nend"
      },
      "steps": [
        "Add an authorization check before accessing user data.",
        "Ensure the user making the request is authorized to access the requested user's data."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "038",
    "title": "Business Information Leak",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications"
    ],
    "need": "Prevention of unauthorized access to sensitive business data.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code is a simple controller action in a Phoenix API that lists all the users in the database. The Repo.all(User) fetches all users' information from the database, including sensitive data such as usernames, employee information, client information, provider information, and strategic information. This is a business information leak vulnerability because it exposes sensitive business data without proper access control checks.",
        "text": "def index(conn, _params) do\n  users = Repo.all(User)\n  render(conn, \"index.json\", users: users)\nend"
      },
      "secure_code_example": {
        "description": "In this code, before we fetch any user data, we check if the currently authenticated user is an admin. If they are, we fetch the users but only return the id and username, removing any sensitive information. If the current user is not an admin, we return a 403 Forbidden response.",
        "text": "def index(conn, _params) do\n  user = get_current_user(conn)\n  if user && user.role == 'admin'\n    users = Repo.all(User)\n    users = for user <- users, do: %{id: user.id, username: user.username}\n    render(conn, \"index.json\", users: users)\n  else\n    conn |> put_status(:forbidden) |> json(%{message: 'Forbidden'})\n  end\nend"
      },
      "steps": [
        "Implement proper access control checks before retrieving data from the database.",
        "Restrict what information is sent to the client.",
        "Consider using view models to control what data is sent to the client."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "037",
    "title": "Technical Information Leak",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for the application"
    ],
    "need": "To prevent unauthorized access to sensitive system and configuration data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The vulnerable code below doesn't handle the HTTP headers and response properly. Thus, it leaks the Phoenix version information which can expose the application to potential risks. The version information can help an attacker find known vulnerabilities and launch specific attacks.",
        "text": "defmodule MyAppWeb.Router do\n use MyAppWeb, :router\n\n pipeline :api do\n plug :accepts, [\"json\"]\n end\n\n scope \"/api\", MyAppWeb do\n pipe_through :api\n\n resources \"/users\", UserController, only: [:index, :show, :create]\n end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code, the version header is removed using the put_resp_header function. This prevents leaking the Phoenix version information to the client. This is a simple yet effective way to reduce the information an attacker could potentially use.",
        "text": "defmodule MyAppWeb.Router do\n use MyAppWeb, :router\n\n pipeline :api do\n plug :accepts, [\"json\"]\n plug :remove_version_header\n end\n\n defp remove_version_header(conn, _opts) do\n Plug.Conn.put_resp_header(conn, \"server\", \"My App\")\n end\n\n scope \"/api\", MyAppWeb do\n pipe_through :api\n\n resources \"/users\", UserController, only: [:index, :show, :create]\n end\nend"
      },
      "steps": [
        "Add a new function inside the router module that removes or alters the server response header.",
        "Call this function inside the pipeline that will be used by the desired routes."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "034",
    "title": "Insecure Generation of Random Numbers",
    "context": [
      "Usage of Elixir (1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of Erlang/OTP for building scalable and fault-tolerant systems"
    ],
    "need": "Prevent predictable sequences of random numbers",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable as it uses the :random.uniform function from Erlang which is not suitable for generating secure random numbers. Also, it uses :erlang.now to seed the random number generator, which can be predictable and hence lead to generating predictable random numbers.",
        "text": "defmodule MyApp.TokenGenerator do\n  def generate_token do\n    :random.seed(:erlang.now())\n    :random.uniform(100000)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This secure code uses the :crypto.strong_rand_bytes function for generating a binary string of random bytes, which is then converted into a hexadecimal string using Base.encode16. This ensures the generation of secure random numbers.",
        "text": "defmodule MyApp.TokenGenerator do\n  def generate_token do\n    :crypto.strong_rand_bytes(16) |> Base.encode16()\n  end\nend"
      },
      "steps": [
        "Avoid using the :random.uniform function for generating secure random numbers.",
        "Use :crypto.strong_rand_bytes function for generating secure random numbers.",
        "Use Base.encode16 function to convert the binary data to a hexadecimal string if needed."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "030",
    "title": "Sensitive Information Sent Via URL Parameters",
    "context": [
      "Usage of Elixir (1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications (version 1.5 and above)"
    ],
    "need": "Secure transmission of sensitive information",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The above code is vulnerable because it allows the user id to be passed as a URL parameter. This exposes the user's sensitive information as the user id is visible in the URL and can be stored in browser history, sent to external sites via the referrer HTTP header, or intercepted by malicious scripts.",
        "text": "defmodule UserController do\n  use MyAppWeb, :controller\n  def show(conn, %{'id' => id}) do\n    user = Repo.get!(User, id)\n    render(conn, 'show.html', user: user)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the user id is obtained from a secure session or a cookie, rather than being passed in the URL. This mitigates the risk of sensitive information being exposed via the URL.",
        "text": "defmodule UserController do\n  use MyAppWeb, :controller\n  def show(conn, _params) do\n    id = get_session(conn, :user_id)\n    user = Repo.get!(User, id)\n    render(conn, 'show.html', user: user)\n  end\nend"
      },
      "steps": [
        "Avoid sending sensitive information in URL parameters.",
        "Use the POST method to transmit sensitive data.",
        "Use secure sessions or cookies to store user identifiers."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "028",
    "title": "Insecure Temporary Files",
    "context": [
      "Usage of Elixir (1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework (1.5+) for building web applications"
    ],
    "need": "Securely store sensitive information",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The above code is vulnerable because it writes sensitive information to a temporary file '/tmp/temp_file'. This file is accessible to all other users on the system, and can also be read by any other processes. This exposes the sensitive information to potential unauthorized access and theft.",
        "text": "defmodule TempFilesController do\n  use MyAppWeb, :controller\n  def write(conn, %{'data' => data}) do\n    File.write!('/tmp/temp_file', data)\n    send_resp(conn, 200, \"Data written to temporary file.\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the sensitive data is first encrypted before being stored, ensuring that even if unauthorized access were to occur, the data would be unreadable without the decryption key. The 'SecureStorage' is a hypothetical secure storage system that should be substituted with an actual secure data storage system in your application.",
        "text": "defmodule SecureStorageController do\n  use MyAppWeb, :controller\n  def write(conn, %{'data' => data}) do\n    encrypted_data = Encryption.encrypt(data)\n    {:ok, _} = SecureStorage.put(encrypted_data)\n    send_resp(conn, 200, \"Data securely stored.\")\n  end\nend"
      },
      "steps": [
        "Avoid saving sensitive information in temporary files.",
        "Encrypt sensitive data before saving.",
        "Ensure temporary files are securely deleted after use."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "026",
    "title": "User Enumeration Vulnerability",
    "context": [
      "Usage of Elixir (1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework (1.5 and above) for building web applications"
    ],
    "need": "Prevent attackers from enumerating valid usernames in the system",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The above code is vulnerable to user enumeration. When a user tries to log in, the application responds differently depending on whether the provided username exists or not. If the username doesn't exist, it sends back a 'User does not exist' message. If the username exists but the password is wrong, it sends back a 'Wrong password' message. An attacker could use these differing responses to enumerate the existing users.",
        "text": "defmodule UserController do\n  use MyAppWeb, :controller\n  def login(conn, %{'username' => username, 'password' => password}) do\n    case Accounts.get_user_by_username(username) do\n      nil -> send_resp(conn, 400, \"User does not exist\")\n      user ->\n        if user.password == password,\n          do: send_resp(conn, 200, \"Logged in successfully\")\n          else: send_resp(conn, 400, \"Wrong password\")\n        end\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the server's response is the same ('Incorrect credentials') for both existent and non-existent users. This prevents an attacker from being able to enumerate the existing users based on the server's responses.",
        "text": "defmodule UserController do\n  use MyAppWeb, :controller\n  def login(conn, %{'username' => username, 'password' => password}) do\n    case Accounts.get_user_by_username(username) do\n      nil -> send_resp(conn, 400, \"Incorrect credentials\")\n      user ->\n        if user.password == password,\n          do: send_resp(conn, 200, \"Logged in successfully\")\n          else: send_resp(conn, 400, \"Incorrect credentials\")\n        end\n    end\n  end\nend"
      },
      "steps": [
        "Change the server response to be the same for both existent and non-existent users.",
        "Ensure that the response does not leak any information about the existence or non-existence of a user."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "022",
    "title": "Use of an Insecure Channel",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of HTTPoison for making HTTP requests"
    ],
    "need": "Ensure data confidentiality and integrity during transmission",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The below Elixir code uses HTTPoison to send a HTTP request. Data transmitted over HTTP can be intercepted and read by anyone on the network.",
        "text": "defmodule MyApp.Client do\n def send_request(data) do\n HTTPoison.post(\"http://example.com\", data)\n end\nend"
      },
      "secure_code_example": {
        "description": "The below Elixir code modifies the original to use HTTPS, ensuring that data is encrypted during transmission.",
        "text": "defmodule MyApp.Client do\n def send_request(data) do\n HTTPoison.post(\"https://example.com\", data)\n end\nend"
      },
      "steps": [
        "Replace all HTTP URLs with their HTTPS counterparts.",
        "If the server does not support HTTPS, configure it to do so.",
        "If you do not control the server, request that the server owner enables HTTPS."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "020",
    "title": "Non-encrypted Confidential Information",
    "context": [
      "Usage of Elixir (version 1.11 and above) for building scalable and concurrent applications",
      "Usage of File module for file handling"
    ],
    "need": "Protect sensitive information from unauthorized access",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The below Elixir code writes confidential information into a file without any encryption. This makes it readable for anyone who can gain access to the file.",
        "text": "defmodule MyApp.Data do\n def write_to_file(data) do\n File.write(\"/path/to/file\", data)\n end\nend"
      },
      "secure_code_example": {
        "description": "The below Elixir code uses AES encryption (via the :crypto module) to encrypt the data before writing it to a file. This ensures that even if someone gains access to the file, they can't read the data without the encryption key.",
        "text": "defmodule MyApp.Data do\n def write_to_file(data, key) do\n {:ok, iv} = :crypto.strong_rand_bytes(16)\n {:ok, cipher} = :crypto.block_encrypt(:aes_cbc128, key, iv, data)\n encrypted_data = iv <> cipher\n File.write(\"/path/to/file\", encrypted_data)\n end\nend"
      },
      "steps": [
        "Make use of the :crypto module for encryption purposes.",
        "Generate a strong encryption key and keep it secure.",
        "Encrypt sensitive data using the encryption key before storing or transmitting it.",
        "When retrieving the data, make sure to decrypt it using the same encryption key."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "019",
    "title": "Administrative Credentials Stored in Cache Memory",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of ETS for caching"
    ],
    "need": "Prevent unauthorized access to administrative credentials",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the below code, admin credentials are stored directly into the Elixir's ETS (Erlang Term Storage) which acts as in-memory store. If an attacker manages to dump the ETS table, they can gain access to sensitive data.",
        "text": "defmodule MyApp.Cache do\n def store_credentials(username, password) do\n :ets.new(:creds, [:public, :named_table])\n :ets.insert(:creds, {username, password})\n end\nend"
      },
      "secure_code_example": {
        "description": "In the below secure code, the admin credentials are hashed before being stored into the ETS. This means even if an attacker dumps the ETS table, they cannot gain access to the actual admin credentials.",
        "text": "defmodule MyApp.Cache do\n def store_credentials(username, password) do\n hashed_password = Bcrypt.hashpwsalt(password)\n :ets.new(:creds, [:public, :named_table])\n :ets.insert(:creds, {username, hashed_password})\n end\nend"
      },
      "steps": [
        "Install the Comeonin library for password hashing: mix deps.get comeonin.",
        "Hash sensitive data before storing them in cache or memory.",
        "Avoid storing sensitive information in plain text.",
        "Ensure secure configuration of cache or memory storage."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "017",
    "title": "Sensitive Information Sent Insecurely",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix web framework for building scalable and fault-tolerant web applications"
    ],
    "need": "Secure transfer of sensitive data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code example, the server sends sensitive information (user credentials) as GET parameters. These parameters are included in the URL and can be easily intercepted by malicious parties. This puts the user's credentials at risk of being compromised.",
        "text": "def login(conn, %{\"username\" => username, \"password\" => password}) do\n  redirect(conn, to: \"/home?username=#{username}&password=#{password}\")\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, sensitive information (user credentials) is stored in the session instead of being sent as GET parameters. This prevents the sensitive information from being included in the URL and therefore reduces the risk of it being intercepted by malicious parties.",
        "text": "def login(conn, %{\"username\" => username, \"password\" => password}) do\n  # store the username and password in the session\n  conn\n  |> put_session(:username, username)\n  |> put_session(:password, password)\n  |> redirect(to: \"/home\")\nend"
      },
      "steps": [
        "Instead of sending sensitive information as GET parameters, send them as POST parameters.",
        "Update the routes and the form to use the POST method instead of GET.",
        "Modify the function to accept POST parameters instead of GET parameters.",
        "Test the changes to make sure everything works as expected."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "016",
    "title": "Insecure Encryption Algorithm - SSL/TLS",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Cowboy for HTTP request and response handling",
      "Usage of Plug package for building web applications in Elixir"
    ],
    "need": "Secure data transfer between client and server",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code example, the server configuration allows for the usage of insecure TLS protocol versions ('tlsv1' and 'tlsv1.1'). These older versions of TLS are known to have several security vulnerabilities that can be exploited to intercept and decrypt the communication between the client and the server.",
        "text": "config :my_app, MyApp.Endpoint,\n  https: [\n    port: 4001,\n    cipher_suite: :strong,\n    honor_cipher_order: true,\n    versions: [:'tlsv1', :'tlsv1.1']\n  ]"
      },
      "secure_code_example": {
        "description": "In the secure code example, the server configuration only allows the use of secure TLS protocol versions (TLSv1.2 and TLSv1.3). This ensures that all the communication between the client and the server is encrypted using a secure encryption algorithm and prevents potential interception and decryption.",
        "text": "config :my_app, MyApp.Endpoint,\n  https: [\n    port: 4001,\n    cipher_suite: :strong,\n    honor_cipher_order: true,\n    versions: [:'tlsv1.2', :'tlsv1.3']\n  ]"
      },
      "steps": [
        "Update the server configuration to only allow secure TLS protocol versions (TLSv1.2 or TLSv1.3).",
        "Test the server after the changes to make sure that everything works as expected.",
        "Regularly update and patch the server software to make sure that it's up to date with the latest security standards."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "015",
    "title": "Insecure Authentication Method - Basic",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Guardian library for JWT authentication"
    ],
    "need": "Securely authenticate user requests",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code example, the server uses Basic Authentication, where the user credentials are Base64-encoded but not encrypted, and transmitted over the network. This can be easily decoded and allows an attacker to intercept the user's credentials.",
        "text": "def login(conn, %{\"username\" => username, \"password\" => password}) do\n  user = Repo.get_by(User, username: username)\n  if user && Bcrypt.checkpw(password, user.password_hash) do\n    {:ok, token, _claims} = BasicAuthToken.encode_and_sign(user.username)\n    conn\n    |> put_resp_header(\"authorization\", \"Basic #{token}\")\n    |> send_resp(:ok, \"Logged in\")\n  else\n    send_resp(conn, :unauthorized, \"Incorrect username or password\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the server uses Bearer Authentication with a hashed token. The server generates a JWT token for the authenticated user and returns it in the Authorization header. This ensures the user's sensitive credentials are not transmitted over the network.",
        "text": "def login(conn, %{\"username\" => username, \"password\" => password}) do\n  user = Repo.get_by(User, username: username)\n  if user && Bcrypt.checkpw(password, user.password_hash) do\n    {:ok, jwt, _full_claims} = Guardian.encode_and_sign(user, :token)\n    conn\n    |> put_resp_header(\"authorization\", \"Bearer #{jwt}\")\n    |> send_resp(:ok, \"Logged in\")\n  else\n    send_resp(conn, :unauthorized, \"Incorrect username or password\")\n  end\nend"
      },
      "steps": [
        "Implement Bearer authentication using hashed tokens instead of transmitting sensitive user credentials.",
        "Use HTTPS for all sensitive communications to prevent the interception of data.",
        "Consider other authentication mechanisms like OAuth or JWT for even better security."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "014",
    "title": "Insecure Functionality",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building scalable web applications"
    ],
    "need": "Prevent unauthorized password change",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code example, the server changes the user's password without verifying the security code provided by the user. This allows an attacker to change a user's password without the correct security code.",
        "text": "def change_password(conn, %{'security_code' => _security_code, 'new_password' => new_password}) do\n  user = conn.assigns.current_user\n  user = User.changeset(user, %{password: new_password})\n  Repo.update!(user)\n  send_resp(conn, :ok, 'Password updated')\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the server first checks if the provided security code matches the one stored in the database for that user. If it does not, the server returns an 'Unauthorized' response. This ensures that an attacker can't change a user's password without the correct security code.",
        "text": "def change_password(conn, %{'security_code' => security_code, 'new_password' => new_password}) do\n  user = conn.assigns.current_user\n  if check_security_code(user, security_code) do\n    user = User.changeset(user, %{password: new_password})\n    Repo.update!(user)\n    send_resp(conn, :ok, 'Password updated')\n  else\n    send_resp(conn, :unauthorized, 'Incorrect security code')\n  end\nend"
      },
      "steps": [
        "Always validate the security code on the server-side before changing the password.",
        "Ensure that the security code expires after a certain time period to limit the time window for an attack.",
        "Lock the account or require additional verification if there are too many failed attempts to enter the security code."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "013",
    "title": "Insecure Object Reference",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Ecto ORM for data access"
    ],
    "need": "Prevent unauthorized access to user data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The insecure code example takes an 'id' parameter from the incoming request and directly uses it to fetch the user data from the database. This means that an attacker can modify the 'id' in the request to access data of any user.",
        "text": "def show(conn, %{'id' => id}) do\n  user = Repo.get(User, id)\n  render(conn, 'show.json', user: user)\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the server first checks whether the authenticated user's 'id' matches the 'id' in the request. If it does not, the server returns a '403 Forbidden' response. This ensures that users can only access their own data.",
        "text": "def show(conn, %{'id' => id}) do\n  if conn.assigns.current_user.id == id do\n    user = Repo.get(User, id)\n    render(conn, 'show.json', user: user)\n  else\n    send_resp(conn, :forbidden, 'Access denied')\n  end\nend"
      },
      "steps": [
        "Avoid using direct references to internal objects.",
        "Use session-based user authentication and associate this with the users' actions.",
        "Instead of using the user-provided 'id', use the 'id' associated with the authenticated session."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "011",
    "title": "Use of Software with Known Vulnerabilities",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of mix for dependency management"
    ],
    "need": "Prevent exploitation of known vulnerabilities in dependencies",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The insecure code example demonstrates the use of an outdated and potentially vulnerable version of the Phoenix framework (1.2.1), as specified in the mix.exs file in an Elixir project. Known vulnerabilities exist in this version of the Phoenix framework that can be exploited by attackers.",
        "text": "defp deps do\n  [{:phoenix, '~> 1.2.1'}]\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the Phoenix framework has been updated to a more recent and secure version (1.5.7). This version does not have the vulnerabilities present in the older version.",
        "text": "defp deps do\n  [{:phoenix, '~> 1.5.7'}]\nend"
      },
      "steps": [
        "Identify the dependencies and their versions that are known to have vulnerabilities.",
        "Search for the latest versions or the safe versions of those dependencies.",
        "Update the dependency specifications in your mix.exs file.",
        "Run 'mix deps.update --all' to update the dependencies."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "009",
    "title": "Sensitive Information in Source Code",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of generic packages or server types"
    ],
    "need": "Avoid exposure of sensitive data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The source code contains sensitive data, including a password and an API key, hardcoded in the code. This is a bad practice as it exposes sensitive information directly in the source code, making it accessible to anyone who can access this code.",
        "text": "defmodule MySensitiveInfo do\n  @password 'sensitive_password'\n  @api_key 'API_KEY'\nend"
      },
      "secure_code_example": {
        "description": "The revised code now retrieves sensitive data from environment variables, which are set outside of the application and not exposed in the source code. This avoids the direct exposure of sensitive information in the source code.",
        "text": "defmodule MySensitiveInfo do\n  @password System.get_env('PASSWORD')\n  @api_key System.get_env('API_KEY')\nend"
      },
      "steps": [
        "Delete all hardcoded sensitive information from the source code.",
        "Change all affected access credentials where these have been exposed.",
        "Remove sensitive information from git logs if the code has been previously committed.",
        "Use environment variables or a secure key vault service to manage sensitive data."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "006",
    "title": "Authentication Mechanism Absence or Evasion Vulnerability",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of plain maps for user management"
    ],
    "need": "Prevent unauthorized access to protected resources",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code defines a user system using a struct User, which holds an id and data. The function 'access_data' allows any user to access data without any form of authentication. Therefore, any person can create a user struct and view sensitive data.",
        "text": "defmodule User do\n  defstruct [:id, :data]\nend\n\nuser = %User{id: 1, data: 'secret'}\n\ndef access_data(user) do\n  IO.puts user.data\nend"
      },
      "secure_code_example": {
        "description": "The revised code introduces a secure authentication mechanism. The User struct now includes 'username' and 'password' fields. The 'login' function checks these credentials and returns a session if they are correct. The 'access_data' function now requires a successful login before accessing data, effectively preventing unauthorized access.",
        "text": "defmodule User do\n  defstruct [:id, :username, :password, :data]\nend\n\nuser = %User{id: 1, username: 'user1', password: 'pass1', data: 'secret'}\n\ndef login(user, username, password) do\n  if user.username == username and user.password == password do\n    {:ok, user}\n  else\n    {:error, 'Incorrect username or password.'}\n  end\nend\n\ndef access_data(user, username, password) do\n  case login(user, username, password) do\n    {:ok, user} -> IO.puts user.data\n    _ -> IO.puts 'Access denied.'\n  end\nend"
      },
      "steps": [
        "Introduce a secure authentication process: Implement a login mechanism that requires a username and password to create a user session.",
        "Ensure critical functionality resources are protected by this authentication process.",
        "Ensure every request for these resources checks for an active and authenticated user session."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "005",
    "title": "Privilege Escalation Vulnerability",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of plain maps for role management"
    ],
    "need": "Prevent unauthorized access to information and operations",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code represents a user system with different roles. An Elixir struct User is defined which holds an id, role, and data. However, due to the lack of a proper access control mechanism, a malicious user can easily manipulate their role in the User struct and escalate their privileges. For example, a user can change their role to 'admin' and gain access to sensitive data or actions they are not supposed to.",
        "text": "defmodule User do\n  defstruct [:id, :role, :data]\nend\n\nuser = %User{id: 1, role: :admin, data: 'secret'}\n\ndef execute_action(user, action) do\n  if user.role == :admin do\n    IO.puts 'Admin action executed!'\n  else\n    IO.puts 'User action executed!'\n  end\nend"
      },
      "secure_code_example": {
        "description": "This revised code introduces a secure token system for role management. It removes the 'role' field from the User struct and instead uses a list of admin user IDs. Also, the user struct now includes a token generated using :crypto.strong_rand_bytes. The token is used for identifying the user instead of the id, thus making it harder to manipulate. The function 'execute_action' checks if the user's id is in the list of admins before allowing an admin action.",
        "text": "defmodule User do\n  defstruct [:id, :token, :data]\nend\n\nadmins = [1, 2, 3]\n\nuser = %User{id: 1, token: :crypto.strong_rand_bytes(16), data: 'secret'}\n\ndef execute_action(user, action) do\n  if user.id in admins do\n    IO.puts 'Admin action executed!'\n  else\n    IO.puts 'User action executed!'\n  end\nend"
      },
      "steps": [
        "Implement proper access control: Ensure the role cannot be easily manipulated by a user.",
        "Roles should be controlled with users tokens or the exposure of user ID should be avoided.",
        "Encrypt sensitive data and ensure it cannot be accessed without proper authorization."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "004",
    "title": "Remote Command Execution Vulnerability",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of os.cmd for executing shell commands"
    ],
    "need": "Prevent unauthorized code or command execution",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this code, the function 'run_command' takes user input and directly interpolates it into an OS command to be executed. This is a vulnerability because an attacker could manipulate the input to execute arbitrary commands on the OS, leading to unauthorized code execution. The function is not validating or sanitizing the input before use, which makes it susceptible to the vulnerability.",
        "text": "def run_command(input) do\n  :os.cmd(\"echo #{input}\")\nend"
      },
      "secure_code_example": {
        "description": "This code mitigates the vulnerability by first sanitizing the user input, removing or substituting characters that could modify the OS command. Then it verifies if the sanitized_input still is a binary string. If it isn't, it returns an error. Only if the input passes these checks, it's then used in the OS command.",
        "text": "def run_command(input) do\n  sanitized_input = String.replace(input, ~r/[\\n\\r\\$()]/, \"\")\n  case sanitized_input do\n    ^sanitized_input when is_binary(sanitized_input) -> :os.cmd('echo ' <> sanitized_input)\n    _ -> {:error, \"Invalid input\"}\n  end\nend"
      },
      "steps": [
        "Validate user inputs: Check if the input is as expected. This could be a format, type, length, range, or a set of permitted values.",
        "Sanitize user inputs: Remove or substitute harmful patterns in the input.",
        "Instead of using external processes like :os.cmd, try using standard library calls to recreate the desired functionality."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "137",
    "title": "Insecure or unset HTTP headers - X-Permitted-Cross-Domain-Policies",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of X-Permitted-Cross-Domain-Policies header management"
    ],
    "need": "To prevent harmful requests from Adobe Flash or PDF documents",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code snippet, the application is lacking the X-Permitted-Cross-Domain-Policies header.",
        "text": "defmodule Vulnerable do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    conn\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code snippet, the application is setting the X-Permitted-Cross-Domain-Policies header to 'none'.",
        "text": "defmodule Secure do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    conn\n    |> put_resp_header(\"x-permitted-cross-domain-policies\", \"none\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "steps": [
        "Unless the application requires Adobe products, set the X-Permitted-Cross-Domain-Policies to none in the server responses."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "135",
    "title": "Insecure or unset HTTP headers - X-XSS Protection",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of X-XSS Protection header management for preventing cross-site scripting attacks"
    ],
    "need": "To prevent the increase in the chance of exploiting a stored XSS",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code snippet, the application is using the deprecated X-XSS Protection header.",
        "text": "defmodule Vulnerable do\n  use Plug.Router\n  plug :put_secure_browser_headers\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    conn\n    |> put_resp_header(\"x-xss-protection\", \"1; mode=block\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code snippet, the application is using CSP (Content Security Policy) header instead of the deprecated X-XSS Protection header.",
        "text": "defmodule Secure do\n  use Plug.Router\n  plug :put_secure_browser_headers\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    conn\n    |> put_resp_header(\"content-security-policy\", \"default-src 'self'\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "steps": [
        "Disable the X-XSS Protection filter in the server responses.",
        "Instead, define security policies using CSP (Content Security Policy) header."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "134",
    "title": "Insecure or unset HTTP headers - CORS",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug, Cowboy, and CorsPlug for building a web server in Elixir",
      "Usage of CORS headers management for handling cross-origin resource sharing"
    ],
    "need": "To prevent the inclusion of resources from untrusted origins",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code snippet, the CORS policy is set to '*', allowing any domain to share resources.",
        "text": "defmodule Vulnerable do\n  use Plug.Router\n  plug CORSPlug, origin: \"*\"\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    send_resp(conn, 200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code snippet, the CORS policy is explicitly set to a specific domain, preventing resource sharing with untrusted domains.",
        "text": "defmodule Secure do\n  use Plug.Router\n  plug CORSPlug, origin: \"https://trusted.domain.com\"\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    send_resp(conn, 200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "steps": [
        "Remove the wildcard (*) from the CORS policy.",
        "Explicitly define the trusted origins for the application resources."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "132",
    "title": "Insecure or unset HTTP headers - X-Content-Type-Options",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of HTTP headers management"
    ],
    "need": "To prevent MIME sniffing attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code snippet, the server response doesn't include the X-Content-Type-Options header, making the application vulnerable to MIME sniffing attacks.",
        "text": "defmodule Vulnerable do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    conn\n    |> put_resp_content_type(\"text/html\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code snippet, the server response includes the X-Content-Type-Options header with a value of nosniff, preventing MIME type sniffing by the browser.",
        "text": "defmodule Secure do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    conn\n    |> put_resp_content_type(\"text/html\")\n    |> put_resp_header(\"x-content-type-options\", \"nosniff\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "steps": [
        "Set the X-Content-Type-Options header in the server responses.",
        "Set this header to nosniff to disable MIME type sniffing."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "131",
    "title": "Insecure or unset HTTP headers - Strict Transport Security",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of HTTP headers management"
    ],
    "need": "To enforce the use of HTTPS to prevent confidential information from being sent over insecure channels",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code snippet, the server response doesn't include the Strict-Transport-Security header, making the application vulnerable to attacks such as MiTM.",
        "text": "defmodule Vulnerable do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    conn\n    |> put_resp_content_type(\"text/html\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code snippet, the server response includes the Strict-Transport-Security header with a max-age of one year, ensuring that the browser only communicates with the server over HTTPS for the specified time.",
        "text": "defmodule Secure do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"\" do\n    conn\n    |> put_resp_content_type(\"text/html\")\n    |> put_resp_header(\"strict-transport-security\", \"max-age=31536000\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "steps": [
        "Set the Strict-Transport-Security header in the server responses.",
        "Set the max-age of this header to at least 31536000 (one year)."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "130",
    "title": "Insecurely generated cookies - Secure",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of secure cookie handling for session management"
    ],
    "need": "To protect sensitive cookies from being sent over insecure channels",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code snippet, a cookie is being set without the Secure attribute, making it susceptible to being sent over insecure channels.",
        "text": "defmodule Vulnerable do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"\" do\n    conn\n    |> put_resp_cookie(\"sensitive_info\", \"some_value\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code snippet, the cookie is set with the Secure attribute, ensuring it will only be sent over secure channels.",
        "text": "defmodule Secure do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"\" do\n    conn\n    |> put_resp_cookie(\"sensitive_info\", \"some_value\", secure: true)\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "steps": [
        "Set the Secure attribute while setting the cookies.",
        "Only send cookies over HTTPS."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "129",
    "title": "Insecurely generated cookies - SameSite",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of secure cookie handling"
    ],
    "need": "To protect cookies from being sent along with cross-site requests",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code snippet, a cookie is being set without the SameSite attribute, making it susceptible to being sent along with cross-site requests.",
        "text": "defmodule Vulnerable do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"\" do\n    conn\n    |> put_resp_cookie(\"sensitive_info\", \"some_value\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code snippet, the cookie is set with the SameSite attribute set to 'Strict', protecting it from being sent along with cross-site requests.",
        "text": "defmodule Secure do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"\" do\n    conn\n    |> put_resp_cookie(\"sensitive_info\", \"some_value\", same_site: \"Strict\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "steps": [
        "Set the SameSite attribute to 'Strict' or 'Lax' while setting the cookies.",
        "Do not store sensitive information in cookies if possible."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "128",
    "title": "Insecurely generated cookies - HttpOnly",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of secure cookie handling for session management"
    ],
    "need": "To protect cookies from being accessed by client-side scripts",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code snippet, a cookie is being set without the HttpOnly attribute, making it susceptible to being read by client-side scripts.",
        "text": "defmodule Vulnerable do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"\" do\n    conn\n    |> put_resp_cookie(\"sensitive_info\", \"some_value\")\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code snippet, the cookie is set with the HttpOnly attribute set to true, protecting it from being read by client-side scripts.",
        "text": "defmodule Secure do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"\" do\n    conn\n    |> put_resp_cookie(\"sensitive_info\", \"some_value\", http_only: true)\n    |> send_resp(200, \"OK\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Not found\")\n  end\nend"
      },
      "steps": [
        "Set the HttpOnly attribute to true while setting the cookies.",
        "Do not store sensitive information in cookies if possible."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "127",
    "title": "Lack of data validation - Type confusion",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of input validation for data validation and sanitization",
      "Usage of type casting for ensuring type safety in TypeScript"
    ],
    "need": "Prevent misinterpretation of data types and code injection",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code is vulnerable because it directly uses the user input without validating its type. This can lead to type confusion and potentially code execution.",
        "text": "defmodule Vulnerable do\n  def process(input) do\n    {:ok, number} = Integer.parse(input)\n    IO.puts(number)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This Elixir code is safe because it validates the type of the input data before using it, preventing type confusion and potential code execution.",
        "text": "defmodule Safe do\n  def process(input) do\n    case Integer.parse(input) do\n      :error -> IO.puts('Invalid input')\n      {:ok, number} -> IO.puts(number)\n    end\n  end\nend"
      },
      "steps": [
        "Always validate the type of data you receive from user input.",
        "Cast the data to the desired type before using it."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "124",
    "title": "Race Condition",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of Concurrency for parallel execution of tasks",
      "Usage of process synchronization for managing concurrent execution"
    ],
    "need": "Prevent arbitrary overwriting, deletion or reading of files due to incorrect input sequencing",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code is vulnerable because it does not handle the concurrent operations properly, leading to a race condition where the file might be read and deleted by two different processes at the same time.",
        "text": "defmodule RaceCondition do\n  def process(file) do\n    Task.async(fn -> File.read!(file) end)\n    Task.async(fn -> File.rm!(file) end)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This Elixir code is safe because it ensures that the reading and deletion of a file are performed in a single process, preventing a race condition.",
        "text": "defmodule RaceCondition do\n  def process(file) do\n    File.read!(file)\n    File.rm!(file)\n  end\nend"
      },
      "steps": [
        "Ensure that operations that should be atomic are performed in a single process to prevent race conditions.",
        "Handle concurrency properly to prevent the interleaving of operations."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "123",
    "title": "Local File Inclusion",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications with Elixir",
      "Usage of file handling for reading, writing, and manipulating files",
      "Usage of path sanitization for preventing directory traversal attacks"
    ],
    "need": "Prevent reading or executing server files through relative path manipulation",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code is vulnerable because it does not sanitize the file path provided by the user, allowing local file inclusion attacks.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/file\" do\n    file_path = conn.params[\"path\"]\n    file_contents = File.read!(file_path)\n    send_resp(conn, 200, file_contents)\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Oops, not found!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This Elixir code is safe because it includes validation and sanitization of the file path. It checks that the file path is within the expected directory and does not contain relative path characters.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/file\" do\n    file_path = conn.params[\"path\"]\n    sanitized_path = Path.expand(file_path, \"/expected_directory\")\n    if String.starts_with?(sanitized_path, \"/expected_directory\") do\n      file_contents = File.read!(sanitized_path)\n      send_resp(conn, 200, file_contents)\n    else\n      send_resp(conn, 403, \"Access Denied\")\n    end\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Oops, not found!\")\n  end\nend"
      },
      "steps": [
        "Sanitize the file path to remove any relative path characters.",
        "Ensure that the file path is within the expected directory."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "121",
    "title": "HTTP Parameter Pollution",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications in Elixir",
      "Usage of HTTP parameter validation",
      "Usage of input sanitization for protecting against malicious user input"
    ],
    "need": "Prevent unexpected behavior due to injection of extra HTTP parameters",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code is vulnerable because it does not perform validation and sanitization on the incoming parameters. This allows injection of extra parameters which can cause unexpected behavior.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    send_resp(conn, 200, \"Hello, #{conn.params[\"name\"]}\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Oops, not found!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This Elixir code is safe because it includes validation and sanitization of incoming parameters. It checks that the 'name' parameter exists and removes any potential harmful data.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    name = Map.get(conn.params, \"name\", \"\")\n    name = String.replace(name, \"<>\", \"\")\n    send_resp(conn, 200, \"Hello, #{name}\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Oops, not found!\")\n  end\nend"
      },
      "steps": [
        "Validate the incoming parameters to ensure they are as expected.",
        "Sanitize the parameters to remove any potential harmful data."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "115",
    "title": "Security Controls Bypass or Absence",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Cowboy for building web applications with Elixir",
      "Handling high incoming requests",
      "Usage of API abuse detection and prevention techniques"
    ],
    "need": "Prevent denial of service or system overloading by limiting request rate",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code is vulnerable because it exposes an API endpoint without any rate limiting. This allows a host to send unlimited requests.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Oops, not found!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This Elixir code is safe because it includes 'plug_attack' for rate limiting. The plug is configured to limit requests to 100 per minute from a single IP address.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug PlugAttack\n\n  plug_attack_handler do\n    PlugAttack.Storage.Memory.set_rules([%{bans: 100, period: 60_000}])\n  end\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\n\n  match _ do\n    send_resp(conn, 404, \"Oops, not found!\")\n  end\nend"
      },
      "steps": [
        "Add a rate limiting package, such as 'plug_attack'.",
        "Configure the rate limit rules in the 'plug_attack' config."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "113",
    "title": "Improper Type Assignation",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of dynamically typed language"
    ],
    "need": "To prevent errors and potential security issues caused by assigning the wrong type of value to a variable",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code is vulnerable because it assigns a string to a variable that is expected to be a number. If a string is supplied instead of a number, an error will occur when trying to perform an arithmetic operation.",
        "text": "defmodule VulnerableCode do\n  def add_one(input) do\n    input + 1\n  end\nend"
      },
      "secure_code_example": {
        "description": "This Elixir code is safe because it checks the type of the input before performing the arithmetic operation. If the input is not a number, an error message is returned instead of causing a runtime error.",
        "text": "defmodule SecureCode do\n  def add_one(input) when is_number(input) do\n    input + 1\n  end\n\n  def add_one(_input) do\n    {:error, \"Input must be a number\"}\n  end\nend"
      },
      "steps": [
        "Perform type checking before using the variable.",
        "Handle the error case when the value is not of the expected type."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "108",
    "title": "Improper Control of Interaction Frequency",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir Plug for handling HTTP requests and protecting against attacks",
      "No rate limiting for API requests"
    ],
    "need": "To prevent server saturation and potential Denial of Service (DoS) attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code exposes an API endpoint without any rate limiting, allowing clients to send as many requests as they want in a short period of time. This makes the application vulnerable to DoS attacks and log flooding.",
        "text": "defmodule VulnerableApp.ApiController do\n  use Plug.Router\n\n  def index(conn, _params) do\n    # API logic here\n    send_resp(conn, 200, \"OK\")\n  end\n\n  plug :match\n  plug :dispatch\n\n  get \"/\", do: index(conn, params)\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code uses the 'plug_attack' library to implement rate limiting on the API endpoint. This prevents clients from sending too many requests in a short period of time, protecting the application from DoS attacks and log flooding.",
        "text": "defmodule SecureApp.ApiController do\n  use Plug.Router\n  use PlugAttack\n\n  plug PlugAttack.Blocker, otp_app: :my_app, name: :api\n\n  def index(conn, _params) do\n    # API logic here\n    send_resp(conn, 200, \"OK\")\n  end\n\n  plug :match\n  plug :dispatch\n\n  get \"/\", do: index(conn, params)\n\n  defoverridable [block: 2]\n  def block(conn, _opts), do: send_resp(conn, 429, \"Too Many Requests\")\nend"
      },
      "steps": [
        "Use the 'plug_attack' library or similar to implement rate limiting on your API endpoints.",
        "Define rate limit rules based on your application's requirements and capacity.",
        "Apply these rules to your API endpoints."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "102",
    "title": "Email Uniqueness Not Properly Verified",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir Phoenix Ecto for building web applications with a functional programming language and a reliable database layer",
      "User registration with email verification"
    ],
    "need": "To prevent multiple account creation with the same email address",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code accepts the email from an untrusted source and creates a user account without properly validating the uniqueness of the email address. This allows an attacker to create multiple accounts with the same email.",
        "text": "defmodule VulnerableApp.UserController do\n  use VulnerableApp.Web, :controller\n\n  def register(conn, %{\"email\" => email, \"password\" => password}) do\n    User.changeset(%User{}, %{email: email, password: password}) |> Repo.insert()\n    send_resp(conn, 200, \"User registered successfully\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code normalizes the email address by removing any characters after and including the '+' sign in the local part, and then checks the uniqueness of the email address before creating a user account. This prevents an attacker from creating multiple accounts with the same email.",
        "text": "defmodule SecureApp.UserController do\n  use SecureApp.Web, :controller\n\n  def register(conn, %{\"email\" => email, \"password\" => password}) do\n    normalized_email = normalize_email(email)\n    changeset = User.changeset(%User{}, %{email: normalized_email, password: password}) |> Ecto.Changeset.unique_constraint(:email)\n    case Repo.insert(changeset) do\n      {:ok, _} -> send_resp(conn, 200, \"User registered successfully\")\n      {:error, _} -> send_resp(conn, 400, \"Email already registered\")\n    end\n  end\n\n  defp normalize_email(email) do\n    [local, domain] = String.split(email, \"@\")\n    local = String.split(local, \"+\") |> List.first()\n    local <> \"@\" <> domain\n  end\nend"
      },
      "steps": [
        "Use Ecto's `unique_constraint` function in the changeset to enforce uniqueness at the database level.",
        "Normalize the email address before saving it to the database. Remove any characters after and including the '+' sign in the local part of the email address."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "098",
    "title": "External Control of File Name or Path",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir Phoenix Plug for building web applications",
      "Usage of file-upload handling for untrusted sources"
    ],
    "need": "To prevent unauthorized access and alteration of system files",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code receives an uploaded file and its filename from an untrusted source and directly uses the given filename to save the file. This leaves the application open to manipulation from an attacker.",
        "text": "defmodule VulnerableApp.FileUploadController do\n  use VulnerableApp.Web, :controller\n\n  def upload(conn, %{\"file\" => file, \"filename\" => filename}) do\n    File.write(filename, file)\n    send_resp(conn, 200, \"File uploaded successfully\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code receives an uploaded file from an untrusted source, generates a new filename and saves the file to a specified directory. This prevents an attacker from manipulating the file name or path.",
        "text": "defmodule SecureApp.FileUploadController do\n  use SecureApp.Web, :controller\n\n  def upload(conn, %{\"file\" => file}) do\n    filename = generate_filename()\n    File.write(\"uploads/\" <> filename, file)\n    send_resp(conn, 200, \"File uploaded successfully\")\n  end\n\n  defp generate_filename() do\n    :crypto.strong_rand_bytes(20) |> Base.url_encode64()\n  end\nend"
      },
      "steps": [
        "Use a library such as `plug` to handle file uploads securely.",
        "Do not use the original filename from the user. Generate a new filename on the server side.",
        "Restrict the storage of uploaded files to a specific directory."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "096",
    "title": "Insecure Deserialization",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir Phoenix for building web applications",
      "Usage of serialization/deserialization libraries for handling serialized objects from untrusted sources"
    ],
    "need": "To protect against unauthorized control of application execution flow",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code deserializes an incoming object from an untrusted source without validating or casting it. This leaves the application open to manipulation from an attacker.",
        "text": "defmodule VulnerableApp.WebController do\n  use VulnerableApp.Web, :controller\n\n  def deserialize(conn, _params) do\n    {:ok, params} = Poison.decode(conn.params[\"payload\"])\n    process_params(params)\n  end\n\n  defp process_params(params) do\n    # Handle params...\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code deserializes an incoming object from an untrusted source but first validates it. This prevents an attacker from manipulating the execution flow of the application.",
        "text": "defmodule SecureApp.WebController do\n  use SecureApp.Web, :controller\n\n  def deserialize(conn, _params) do\n    case Jason.decode(conn.params[\"payload\"]) do\n      {:ok, params} when is_map(params) ->\n        process_params(params)\n      _ ->\n        {:error, \"Invalid payload\"}\n    end\n  end\n\n  defp process_params(params) do\n    # Handle params...\n  end\nend"
      },
      "steps": [
        "Use a library such as `jason` to validate the structure of the incoming serialized object.",
        "Only deserialize the object if it meets the expected properties."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "095",
    "title": "Data Uniqueness Not Properly Verified",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir Ecto for database query and manipulation",
      "Usage of unique tokens for database record identification"
    ],
    "need": "To ensure that sensitive data intended for single use cannot be reused or regenerated.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code creates a user record with a unique token but does not validate the uniqueness of the token. This means that an attacker could create multiple users with the same token, leading to potential security issues.",
        "text": "defmodule VulnerableApp.Accounts do\n  alias VulnerableApp.Repo\n  alias VulnerableApp.Accounts.User\n\n  def create_user(attrs \\ %{}) do\n    %User{}\n    |> User.changeset(attrs)\n    |> Repo.insert()\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code creates a user record with a unique token and validates the uniqueness of the token. This prevents an attacker from creating multiple users with the same token.",
        "text": "defmodule SecureApp.Accounts do\n  alias SecureApp.Repo\n  alias SecureApp.Accounts.User\n\n  def create_user(attrs \\ %{}) do\n    %User{}\n    |> User.changeset(attrs)\n    |> Ecto.Changeset.unique_constraint(:token)\n    |> Repo.insert()\n  rescue\n    Ecto.ConstraintError -> {:error, \"Token must be unique\"}\n  end\nend"
      },
      "steps": [
        "Use Ecto's unique constraint feature to ensure that the token is unique across all users.",
        "Handle Ecto's unique violation error when inserting a new user."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "090",
    "title": "CSV injection",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir CSV library for handling CSV files",
      "Exporting user-provided data to CSV files"
    ],
    "need": "To protect against malicious injection of formulas into fields that are exported as part of CSV files and potentially interpreted by Excel or other spreadsheet software.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code writes user-provided data directly to a CSV file without sanitization. This allows a user to inject a formula, which could be executed when the CSV file is opened in a spreadsheet software.",
        "text": "defmodule VulnerableApp do\n  def create_csv(data, filename) do\n    {:ok, file} = File.open(filename, [:write])\n    Enum.each(data, fn row ->\n      IO.write(file, Enum.join(row, \",\") <> \"\\n\")\n    end)\n    File.close(file)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code sanitizes user-provided data by prepending any field starting with '=', '+', '-', '@' with a single quote, before writing it to a CSV file. This prevents any injected formulas from being interpreted by spreadsheet software.",
        "text": "defmodule SecureApp do\n  def create_csv(data, filename) do\n    {:ok, file} = File.open(filename, [:write])\n    Enum.each(data, fn row ->\n      sanitized_row = Enum.map(row, &sanitize_field/1)\n      IO.write(file, Enum.join(sanitized_row, \",\") <> \"\\n\")\n    end)\n    File.close(file)\n  end\n\n  defp sanitize_field(field) when is_binary(field) do\n    if String.starts_with?(field, [\"=\", \"+\", \"-\", \"@\"]) do\n      \"'\" <> field\n    else\n      field\n    end\n  end\n  defp sanitize_field(field), do: field\nend"
      },
      "steps": [
        "Sanitize user-provided data before exporting it to a CSV file.",
        "If the data includes numbers or strings that start with '=', '+', '-', '@', consider prepending the string with a single quote (') to prevent spreadsheet software from interpreting it as a formula."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "089",
    "title": "Lack of data validation - Trust boundary violation",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of user-provided data without validation"
    ],
    "need": "To prevent potential security vulnerabilities due to trusting and mixing untrusted data in the same data structure or structured message.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir code directly includes user-provided data in a structured message without any validation or sanitization. An attacker can potentially manipulate the message to introduce malicious payloads.",
        "text": "defmodule VulnerableApp do\n  def handle_request(params) do\n    {:ok, message} = build_message(params)\n    send_message(message)\n  end\n\n  defp build_message(params) do\n    {:ok, \"Hello #{params[:name]}, your account balance is #{params[:balance]}\"}\n  end\nend"
      },
      "secure_code_example": {
        "description": "This Elixir code validates and sanitizes user-provided data before including it in a structured message, thereby preventing potential injection attacks.",
        "text": "defmodule SecureApp do\n  def handle_request(params) do\n    sanitized_params = sanitize(params)\n    case validate(sanitized_params) do\n      :ok -> {:ok, message} = build_message(sanitized_params)\n               send_message(message)\n      {:error, reason} -> {:error, reason}\n    end\n  end\n\n  defp build_message(params) do\n    {:ok, \"Hello #{params[:name]}, your account balance is #{params[:balance]}\"}\n  end\nend"
      },
      "steps": [
        "Validate user-provided data before including it in structured messages or data structures.",
        "Sanitize user-provided data to remove any potentially malicious payloads.",
        "Consider using parameterized queries or prepared statements for database operations to prevent SQL Injection attacks."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "087",
    "title": "Account Lockout",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of user lockout feature for failed authentication attempts"
    ],
    "need": "To prevent potential denial of service for valid users via account lockouts.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code accepts user credentials and locks the user account after three failed login attempts. An attacker could exploit this by purposely failing login attempts for a targeted user, effectively locking them out of their account.",
        "text": "defmodule VulnerableApp do\n  def login(user, password) do\n    case authenticate(user, password) do\n      :ok -> {:ok, get_user(user)}\n      {:error, :invalid_credentials} -> update_failed_attempts(user)\n    end\n  end\n\n  defp update_failed_attempts(user) do\n    user\n    |> increment_failed_attempts()\n    |> case do\n      %{failed_attempts: 3} -> lock_account(user)\n      _ -> :ok\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code implements a progressive delay after each failed login attempt, slowing down potential brute force attacks without locking out legitimate users. It also sends a notification to the user when their account is locked, providing a way for legitimate users to unlock their account.",
        "text": "defmodule SecureApp do\n  def login(user, password) do\n    case authenticate(user, password) do\n      :ok -> {:ok, get_user(user)}\n      {:error, :invalid_credentials} -> update_failed_attempts(user)\n    end\n  end\n\n  defp update_failed_attempts(user) do\n    user\n    |> increment_failed_attempts()\n    |> case do\n      %{failed_attempts: 3} -> notify_user_and_lock_account(user)\n      _ -> :ok\n    end\n  end\nend"
      },
      "steps": [
        "Implement a delay after each failed authentication attempt, which increases with each attempt. This slows down brute force attacks without locking out legitimate users.",
        "Use a CAPTCHA after a certain number of failed attempts to prevent automated brute force attacks.",
        "Notify users via email or SMS when their account is locked out due to failed login attempts, and provide them with a way to unlock their account."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "083",
    "title": "XML injection (XXE)",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of sweet_xml for parsing and manipulating XML data",
      "Vulnerability: XML input parsing without proper sanitization"
    ],
    "need": "To prevent potential data exfiltration or remote command execution via XML input.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code accepts and parses XML input using the SweetXml library without validating or sanitizing the input. As a result, an attacker could inject malicious XML data.",
        "text": "defmodule VulnerableApp do\n  def parse(xml) do\n    xml\n    |> SweetXml.parse()\n    |> SweetXml.xpath(~x/data)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code properly sanitizes the XML input before parsing it and is configured to reject DTDs, mitigating the risk of XML injection attacks.",
        "text": "defmodule SecureApp do\n  def parse(xml) do\n    xml\n    |> sanitize_input()\n    |> SweetXml.parse()\n    |> SweetXml.xpath(~x/data)\n  end\n\n  defp sanitize_input(xml) do\n    # Add your sanitization logic here\n  end\nend"
      },
      "steps": [
        "Use a secure XML parser that is configured to reject DTDs (Document Type Definitions).",
        "Sanitize and validate all XML input to ensure it does not contain any unexpected or malicious data."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "076",
    "title": "Insecure session management",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug.Session for HTTP session management",
      "Usage of session token reuse in server even after user logout"
    ],
    "need": "To prevent unauthorized access and potential misuse of session tokens.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code sets up a session using Plug.Session. However, when a user logs out, their session is not properly invalidated, leaving it vulnerable to misuse.",
        "text": "defmodule VulnerableApp do\n  use Plug.Router\n\n  plug Plug.Session, store: :cookie\n\n  plug :match\n  plug :dispatch\n\n  get \"/logout\" do\n    conn\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Logged out!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code correctly invalidates the session when the user logs out, preventing further use of their session token.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n\n  plug Plug.Session, store: :cookie\n\n  plug :match\n  plug :dispatch\n\n  get \"/logout\" do\n    conn\n    |> delete_session(:user)\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Logged out!\")\n  end\nend"
      },
      "steps": [
        "When a user logs out, their session should be invalidated to prevent further use of their session token.",
        "This can be done using the Plug.Conn.delete_session/2 function, which removes the session data from the client."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "068",
    "title": "Insecure session expiration time",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug.Session for managing session data in Elixir applications",
      "Usage of a server with indefinite session persistence"
    ],
    "need": "Prevent unauthorized access to user information and actions.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code uses the Plug.Session to manage sessions but does not set a timeout for session expiration. This means that sessions will remain active indefinitely, which can be exploited by an attacker.",
        "text": "defmodule VulnerableApp do\n  use Plug.Router\n\n  plug Plug.Session, store: :cookie\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    conn\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Hello world!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code correctly sets a timeout for session expiration using the 'expires' option in the Plug.Session plug. After 5 minutes of inactivity, sessions will expire and cannot be used again, preventing unauthorized access.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n\n  plug Plug.Session, store: :cookie, expires: 5 * 60\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    conn\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Hello world!\")\n  end\nend"
      },
      "steps": [
        "Use the 'expires' option in the Plug.Session plug to set a timeout for session expiration.",
        "Set the timeout to a reasonable value, such as 5 minutes."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "063",
    "title": "Lack of data validation - Path Traversal",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for HTTP request and response handling",
      "File access or operations based on user-supplied path"
    ],
    "need": "Prevent unauthorized access to files and directories outside the intended path scope.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code takes a user-supplied path to read a file without validating or sanitizing the input, allowing an attacker to access files outside the intended directory.",
        "text": "defmodule VulnerableApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get '/read_file' do\n    path = conn.params['path']\n    file_content = File.read!(path)\n    send_resp(conn, 200, file_content)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code validates and sanitizes the user-supplied path before reading the file, effectively preventing path traversal attacks.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get '/read_file' do\n    path = conn.params['path']\n    if valid_path?(path) do\n      file_content = File.read!(path)\n      send_resp(conn, 200, file_content)\n    else\n      send_resp(conn, 400, 'Bad Request')\n    end\n  end\n\n  defp valid_path?(path) do\n    # Add your path validation logic here\n  end\nend"
      },
      "steps": [
        "Always validate and sanitize user-supplied input.",
        "Prevent the user from supplying the full path; consider using identifiers to reference files or directories.",
        "Use a whitelist of allowed paths or files.",
        "Check for path traversal sequences (.., ~, /) in the user input and neutralize them."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "071",
    "title": "Insecure or unset HTTP headers - Referrer-Policy",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for HTTP request and response handling",
      "Improperly set Referrer-Policy HTTP header in the server"
    ],
    "need": "Prevent website domain and path from being leaked to external services.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code sets up a simple Plug router to handle HTTP requests, but it does not set the Referrer-Policy header, potentially allowing the website's domain and path to be leaked.",
        "text": "defmodule VulnerableApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    conn\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Hello world!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code correctly sets the Referrer-Policy HTTP header to 'strict-origin', which ensures that the referrer will only be sent to same-protocol security destinations, thus preventing the website's domain and path from being leaked.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n\n  plug Plug.ReferrerPolicy, policy: :strict_origin\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    conn\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Hello world!\")\n  end\nend"
      },
      "steps": [
        "Add the 'plug Plug.ReferrerPolicy, policy: :strict_origin' line to your router to set the Referrer-Policy header",
        "The :strict_origin policy option will only send the referrer to same-protocol security destinations."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "062",
    "title": "Concurrent sessions",
    "context": [
      "Usage of Elixir for building scalable and concurrent applications",
      "Usage of Plug and Cowboy for HTTP request and response handling",
      "Session management for user data"
    ],
    "need": "Prevent multiple simultaneous sessions from the same user account to maintain traceability and non-repudiation of user actions.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code creates a new session for a user every time they log in, even if they already have an active session. This could lead to Concurrent Sessions.",
        "text": "defmodule VulnerableApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post '/login' do\n    user = authenticate_user(conn.params['username'], conn.params['password'])\n    if user do\n      session = start_session(user)\n      send_resp(conn, 200, 'Logged in')\n    else\n      send_resp(conn, 401, 'Unauthorized')\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code prevents concurrent sessions by checking if a user already has an active session when they try to log in. If they do, it ends the existing session before creating a new one.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post '/login' do\n    user = authenticate_user(conn.params['username'], conn.params['password'])\n    if user do\n      end_existing_session(user)\n      session = start_session(user)\n      send_resp(conn, 200, 'Logged in')\n    else\n      send_resp(conn, 401, 'Unauthorized')\n    end\n  end\nend"
      },
      "steps": [
        "Track the number of active sessions for each user.",
        "If a user tries to create a new session while they already have one, end the existing session or deny the creation of a new one.",
        "Notify the user when a new session is created from a different location."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "061",
    "title": "Remote File Inclusion",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for HTTP request and response handling",
      "Usage of server to accept URLs or file paths from user inputs"
    ],
    "need": "Prevent execution of remote files to maintain application integrity and confidentiality of data.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code includes a file specified by user input in the server's execution context, which could lead to Remote File Inclusion.",
        "text": "defmodule VulnerableApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get '/' do\n    filename = get_param(conn, 'filename')\n    file_content = File.read!(filename)\n    send_resp(conn, 200, file_content)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code retrieves files in a safe manner by using a database of file references rather than directly including files from user inputs.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get '/' do\n    file_id = get_param(conn, 'file_id')\n    filename = lookup_filename(file_id)\n    file_content = File.read!(filename)\n    send_resp(conn, 200, file_content)\n  end\n\n  defp lookup_filename(file_id) do\n    # Query database to retrieve file path by ID\n  end\nend"
      },
      "steps": [
        "Don't allow file paths or URLs to be specified directly by user inputs.",
        "Sanitize all user inputs to ensure they don't contain malicious code.",
        "Use a safe method for handling files, such as storing file references in a database and retrieving them by ID."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "057",
    "title": "Asymmetric denial of service - Content length",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for HTTP request and response handling",
      "Usage of server that accepts requests with unrestricted Content-Length header"
    ],
    "need": "Prevent service degradation or outage due to malicious requests with excessively large Content-Length headers",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This basic Plug-based Elixir application doesn't impose any limits on the Content-Length of incoming requests, making it vulnerable to DoS attacks.",
        "text": "defmodule VulnerableApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get '/' do\n    send_resp(conn, 200, 'Hello, world!')\n  end\nend"
      },
      "secure_code_example": {
        "description": "This Elixir application uses the Cowboy HTTP server with a configuration that limits the maximum request body size, mitigating the DoS vulnerability.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n\n  plug Plug.Parsers, parsers: [:urlencoded, :multipart, :json], pass: ['*/*'], json_decoder: Poison, length: 1_000_000\n\n  plug :match\n  plug :dispatch\n\n  get '/' do\n    send_resp(conn, 200, 'Hello, world!')\n  end\nend"
      },
      "steps": [
        "Set a maximum limit for the Content-Length of incoming requests.",
        "Consider using a rate limiting mechanism to limit the number of requests from a single source.",
        "Set an absolute timeout for incoming connections."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "044",
    "title": "Insecure HTTP methods enabled",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Phoenix Framework for building web applications",
      "Usage of the application as a web server for handling HTTP requests"
    ],
    "need": "To ensure that HTTP methods such as TRACE, PUT and DELETE are disabled to avoid potential security risks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code is vulnerable because it allows PUT and DELETE HTTP methods. This configuration can make the application susceptible to potential security threats.",
        "text": "defmodule VulnerableController do\n  use MyApp.Web, :controller\n\n  def update(conn, _params) do\n    # update action\n  end\n\n  def delete(conn, _params) do\n    # delete action\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code is secure because it does not include handlers for PUT and DELETE HTTP methods. This prevents potential security threats associated with these methods.",
        "text": "defmodule SecureController do\n  use MyApp.Web, :controller\n\n  def show(conn, _params) do\n    # show action\n  end\n\n  def create(conn, _params) do\n    # create action\n  end\n\n  # The PUT and DELETE methods are not handled\nend"
      },
      "steps": [
        "Use Plug to limit the allowed HTTP methods in your application.",
        "Remove or comment out any code that handles unwanted HTTP methods."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "043",
    "title": "Insecure or unset HTTP headers - Content-Security-Policy",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug Phoenix Framework for building web applications",
      "Usage of the application as a web server for handling HTTP responses"
    ],
    "need": "Prevent potential security threats by correctly setting Content-Security-Policy",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code is vulnerable because it does not set the Content-Security-Policy HTTP header. This omission makes the application susceptible to potential security threats like Cross-Site Scripting (XSS).",
        "text": "defmodule VulnerableController do\n  use MyApp.Web, :controller\n\n  def show(conn, _params) do\n    render(conn, \"show.html\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code is secure because it sets the Content-Security-Policy HTTP header using Plug. This setting protects the application from potential security threats.",
        "text": "defmodule SecureController do\n  use MyApp.Web, :controller\n\n  plug :put_content_security_policy_header\n\n  def show(conn, _params) do\n    render(conn, \"show.html\")\n  end\n\n  defp put_content_security_policy_header(conn, _opts) do\n    conn\n    |> put_resp_header(\"content-security-policy\", \"default-src 'self'\")\n  end\nend"
      },
      "steps": [
        "Use Plug to set the Content-Security-Policy HTTP header in every response.",
        "Ensure the policies set in the Content-Security-Policy HTTP header do not contain insecure values."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "033",
    "title": "Password change without identity check",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Password reset without identity verification"
    ],
    "need": "Ensure only the authentic user can change the account password",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code is vulnerable because it allows users to change their passwords without verifying their current password. An attacker who has access to a user's session could change the password without the user's knowledge.",
        "text": "defmodule VulnerableController do\n  use MyApp.Web, :controller\n\n  def change_password(conn, %{\"new_password\" => new_password}) do\n    user = get_current_user(conn)\n    User.change_password(user, new_password)\n    send_resp(conn, 200, \"Password changed\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code is secure because it requires the current password to change the password. This helps ensure that the request is made by the legitimate user.",
        "text": "defmodule SecureController do\n  use MyApp.Web, :controller\n\n  def change_password(conn, %{\"current_password\" => current_password, \"new_password\" => new_password}) do\n    user = get_current_user(conn)\n    if User.check_password(user, current_password) do\n      User.change_password(user, new_password)\n      send_resp(conn, 200, \"Password changed\")\n    else\n      send_resp(conn, 400, \"Incorrect current password\")\n    end\n  end\nend"
      },
      "steps": [
        "Require the current password when a user attempts to change their password.",
        "Consider implementing a second form of identity verification (e.g., email confirmation, OTP)."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "029",
    "title": "Inadequate File Size Control",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Plug.Upload for handling file uploads in Elixir",
      "File uploads are handled using Plug.Upload"
    ],
    "need": "Prevent resource exhaustion and potential denial of service attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code is vulnerable because it does not impose a limit on the size of the uploaded file. An attacker could upload a very large file to consume server resources and potentially cause a denial of service.",
        "text": "defmodule VulnerableController do\n  use MyApp.Web, :controller\n\n  def upload(conn, %{\"file\" => %Plug.Upload{} = upload}) do\n    {:ok, _} = File.cp(upload.path, \"./uploads/#{upload.filename}\")\n    send_resp(conn, 200, \"File uploaded successfully\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code is secure because it checks the size of the uploaded file before processing it. If the file size exceeds the limit, the upload is rejected.",
        "text": "defmodule SecureController do\n  use MyApp.Web, :controller\n\n  def upload(conn, %{\"file\" => %Plug.Upload{} = upload}) do\n    if File.size(upload.path) > 10_000_000 do\n      send_resp(conn, 400, \"File size exceeds limit\")\n    else\n      {:ok, _} = File.cp(upload.path, \"./uploads/#{upload.filename}\")\n      send_resp(conn, 200, \"File uploaded successfully\")\n    end\n  end\nend"
      },
      "steps": [
        "Install the 'arc' library which allows to impose a limit on the size of the uploaded files.",
        "Define a function to check the size of the uploaded file before copying it to the server storage.",
        "If the file size exceeds the limit, reject the upload and send an appropriate response to the client."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "023",
    "title": "Uncontrolled External Site Redirect - Host Header Injection",
    "context": [
      "Usage of Elixir for functional and concurrent programming",
      "Usage of Plug.Conn for handling HTTP connections in Elixir",
      "Usage of Plug.Conn for request handling"
    ],
    "need": "Prevent malicious redirection and potential SSRF attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following Elixir code is vulnerable because it uses the `host` from the `conn` object directly to construct a redirection URL. An attacker could provide a malicious host in the HTTP request's Host header to cause redirection to an external site or possibly exploit SSRF vulnerabilities.",
        "text": "defmodule VulnerableController do\n  use MyApp.Web, :controller\n\n  def redirect(conn, _params) do\n    redirect_to = conn.host\n    conn\n    |> put_resp_header(\"location\", redirect_to)\n    |> send_resp(302, \"\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The following Elixir code is secure because it does not use the `host` from the `conn` object directly. Instead, it uses a predefined host for the redirection, preventing potential misuse of the Host header.",
        "text": "defmodule SecureController do\n  use MyApp.Web, :controller\n\n  def redirect(conn, _params) do\n    redirect_to = \"https://secure.example.com\"\n    conn\n    |> put_resp_header(\"location\", redirect_to)\n    |> send_resp(302, \"\")\n  end\nend"
      },
      "steps": [
        "Add a function to validate the host before using it for redirection.",
        "Do not use the host from the incoming HTTP request directly for generating redirection responses. Instead, use a predefined and validated list of acceptable hosts or a fixed host configured in the application settings.",
        "Use pattern matching or similar to ensure the host matches the expected format."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "417",
    "title": "Account Takeover",
    "context": [
      "Usage of Elixir 1.12 for functional programming and building scalable applications",
      "Usage of Plug for building composable web applications",
      "Usage of Phoenix web framework for building web applications"
    ],
    "need": "To prevent unauthorized access and control over a user account.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code implements a password reset functionality. However, it does not validate whether the requester is indeed the owner of the account. This allows an attacker to request a password reset for any account and receive the reset link, allowing them to takeover that account.",
        "text": "defmodule MyAppWeb.PasswordResetController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{'email' => email}) do\n    user = Accounts.get_user_by_email(email)\n    Accounts.deliver_password_reset_instructions(user, conn)\n    send_resp(conn, :ok, \"\")\n  end\nend\n\ndefmodule MyApp.Accounts do\n  def deliver_password_reset_instructions(%User{} = user, conn) do\n    url = MyAppWeb.Router.Helpers.password_reset_url(conn, :edit, user.reset_password_token)\n    MyApp.Mailer.deliver_password_reset_instructions(user.email, url)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code now first sends a verification code to the user's registered email when a password reset is requested. The password reset process only proceeds if the correct verification code is provided, thereby validating that the requester is indeed the owner of the account.",
        "text": "defmodule MyAppWeb.PasswordResetController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{'email' => email}) do\n    user = Accounts.get_user_by_email(email)\n    verification_code = Accounts.generate_verification_code(user)\n    MyApp.Mailer.deliver_verification_code(user.email, verification_code)\n    send_resp(conn, :ok, \"\")\n  end\n\n  def update(conn, %{'email' => email, 'verification_code' => verification_code, 'new_password' => new_password}) do\n    user = Accounts.get_user_by_email(email)\n    if Accounts.verify(user, verification_code) do\n      Accounts.reset_password(user, new_password)\n      send_resp(conn, :ok, \"\")\n    else\n      send_resp(conn, :bad_request, \"\")\n    end\n  end\nend"
      },
      "steps": [
        "Implement verification mechanisms to ensure that the person requesting a password reset is indeed the owner of the account.",
        "This could be done by sending a verification code to the user's registered email before proceeding with the password reset process.",
        "Ensure that the password reset URL is only sent to the user's registered email and is not exposed anywhere else."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "420",
    "title": "Password Reset Poisoning",
    "context": [
      "Usage of Elixir 1.12 for functional programming and building scalable applications",
      "Usage of Plug for building composable web applications in Elixir",
      "Usage of Phoenix web framework for building web applications"
    ],
    "need": "To ensure secure password resets and prevent attackers from gaining control over user accounts.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code generates a password reset link using the host provided in the request headers. An attacker can manipulate the request headers to provide a host that they control, resulting in the application generating a reset link that points to the attacker's host.",
        "text": "defmodule MyAppWeb.PasswordResetController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{'email' => email}) do\n    user = Accounts.get_user_by_email(email)\n    Accounts.deliver_password_reset_instructions(user, conn)\n    send_resp(conn, :ok, \"\")\n  end\nend\n\ndefmodule MyApp.Accounts do\n  def deliver_password_reset_instructions(%User{} = user, conn) do\n    url = MyAppWeb.Router.Helpers.password_reset_url(conn, :edit, user.reset_password_token)\n    MyApp.Mailer.deliver_password_reset_instructions(user.email, url)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code now generates the password reset URL using a trusted host value from the application's configuration, instead of the host provided in the request headers. This prevents an attacker from manipulating the reset URL to point to their own host.",
        "text": "defmodule MyAppWeb.PasswordResetController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{'email' => email}) do\n    user = Accounts.get_user_by_email(email)\n    Accounts.deliver_password_reset_instructions(user)\n    send_resp(conn, :ok, \"\")\n  end\nend\n\ndefmodule MyApp.Accounts do\n  def deliver_password_reset_instructions(%User{} = user) do\n    host = Application.get_env(:my_app, MyAppWeb.Endpoint)[:url][:host]\n    url = MyAppWeb.Router.Helpers.password_reset_url(MyAppWeb.Endpoint, :edit, user.reset_password_token, host: host)\n    MyApp.Mailer.deliver_password_reset_instructions(user.email, url)\n  end\nend"
      },
      "steps": [
        "Ensure the password reset URL is generated using a trusted host value.",
        "Don't rely on values provided in the request headers for generating the reset URL.",
        "Add a configuration for the application's host and use that when generating the password reset URL."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "404",
    "title": "OS Command Injection",
    "context": [
      "Usage of Elixir (version 1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for HTTP request and response handling"
    ],
    "need": "Preventing execution of arbitrary OS commands",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code takes a command from the user via a POST request and directly executes it using the System.cmd function. An attacker can craft a command to retrieve or modify sensitive data, or even gain control over the system.",
        "text": "defmodule MyApp.CommandController do\n  use Plug.Router\n  plug :match\n  plug :dispatch\n\n  post \"/execute\" do\n    command = conn.body_params[\"command\"]\n    {result, 0} = System.cmd(\"/bin/sh\", [\"-c\", command])\n    send_resp(conn, 200, result)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure code checks whether the provided command is in a list of allowed commands before executing it. This whitelist approach prevents the execution of any arbitrary command, thus mitigating the risk of OS command injection.",
        "text": "defmodule MyApp.CommandController do\n  use Plug.Router\n  plug :match\n  plug :dispatch\n\n  post \"/execute\" do\n    command = conn.body_params[\"command\"]\n    if command in [@allowed_command1, @allowed_command2] do\n      {result, 0} = System.cmd(\"/bin/sh\", [\"-c\", command])\n      send_resp(conn, 200, result)\n    else\n      send_resp(conn, 403, \"Forbidden command\")\n    end\n  end\nend"
      },
      "steps": [
        "Implement a whitelist of allowed commands.",
        "Check the provided command against the whitelist before executing it.",
        "If possible, avoid executing OS commands based on user inputs."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "395",
    "title": "Insecure generation of random numbers - Static IV",
    "context": [
      "Usage of Elixir (version 1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for HTTP request and response handling",
      "Usage of Ecto for data persistence",
      "Usage of crypto for cryptographic operations"
    ],
    "need": "Ensuring secure initialization vectors for cryptographic operations",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code, a static, hardcoded initialization vector (IV) is used in the AES encryption. Using a static IV for multiple encryptions with the same key allows an attacker to analyze the patterns and potentially reverse-engineer the key.",
        "text": "defmodule MyApp.Crypto do\n  @iv \"0123456789abcdef\"\n  def encrypt(data, key) do\n    :crypto.block_encrypt(:aes_cbc128, key, @iv, data)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure version, a new random initialization vector (IV) is generated for each encryption using :crypto.strong_rand_bytes. This method provides sufficient randomness and high entropy, which makes it very difficult for an attacker to predict the IVs.",
        "text": "defmodule MyApp.Crypto do\n  def encrypt(data, key) do\n    iv = :crypto.strong_rand_bytes(16)\n    {:iv, :crypto.block_encrypt(:aes_cbc128, key, iv, data)}\n  end\nend"
      },
      "steps": [
        "Use :crypto.strong_rand_bytes to generate a random initialization vector for each encryption.",
        "Avoid using static, hardcoded initialization vectors."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "369",
    "title": "Insecure object reference - User deletion",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for HTTP request and response handling",
      "Usage of Ecto for data persistence"
    ],
    "need": "Protecting user data and ensuring application integrity",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this vulnerable code snippet, the application is deleting a user based on the provided id without checking if the authenticated user has the necessary permissions to perform the operation.",
        "text": "def delete_user(conn, %{'id' => id}) do\n  Repo.delete!(User |> Repo.get!(id))\n  send_resp(conn, 204, \"\")\nend"
      },
      "secure_code_example": {
        "description": "In this secure version, before deleting a user, the application checks if the current user has the 'admin' role. If the user doesn't have the necessary permissions, the application returns a 403 Forbidden status code.",
        "text": "def delete_user(conn, %{'id' => id}) do\n  case conn.assigns.current_user.role do\n    :admin -> \n      Repo.delete!(User |> Repo.get!(id))\n      send_resp(conn, 204, \"\")\n    _ ->\n      send_resp(conn, 403, \"Forbidden\")\n  end\nend"
      },
      "steps": [
        "Check the role of the current user before performing any destructive operations.",
        "Only allow users with the necessary permissions to delete other users.",
        "If a user without the necessary permissions tries to delete a user, return a 403 Forbidden status code."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "345",
    "title": "Security Controls Bypass or Absence - Session Invalidation",
    "context": [
      "Usage of Elixir 1.12 for building scalable and concurrent applications",
      "Usage of Plug.Session for HTTP session management"
    ],
    "need": "To ensure proper session management and invalidate sessions appropriately",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code example, the `get_user_email` function checks the session to find the user's email. However, there is debug code left in that allows anyone to pass in a session with the word 'auto' and get access to a testing email. This is insecure as it allows unauthorized access.",
        "text": "defmodule MyApp.Accounts do\n  def get_user_email(conn) do\n    session = Plug.Conn.get_session(conn, :user)\n    if session == \"auto\", do: \"test@test.com\", else: session.email\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the `get_user_email` function only checks the session for the user's email, and there is no debug code that can be exploited for unauthorized access.",
        "text": "defmodule MyApp.Accounts do\n  def get_user_email(conn) do\n    session = Plug.Conn.get_session(conn, :user)\n    session.email\n  end\nend"
      },
      "steps": [
        "Remove the debugging code from the production environment",
        "Ensure all test code is isolated from production code"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "337",
    "title": "Insecure Session Management - CSRF Fixation",
    "context": [
      "Usage of Elixir 1.12 for functional programming and building scalable applications",
      "Usage of Phoenix Framework 1.6 for web development",
      "Usage of Plug.CSRFProtection for protecting against Cross-Site Request Forgery (CSRF) attacks"
    ],
    "need": "To prevent CSRF attacks that can spoof an authenticated user and execute critical transactions",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code example, the `make_transaction` function handles a transaction without validating a CSRF token. This allows an attacker to create a button with the content of a request and trick a user running a transaction to receive the app push notification and complete the request.",
        "text": "defmodule TransactionController do\n  use MyApp.Web, :controller\n\n  def make_transaction(conn, %{'amount' => amount, 'recipient' => recipient}) do\n    # perform transaction...\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the `make_transaction` function validates the CSRF token using `Plug.CSRFProtection.check_csrf_token/2`. This ensures that the request is made by a legitimate user, preventing CSRF attacks.",
        "text": "defmodule TransactionController do\n  use MyApp.Web, :controller\n\n  def make_transaction(conn, %{'_csrf_token' => csrf_token, 'amount' => amount, 'recipient' => recipient}) do\n    if Plug.CSRFProtection.check_csrf_token(conn, csrf_token) do\n      # perform transaction...\n    else\n      send_resp(conn, 403, \"Invalid CSRF token\")\n    end\n  end\nend"
      },
      "steps": [
        "Enable CSRF protection using `Plug.CSRFProtection`",
        "Generate a CSRF token for every form using `Plug.CSRFProtection.get_csrf_token/0` and include it as a hidden field in the form",
        "In the function handling the form submission, validate the CSRF token"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "329",
    "title": "Insecure or Unset HTTP Headers - Content-Type",
    "context": [
      "Usage of Elixir 1.12 for functional programming on the Erlang virtual machine",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "To prevent unexpected behaviors due to content type misinterpretations",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code example, the `index` function responds to a GET request but does not set the Content-Type header. This can lead to misinterpretation of the content type, which can cause unexpected behaviors in clients.",
        "text": "defmodule PageController do\n  use MyApp.Web, :controller\n\n  def index(conn, _params) do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code, the `index` function sets the Content-Type header to `text/plain`. This informs the client about the type of content in the response, preventing misinterpretations.",
        "text": "defmodule PageController do\n  use MyApp.Web, :controller\n\n  def index(conn, _params) do\n    conn\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Hello, world!\")\n  end\nend"
      },
      "steps": [
        "Always set the Content-Type header to explicitly define the content types allowed by the application",
        "Use `put_resp_content_type` function provided by Phoenix framework to set the Content-Type header"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "328",
    "title": "Insecure Object Reference - Session Management",
    "context": [
      "Usage of Elixir 1.12 for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "To prevent unauthorized users from closing sessions of other users",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code, the `logout_user` function logs out a user based on the email provided. This is insecure because if an attacker knows a user's email, they can log out the user's session.",
        "text": "defmodule SessionManager do\n  def logout_user(conn, email) do\n    # Clearing the session\n    conn\n    |> put_flash(:info, \"Logged out successfully.\")\n    |> configure_session(drop: true)\n    |> redirect(to: \"/\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure version of the code, the system checks whether the session being terminated belongs to the user initiating the logout operation.",
        "text": "defmodule SessionManager do\n  def logout_user(conn, session_token) do\n    user = get_user_from_session_token(session_token)\n    if conn.assigns.current_user == user do\n      # Clearing the session\n      conn\n      |> put_flash(:info, \"Logged out successfully.\")\n      |> configure_session(drop: true)\n      |> redirect(to: \"/\")\n    else\n      # Do not allow logging out other users' sessions\n    end\n  end\n\n  defp get_user_from_session_token(session_token) do\n    # Logic to get the user from the session token\n  end\nend"
      },
      "steps": [
        "Use a secure identifier, like a session token, to identify the user for the logout operation",
        "Implement checks to validate that the session being terminated matches the user performing the operation"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "324",
    "title": "Insecure Functionality - User Management",
    "context": [
      "Usage of Elixir 1.12 for functional programming and building scalable applications",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "To ensure that sensitive vulnerability data is only accessible by registered and authorized users",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this code, the function `assign_treatment_manager` allows any email address to be assigned as a manager of vulnerabilities. This means the system could potentially send sensitive vulnerability data to non-registered users, or users who no longer have access to the system.",
        "text": "defmodule UserManager do\n  def assign_treatment_manager(email, vulnerability_id) do\n    send_vulnerability_email(email, vulnerability_id)\n  end\n\n  defp send_vulnerability_email(email, vulnerability_id) do\n    # Email sending logic here\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure version of the code, the system checks whether the user is registered and still part of the organization before assigning them as a treatment manager. Also, when a user is removed from all projects, their access is effectively revoked.",
        "text": "defmodule UserManager do\n  def assign_treatment_manager(email, vulnerability_id) do\n    if is_registered_and_authorized?(email) do\n      send_vulnerability_email(email, vulnerability_id)\n    end\n  end\n\n  defp send_vulnerability_email(email, vulnerability_id) do\n    # Email sending logic here\n  end\n\n  defp is_registered_and_authorized?(email) do\n    # Verification logic here\n  end\nend"
      },
      "steps": [
        "Ensure the system verifies if a user is registered and has the necessary access rights before assigning them as a treatment manager",
        "Check if a user is still part of an organization before sending them any vulnerability data",
        "When a user is removed from all projects, ensure their access to all related data is revoked"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "322",
    "title": "Insecurely Generated Token - Lifespan",
    "context": [
      "Usage of Elixir 1.12 for functional programming and building scalable applications",
      "Usage of Phoenix Framework 1.6 for web development",
      "Usage of Guardian 2.0 for authentication and authorization"
    ],
    "need": "To prevent unauthorized user data modifications by ensuring token's expiry time is reasonable",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this code snippet, JWT tokens are created with a lifespan of approximately 5 days (represented as 432000 seconds). This is too long and it increases the risk that a malicious actor can use a stolen token for unauthorized activities.",
        "text": "defmodule InsecureToken do\n  alias Guardian.JWT\n  @secret_key \"Your secret key\"\n\n  def create_token(claims) do\n    {:ok, token, _claims} = JWT.encode_and_sign(claims, key: @secret_key, ttl: {432000, :second})\n    token\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure version of the code, the lifespan of the token has been significantly reduced to approximately 15 minutes (represented as 900 seconds). This reduces the time window for an attacker to use a stolen token.",
        "text": "defmodule SecureToken do\n  alias Guardian.JWT\n  @secret_key \"Your secret key\"\n\n  def create_token(claims) do\n    {:ok, token, _claims} = JWT.encode_and_sign(claims, key: @secret_key, ttl: {900, :second})\n    token\n  end\nend"
      },
      "steps": [
        "Reduce the lifespan of JWT tokens to a more reasonable timeframe",
        "Invalidate tokens on the server side when a user logs out",
        "Consider token refresh strategies if long-lived tokens are required"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "318",
    "title": "Insecurely Generated Token - Validation",
    "context": [
      "Usage of Elixir 1.12 for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework 1.6 for web development",
      "Usage of Guardian 2.0 for authentication and authorization"
    ],
    "need": "To prevent unauthorized user creation and protect the integrity of user data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this code snippet, a JWT token is decoded without verifying its signature, thus allowing tampering. An attacker can modify the token header, to change the algorithm used for signature and create users without the token being properly validated.",
        "text": "defmodule InsecureToken do\n  alias Guardian.JWT\n\n  def decode_and_verify(token) do\n    {:ok, claims} = JWT.decode_and_verify(token)\n    IO.inspect(claims)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure version of the code, the token is decoded and verified with a predefined secret key. This ensures the token's integrity and authenticity, thus preventing the creation of unauthorized users.",
        "text": "defmodule SecureToken do\n  alias Guardian.JWT\n  @secret_key \"Your secret key\"\n\n  def decode_and_verify(token) do\n    {:ok, claims} = JWT.decode_and_verify(token, key: @secret_key)\n    IO.inspect(claims)\n  end\nend"
      },
      "steps": [
        "Ensure that the JWT token signature is properly validated before decoding",
        "Use a known and secure algorithm for token encryption",
        "Consider using a library like Guardian for Elixir that provides secure handling of JWT tokens"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "317",
    "title": "Improper Resource Allocation - Memory Leak",
    "context": [
      "Usage of Elixir 1.12 for building scalable and concurrent applications",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "To avoid exhausting system resources due to memory leaks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The following code demonstrates a memory leak situation in Elixir. A process is spawned that starts a large data structure (a list), which is continually appended with elements. However, these elements are never released and accumulate over time, leading to increased memory usage.",
        "text": "defmodule MemoryLeak do\n  def leak_memory do\n    spawn(fn ->\n      Process.flag(:trap_exit, true)\n      accumulate([])\n    end)\n  end\n\n  defp accumulate(list) do\n    new_list = [0 | list]\n    accumulate(new_list)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this solution, the process is set to terminate after a certain period of time, ensuring that the large data structure it has created is released from memory.",
        "text": "defmodule MemoryLeak do\n  def leak_memory do\n    spawn(fn ->\n      Process.flag(:trap_exit, true)\n      accumulate([])\n      Process.sleep(10000)\n      :ok\n    end)\n  end\n\n  defp accumulate(list) when length(list) < 1_000_000 do\n    new_list = [0 | list]\n    accumulate(new_list)\n  end\n\n  defp accumulate(_list), do: :ok\nend"
      },
      "steps": [
        "Monitor your processes and identify those that continue to consume memory over time",
        "Limit the lifetime of processes that create large data structures",
        "Consider making use of Elixir's garbage collection features to manually trigger garbage collection in certain situations"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "309",
    "title": "Insecurely Generated Token - JWT",
    "context": [
      "Usage of Elixir 1.12 for functional programming and building scalable applications",
      "Usage of Phoenix Framework 1.6 for web development",
      "Usage of Guardian 2.0 for authentication and authorization"
    ],
    "need": "To ensure tokens are generated securely, preventing unauthorized access",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code example shows a JWT token being signed with a weak secret key. This weak key can be easily cracked, allowing attackers to generate their own tokens, modify token parameters and access the service illegitimately.",
        "text": "def sign(user) do\n  jwt = %{id: user.id}\n  secret = 'weak-secret'\n  {:ok, token, _claims} = Guardian.encode_and_sign(jwt, secret)\n  token\nend"
      },
      "secure_code_example": {
        "description": "This secure code example replaces the weak secret key with a strong secret key stored in an environment variable. This enhances the security of the JWT signing and verification process.",
        "text": "def sign(user) do\n  jwt = %{id: user.id}\n  secret = System.get_env('JWT_SECRET')\n  {:ok, token, _claims} = Guardian.encode_and_sign(jwt, secret)\n  token\nend"
      },
      "steps": [
        "Use a strong secret key for JWT signing and verification",
        "Consider using environment variables to store the secret key securely",
        "Consider using a library or service that can generate strong secret keys"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "307",
    "title": "Insecure Object Reference - Data",
    "context": [
      "Usage of Elixir 1.12 for functional programming and building scalable applications",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "Prevent unauthorized users from accessing or manipulating other stores' data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code example shows an Elixir Phoenix application that retrieves a store's data by its ID without checking the user's permissions. An attacker can exploit this by guessing or brute-forcing the store IDs to access and manipulate other stores' data.",
        "text": "def show(conn, %{\"id\" => id}) do\n  store = Repo.get!(Store, id)\n  send_resp(conn, :ok, store)\nend"
      },
      "secure_code_example": {
        "description": "This secure code example includes a check to ensure the authenticated user has the necessary permissions to access the store's data before it is returned. If they do not, a 403 Forbidden status code is returned.",
        "text": "def show(conn, %{\"id\" => id}) do\n  store = Repo.get!(Store, id)\n  if has_permission?(conn.assigns[:current_user], store) do\n    send_resp(conn, :ok, store)\n  else\n    send_resp(conn, :forbidden, \"You do not have permission to access this store's data\")\n  end\nend\n\ndefp has_permission?(user, store) do\n  user.id == store.user_id\nend"
      },
      "steps": [
        "Before returning the store's data, check if the authenticated user has the necessary permissions to access it",
        "Return a 403 Forbidden status code if the user does not have the necessary permissions"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "306",
    "title": "Insecure Object Reference - Files",
    "context": [
      "Usage of Elixir 1.12 for functional programming",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "Prevent unauthorized users from accessing or manipulating information",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code example shows an Elixir Phoenix application that retrieves a file by its ID without checking the user's permissions. An attacker can exploit this by guessing or brute-forcing the file IDs to access other users' files.",
        "text": "def show(conn, %{\"id\" => id}) do\n  file = Repo.get!(File, id)\n  send_resp(conn, :ok, file)\nend"
      },
      "secure_code_example": {
        "description": "This secure code example includes a check to ensure the authenticated user has the necessary permissions to access the file before it is returned. If they do not, a 403 Forbidden status code is returned.",
        "text": "def show(conn, %{\"id\" => id}) do\n  file = Repo.get!(File, id)\n  if has_permission?(conn.assigns[:current_user], file) do\n    send_resp(conn, :ok, file)\n  else\n    send_resp(conn, :forbidden, \"You do not have permission to access this file\")\n  end\nend\n\ndefp has_permission?(user, file) do\n  user.id == file.user_id\nend"
      },
      "steps": [
        "Before returning the file, check if the authenticated user has the necessary permissions to access it",
        "Return a 403 Forbidden status code if the user does not have the necessary permissions"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "305",
    "title": "Security Controls Bypass or Absence - Data Creation",
    "context": [
      "Usage of Elixir 1.12 for building scalable and concurrent applications",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "Prevent the creation of more than four beneficiaries per policy",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code example shows an Elixir Phoenix application that creates a new policy with associated beneficiaries. However, there's no validation on the server side to restrict the number of beneficiaries created per policy. This allows for unlimited beneficiaries to be associated with a single policy, bypassing the intended restriction.",
        "text": "def create(conn, %{\"policy\" => policy_params, \"beneficiaries\" => beneficiaries_params}) do\n  %Policy{}\n  |> Policy.changeset(policy_params)\n  |> Ecto.Changeset.cast_assoc(:beneficiaries, with: &Beneficiary.changeset/2)\n  |> Repo.insert()\n  send_resp(conn, :ok, \"Policy created successfully\")\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, a validation function has been added to the controller. This function checks the length of the beneficiaries list before the policy is created. If more than four beneficiaries are associated with a policy, it returns an error response.",
        "text": "def create(conn, %{\"policy\" => policy_params, \"beneficiaries\" => beneficiaries_params}) do\n  if Enum.count(beneficiaries_params) > 4 do\n    send_resp(conn, :bad_request, \"Cannot associate more than 4 beneficiaries with a policy\")\n  else\n    %Policy{}\n    |> Policy.changeset(policy_params)\n    |> Ecto.Changeset.cast_assoc(:beneficiaries, with: &Beneficiary.changeset/2)\n    |> Repo.insert()\n    send_resp(conn, :ok, \"Policy created successfully\")\n  end\nend"
      },
      "steps": [
        "Add a validation check to restrict the number of beneficiaries associated with each policy to four",
        "Return an error response if more than four beneficiaries are provided"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "302",
    "title": "Insecure Functionality - Session Management",
    "context": [
      "Usage of Elixir 1.12 for building scalable and concurrent applications",
      "Usage of Phoenix Framework 1.6 for web development",
      "Usage of Guardian library for authentication and authorization"
    ],
    "need": "Prevent reuse of expired session tokens to ensure session integrity",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This example depicts an API endpoint in a Phoenix application that authenticates the user using JWT tokens generated with the Guardian library. The problem lies in the token validation mechanism, where the code checks the token's expiration date against the current time but does not verify if the token itself is expired.",
        "text": "defmodule MyAppWeb.Endpoint do\n  use Guardian.Plug.VerifyHeader, realm: \"Bearer\"\n  def call(conn, _) do\n    case Guardian.Plug.current_token(conn) do\n      nil -> conn\n      token ->\n        if MyApp.Auth.Token.is_expired?(token) do\n          MyApp.Auth.Token.extend_expiration(token)\n        end\n        conn\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the fixed code, the token extension functionality has been removed. Therefore, once a token has expired, it can no longer be used, ensuring the integrity of the session.",
        "text": "defmodule MyAppWeb.Endpoint do\n  use Guardian.Plug.VerifyHeader, realm: \"Bearer\"\n  def call(conn, _) do\n    case Guardian.Plug.current_token(conn) do\n      nil -> conn\n      token ->\n        if MyApp.Auth.Token.is_expired?(token) do\n          conn\n          |> put_status(:unauthorized)\n          |> Phoenix.Controller.json(%{error: \"Expired token\"})\n          |> halt()\n        end\n        conn\n    end\n  end\nend"
      },
      "steps": [
        "Remove the token extension functionality",
        "Ensure that expired tokens cannot be reused"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "301",
    "title": "Concurrent Sessions Control Bypass",
    "context": [
      "Usage of Elixir 1.12 for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "Prevent concurrent sessions from a single user account to maintain traceability",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code snippet depicts a controller in a Phoenix application where users can log in without the application terminating their previous sessions. This would allow an attacker who gained access to a user's account to use it concurrently with the legitimate user, causing potential loss of traceability.",
        "text": "defmodule MyAppWeb.SessionController do\n  use MyAppWeb, :controller\n  def create(conn, %{\"user\" => user_params}) do\n    case MyApp.Auth.authenticate(user_params) do\n      {:ok, user} ->\n        conn\n        |> put_session(:user_id, user.id)\n        |> redirect(to: \"/dashboard\")\n      _ ->\n        conn\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the fixed code, upon successful authentication, any existing sessions for the user are invalidated before a new one is created. This ensures that only one session can be active at a time for each user, preventing concurrent session control bypass.",
        "text": "defmodule MyAppWeb.SessionController do\n  use MyAppWeb, :controller\n  def create(conn, %{\"user\" => user_params}) do\n    case MyApp.Auth.authenticate(user_params) do\n      {:ok, user} ->\n        MyApp.Session.invalidate_user_sessions(user)\n        conn\n        |> put_session(:user_id, user.id)\n        |> redirect(to: \"/dashboard\")\n      _ ->\n        conn\n    end\n  end\nend"
      },
      "steps": [
        "Maintain a server-side record of active user sessions",
        "Immediately invalidate any existing sessions for a user when a new login occurs"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "298",
    "title": "Authentication Mechanism Absence or Evasion - Redirect",
    "context": [
      "Usage of Elixir 1.12 for building scalable and concurrent applications",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "Prevent unauthorized access by implementing proper authentication",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code provided shows a function that uses a URL parameter to determine where to redirect the user after login. An attacker could change this parameter to bypass authentication, gaining unauthorized access to the application.",
        "text": "defmodule MyAppWeb.SessionController do\n  use MyAppWeb, :controller\n  def create(conn, %{\"user\" => user_params, \"redirect\" => redirect_url}) do\n    case MyApp.Auth.authenticate(user_params) do\n      {:ok, user} ->\n        conn\n        |> put_session(:user_id, user.id)\n        |> redirect(to: redirect_url)\n      _ ->\n        conn\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code now redirects to a static page instead of using a URL parameter. This ensures that the redirection process cannot be manipulated by attackers.",
        "text": "defmodule MyAppWeb.SessionController do\n  use MyAppWeb, :controller\n  def create(conn, %{\"user\" => user_params}) do\n    case MyApp.Auth.authenticate(user_params) do\n      {:ok, user} ->\n        conn\n        |> put_session(:user_id, user.id)\n        |> redirect(to: \"/dashboard\")\n      _ ->\n        conn\n    end\n  end\nend"
      },
      "steps": [
        "Implement a strong authentication process for every business-critical resource",
        "Instead of using a URL parameter for redirection, set a static redirect page in the application code"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "295",
    "title": "Insecure Session Management After Password Change",
    "context": [
      "Usage of Elixir 1.12 for functional programming",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "Ensure security after password change",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code demonstrates a password change functionality which does not invalidate the session after the password change. If an attacker had compromised this session, they would maintain control even after the legitimate user has changed their password.",
        "text": "defmodule MyApp.Accounts do\n  def change_password(user, new_password) do\n    user\n    |> change()\n    |> put_change(:password, new_password)\n    |> Repo.update()\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code now includes a function call to clear the session after the password change. This forces any user, legitimate or attacker, to re-authenticate after the password change, effectively locking out any attacker that had compromised the previous session.",
        "text": "defmodule MyApp.Accounts do\n  def change_password(conn, user, new_password) do\n    user\n    |> change()\n    |> put_change(:password, new_password)\n    |> Repo.update()\n    |> case do\n         {:ok, _user} ->\n           MyAppWeb.SessionController.clear_session(conn)\n         _ ->\n           conn\n       end\n  end\nend"
      },
      "steps": [
        "Ensure that the session is invalidated or renewed after the password change",
        "This could involve destroying the current session and forcing the user to log in again with their new password"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "288",
    "title": "Insecure Object Reference in Credit Card Inquiry",
    "context": [
      "Usage of Elixir 1.12 for functional programming on the Erlang virtual machine",
      "Usage of Phoenix Framework 1.6 for web development"
    ],
    "need": "Prevent unauthorized access to sensitive user information",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is vulnerable because it allows the querying of credit card information based on the encrypted product number, but it does not verify if the account making the request has the necessary permissions to access that specific credit card information. This opens a pathway for an attacker to probe and potentially obtain sensitive credit card information.",
        "text": "defmodule MyApp.CreditCardController do\n  use MyApp, :controller\n  def show(conn, %{'id' => id}) do\n    credit_card = CreditCard.get!(id)\n    render(conn, 'show.json', credit_card: credit_card)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it verifies if the user making the request has the necessary permissions to access the requested credit card data before providing it. This is achieved by comparing the user id in the session with the user id associated with the credit card. If the ids match, the information is provided. Otherwise, an error message is returned.",
        "text": "defmodule MyApp.CreditCardController do\n  use MyApp, :controller\n  import Plug.Conn\n  def show(conn, %{'id' => id}) do\n    credit_card = CreditCard.get!(id)\n    if conn.assigns.current_user.id == credit_card.user_id do\n      render(conn, 'show.json', credit_card: credit_card)\n    else\n      conn\n      |> put_status(:forbidden)\n      |> put_resp_header('content-type', 'application/json')\n      |> send_resp(403, '{\"error\": \"Not authorized\"}')\n    end\n  end\nend"
      },
      "steps": [
        "Import the Plug.Conn library which provides utility functions for working with connections",
        "Use the Plug.Conn.assign/3 function in your controller to assign the current user to the conn struct",
        "Check if the current user has the necessary permissions to access the requested credit card data before returning it",
        "Add an else clause to handle scenarios when the user does not have permission to access the data"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "287",
    "title": "Insecure object reference - Corporate information",
    "context": [
      "Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Ecto for data persistence",
      "Usage of CSV or Excel file uploading and parsing"
    ],
    "need": "Prevent unauthorized modification of third-party company's employee information",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code below is insecure because it allows anyone to upload an Excel file and update employee information of any company by changing the 'payrollNumber'. An attacker can change the 'payrollNumber' to a company they do not own and upload or modify its employees' information.",
        "text": "defmodule PayrollController do\n  def upload(conn, %{'file' => file, 'payrollNumber' => payroll_number}) do\n    {:ok, company} = Repo.get(Company, payroll_number)\n    Employee.import_from_excel(file, company)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code below is secure because it uses the 'payrollNumber' stored in the session to get the company and update its employees. Even if an attacker changes the 'payrollNumber' in the request parameters, it won't affect which company's employees are updated because the 'payrollNumber' in the session is used.",
        "text": "defmodule PayrollController do\n  def upload(conn, %{'file' => file}) do\n    payroll_number = get_session(conn, :payroll_number)\n    {:ok, company} = Repo.get(Company, payroll_number)\n    Employee.import_from_excel(file, company)\n  end\nend"
      },
      "steps": [
        "Store the authenticated user's company identifier in the session after successful login.",
        "Instead of getting the company identifier from request parameters, get it from the session.",
        "Use the company identifier from the session to get the company and update its employees."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "286",
    "title": "Insecure object reference - Personal information",
    "context": [
      "Usage of Elixir (version 1.12 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Plug for session handling",
      "Usage of Ecto for data persistence"
    ],
    "need": "Prevent unauthorized modification of other user's information",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code below is insecure because it uses the user_id from the request parameters to fetch and update a user. An attacker can change the user_id parameter to update another user's information.",
        "text": "defmodule UserController do\n  def update(conn, %{'id' => id, 'user' => user_params}) do\n    user = Repo.get(User, id)\n    changeset = User.changeset(user, user_params)\n    Repo.update(changeset)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code below is secure because it uses the user_id stored in the session to fetch and update the user. Even if an attacker changes the user_id in the request parameters, it won't affect which user is updated because the user_id in the session is used.",
        "text": "defmodule UserController do\n  def update(conn, %{'user' => user_params}) do\n    id = get_session(conn, :user_id)\n    user = Repo.get(User, id)\n    changeset = User.changeset(user, user_params)\n    Repo.update(changeset)\n  end\nend"
      },
      "steps": [
        "Store the authenticated user's id in the session after successful login.",
        "Instead of getting the user id from request parameters, get it from the session.",
        "Use the user id from the session to fetch and update the user."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "273",
    "title": "Insecure functionality - Fingerprint",
    "context": [
      "Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications",
      "Usage of Ecto for data persistence"
    ],
    "need": "Ensure that only authorized fields can be updated by the user",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code below is insecure because it allows any field of the user to be updated without checking if the field is allowed to be updated. This could lead to unauthorized updates to fields that should be read-only after account creation, like 'email', or worse, 'admin' status.",
        "text": "defmodule UserController do\n  def update(conn, %{'user' => user_params, 'id' => id}) do\n    user = Repo.get(User, id)\n    changeset = User.changeset(user, user_params)\n    Repo.update(changeset)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code below is secure because it only allows 'username' and 'age' to be updated. The 'admin' and 'email' fields are not included in the whitelist, so they cannot be updated even if they are included in the user_params map.",
        "text": "defmodule UserController do\n  def update(conn, %{'user' => user_params, 'id' => id}) do\n    user = Repo.get(User, id)\n    changeset = User.changeset(user, user_params, ~w(username age)a)\n    Repo.update(changeset)\n  end\nend"
      },
      "steps": [
        "Define a whitelist of fields that can be updated.",
        "Use the `Ecto.Changeset.cast/4` function to only allow updates to the whitelisted fields."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "272",
    "title": "Insecure functionality - Masking",
    "context": [
      "Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for HTTP request and response handling"
    ],
    "need": "Ensure confidentiality and integrity of sensitive user data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code below is insecure because it directly uses user input to construct the response. Sensitive data like password is included in the response without being masked, which exposes the data to potential eavesdroppers or data breaches.",
        "text": "defmodule UserController do\n  def show(conn, %{'id' => id}) do\n    user = Repo.get(User, id)\n    conn\n    |> put_resp_content_type('application/json')\n    |> send_resp(200, Poison.encode!(user))\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code below is secure because it masks the password field when sending the user data in the response. The `Map.drop/2` function is used to remove the sensitive data from the map before it is sent in the response.",
        "text": "defmodule UserController do\n  def show(conn, %{'id' => id}) do\n    user = Repo.get(User, id) |> Map.drop([:password])\n    conn\n    |> put_resp_content_type('application/json')\n    |> send_resp(200, Poison.encode!(user))\n  end\nend"
      },
      "steps": [
        "Use pattern matching to exclude sensitive data from the user map before sending it in the response.",
        "Use a separate data model for response that doesn't include sensitive fields."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "271",
    "title": "Insecure functionality - Password management",
    "context": [
      "Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix framework for web application development"
    ],
    "need": "Secure password management",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "\n            This example represents a password update function in a web application written in Elixir using the Phoenix framework. \n            The function does not verify whether the current user has the right to change the password for the user id provided in the params.\n            An attacker can use this function to change the password of any user, knowing only their user id.\n            ",
        "text": "\n            def update_password(conn, %{\"id\" => id, \"password\" => password}) do\n                user = Accounts.get_user!(id)\n                user\n                |> User.changeset(%{password: password})\n                |> Repo.update!()\n                conn\n                |> put_flash(:info, \"Password updated successfully.\")\n                |> redirect(to: \"/\")\n            end\n            "
      },
      "secure_code_example": {
        "description": "\n            This is the secure version of the previous code. \n            It includes a check to verify that the current user (taken from the session) is the same user for whom the password is being changed.\n            ",
        "text": "\n            def update_password(conn, %{\"id\" => id, \"password\" => password}) do\n                current_user = get_session(conn, :current_user)\n                if current_user.id == id do\n                    user = Accounts.get_user!(id)\n                    user\n                    |> User.changeset(%{password: password})\n                    |> Repo.update!()\n                    conn\n                    |> put_flash(:info, \"Password updated successfully.\")\n                    |> redirect(to: \"/\")\n                else\n                    conn\n                    |> put_flash(:error, \"You do not have permission to change this user's password.\")\n                    |> redirect(to: \"/\")\n                end\n            end\n            "
      },
      "steps": [
        "Check if the current user's id matches the id in the parameters.",
        "If not, return an error response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "270",
    "title": "Unauthorized File Creation",
    "context": [
      "Usage of Elixir for building scalable and fault-tolerant applications",
      "Usage of Phoenix web framework for building web applications"
    ],
    "need": "Prevent unauthorized users from creating files",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it does not perform any access control check before creating a file. If a malicious user could craft a request to this endpoint, they could create a file regardless of their authorization level.",
        "text": "\n            defmodule MyApp.FileController do\n              use MyApp, :controller\n            \n              def create(conn, %{\"file\" => file_params}) do\n                # Create a new file\n                {:ok, file} = MyApp.File.create_file(file_params)\n            \n                conn\n                |> put_status(:created)\n                |> render(\"show.json\", file: file)\n              end\n            end\n            "
      },
      "secure_code_example": {
        "description": "In the secure version, the application checks if the current user has the necessary permissions to create a file before performing the action. If they do not, the request is denied.",
        "text": "\n            defmodule MyApp.FileController do\n              use MyApp, :controller\n            \n              def create(conn, %{\"file\" => file_params}) do\n                # Check if the user has the necessary permissions\n                if MyApp.Authorization.check_permission(conn.assigns[:current_user], :create_file) do\n                  # Create a new file\n                  {:ok, file} = MyApp.File.create_file(file_params)\n            \n                  conn\n                  |> put_status(:created)\n                  |> render(\"show.json\", file: file)\n                else\n                  conn\n                  |> put_status(:forbidden)\n                  |> json(%{error: \"You do not have the necessary permissions to perform this action.\"})\n                end\n              end\n            end\n            "
      },
      "steps": [
        "Implement an authorization check function (e.g., MyApp.Authorization.check_permission/2) that verifies if a user has a specific permission.",
        "Before performing any sensitive operations (like creating a file), use this function to check if the current user has the necessary permissions.",
        "If the user does not have the necessary permissions, deny the request."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "204",
    "title": "Insufficient data authenticity validation",
    "context": [
      "Usage of Elixir (version 1.12 and above) for building scalable and fault-tolerant applications",
      "Usage of Ecto.Repo for interacting with databases"
    ],
    "need": "To prevent injection of potentially malicious characters into application fields",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The Elixir code allows a user to update their data without performing any server-side validation or checks on the user input, which could lead to injection of potentially malicious characters into application fields.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def update(conn, params) do\n    user = MyApp.Repo.get!(User, params[\"id\"])\n    user = MyApp.Repo.update!(User.changeset(user, params))\n\n    send_resp(conn, 200, \"User data updated successfully\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure Elixir code checks the validity of the changeset before updating the user data. This prevents the injection of potentially malicious characters into application fields.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def update(conn, params) do\n    user = MyApp.Repo.get!(User, params[\"id\"])\n    \n    changeset = User.changeset(user, params)\n    \n    if changeset.valid? do\n      user = MyApp.Repo.update!(changeset)\n      send_resp(conn, 200, \"User data updated successfully\")\n    else\n      send_resp(conn, 400, \"Invalid data\")\n    end\n  end\nend"
      },
      "steps": [
        "Validate user input on the server side",
        "Check the validity of the changeset before updating the user data"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "201",
    "title": "Unauthorized access to files",
    "context": [
      "Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications",
      "Usage of Ecto.Repo for interacting with databases"
    ],
    "need": "To prevent unauthorized access to files",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The Elixir code allows a user to update their data and get access to a specific path in the Sharepoint. However, it doesn't perform any validation or checks on the user input, which could lead to unauthorized access to files.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def update(conn, params) do\n    user = MyApp.Repo.get!(User, params[\"id\"])\n    user = MyApp.Repo.update!(User.changeset(user, params))\n\n    path = \"/sharepoint/files/#{user.id}/\"\n    send_resp(conn, 200, \"File updated at #{path}\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure Elixir code checks whether the user is authenticated and is the same user that is trying to update the data before giving access to the specific path in the Sharepoint.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def update(conn, params) do\n    user = MyApp.Repo.get!(User, params[\"id\"])\n    user = MyApp.Repo.update!(User.changeset(user, params))\n\n    if user && conn.assigns.current_user && conn.assigns.current_user.id == user.id do\n      path = \"/sharepoint/files/#{user.id}/\"\n      send_resp(conn, 200, \"File updated at #{path}\")\n    else\n      send_resp(conn, 403, \"Unauthorized\")\n    end\n  end\nend"
      },
      "steps": [
        "Validate user input",
        "Check whether the user is authenticated",
        "Check whether the authenticated user is the same user that is trying to update the data",
        "Only give access to the specific path in the Sharepoint if the user is authenticated and is the same user that is trying to update the data"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "154",
    "title": "Time-based SQL Injection",
    "context": [
      "Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications",
      "Usage of Ecto.Repo for interacting with databases"
    ],
    "need": "To prevent SQL injection attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The Elixir code directly interpolates user input into a SQL query, which could lead to SQL injection attacks if the user input is not properly sanitized.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def index(conn, params) do\n    users = MyApp.Repo.query!(\"SELECT * FROM users WHERE name = '#{params[\"name\"]}'\")\n    render conn, \"index.html\", users: users\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure Elixir code uses parameterized queries to prevent SQL injection attacks. The user input is no longer directly interpolated into the SQL query, but instead, it is passed as a parameter to the query.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def index(conn, params) do\n    users = MyApp.Repo.query!(\"SELECT * FROM users WHERE name = $1\", [params[\"name\"]])\n    render conn, \"index.html\", users: users\n  end\nend"
      },
      "steps": [
        "Use parameterized queries instead of directly interpolating user input into SQL queries",
        "Pass the user input as a parameter to the query"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "153",
    "title": "Insecure or unset HTTP headers - Accept",
    "context": [
      "Usage of Elixir (v1.12+) for building scalable and concurrent applications",
      "Usage of Plug.Router for handling HTTP requests"
    ],
    "need": "To prevent unexpected behaviors due to content type misinterpretations",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The Elixir code does not set the Accept header or validate the Content-Type of the incoming requests. This could lead to unexpected behaviors when the application interprets incorrect content types.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  match _ do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure Elixir code checks the Content-Type of the incoming requests and only allows application/json. If the Content-Type is different, the application responds with a 406 Not Acceptable status code.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  match _ do\n    case get_req_header(conn, \"content-type\") do\n      [\"application/json\"] -> send_resp(conn, 200, \"Hello, world!\")\n      _ -> send_resp(conn, 406, \"Not Acceptable\")\n    end\n  end\nend"
      },
      "steps": [
        "Check the Content-Type of the incoming requests",
        "Only allow the application/json content type",
        "Respond with a 406 Not Acceptable status code if the Content-Type is different"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "152",
    "title": "Insecure or unset HTTP headers - X-Frame Options",
    "context": [
      "Usage of Elixir (v1.12+) for building scalable and fault-tolerant applications",
      "Usage of Plug.Router for handling HTTP requests"
    ],
    "need": "To prevent clickjacking attacks",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The Elixir code sets the X-Frame-Options header to SAMEORIGIN. This header is deprecated and can be bypassed using several iframe layers, making it vulnerable to clickjacking attacks.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  match _ do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\n\n  defp put_headers(conn) do\n    put_resp_header(conn, \"x-frame-options\", \"SAMEORIGIN\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure Elixir code sets the Content-Security-Policy header with the frame-ancestors 'self' directive, which is a more secure replacement for the X-Frame-Options header.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  match _ do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\n\n  defp put_headers(conn) do\n    put_resp_header(conn, \"content-security-policy\", \"frame-ancestors 'self'\")\n  end\nend"
      },
      "steps": [
        "Replace the X-Frame-Options header with the Content-Security-Policy header",
        "Set the frame-ancestors directive to 'self' to allow the page to be framed only by pages from the same origin"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "141",
    "title": "Lack of Data Validation - URL",
    "context": [
      "Usage of Elixir (version 1.12 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix framework for building real-time web applications",
      "User authentication implementation"
    ],
    "need": "To prevent unauthorized access to user data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The Elixir code directly uses the date parameter from the URL to fetch documents. There are no checks to verify if the current user has the rights to access these documents.",
        "text": "defmodule PortalController do\n  use PortalWeb, :controller\n\n  def show(conn, %{\"date\" => date}) do\n    docs = Portal.get_documents_by_date(date)\n    render(conn, \"show.html\", docs: docs)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure Elixir code first gets the current user. If the user exists and they have the necessary permissions to access the documents, we proceed as before. Otherwise, we display an error message and redirect the user to the home page.",
        "text": "defmodule PortalController do\n  use PortalWeb, :controller\n\n  def show(conn, %{\"date\" => date}) do\n    user = get_current_user(conn)\n    if user and Portal.user_can_access_documents?(user) do\n      docs = Portal.get_documents_by_date(date)\n      render(conn, \"show.html\", docs: docs)\n    else\n      conn\n      |> put_flash(:error, \"You are not authorized to access this page.\")\n      |> redirect(to: \"/\")\n    end\n  end\nend"
      },
      "steps": [
        "Retrieve the current user",
        "Check if the user has the necessary permissions to access the documents",
        "If the user is authorized, proceed as before",
        "If the user is not authorized, display an error message and redirect them to the home page"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "021",
    "title": "XPath Injection Vulnerability",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of sweet_xml for parsing and manipulating XML data",
      "Usage of XML data manipulation"
    ],
    "need": "Prevent unauthorized data access through XPath Injection",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is vulnerable because it takes a user-provided value (`user_input`) directly to construct an XPath expression. An attacker could exploit this to modify the XPath query and potentially access sensitive information.",
        "text": "def vulnerable(user_input) do\n  {:ok, doc} = File.read('data.xml')\n  xpath = \"//user[username/text() = '\" <> user_input <> \"']\"\n  SweetXml.xpath(doc, xpath)\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it sanitizes the user input by escaping special characters before using it in the XPath expression. It ensures that the user input is treated as literal text, not part of the XPath expression, preventing injection attacks.",
        "text": "def secure(user_input) do\n  {:ok, doc} = File.read('data.xml')\n  sanitized_input = String.replace(user_input, \"'\", \"''\")\n  xpath = \"//user[username/text() = '\" <> sanitized_input <> \"']\"\n  SweetXml.xpath(doc, xpath)\nend"
      },
      "steps": [
        "Upgrade to the latest version of Elixir and the sweet_xml library if not done already",
        "Always sanitize user-provided input before using in XPath expressions",
        "Use parameterized queries instead of string concatenation to build XPath expressions"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "010",
    "title": "Stored Cross-Site Scripting (XSS)",
    "context": [
      "Usage of Elixir 1.13.0 for building scalable and fault-tolerant applications",
      "Usage of Ecto for database query and manipulation",
      "Usage of Phoenix.HTML for building HTML",
      "Usage of application state management for dynamic content generation"
    ],
    "need": "Prevent persistent injection of malicious scripts into application fields",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This vulnerable code saves user-provided messages directly to the database without sanitizing the input first. Then it uses this data to generate dynamic content on the index page. An attacker can store a malicious script in the message, which will be executed by the user's browser when the index page is loaded.",
        "text": "defmodule VulnerableController do\n  use MyWeb, :controller\n\n  def create(conn, %{\"message\" => message_params}) do\n    %Message{} |> Message.changeset(message_params) |> Repo.insert()\n    redirect(conn, to: message_path(conn, :index))\n  end\n\n  def index(conn, _params) do\n    messages = Repo.all(Message)\n    render(conn, \"index.html\", messages: messages)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure code uses the 'h' function from the Phoenix.HTML package to sanitize user-provided input before saving it to the database. This ensures that any HTML special characters in the input are escaped, preventing them from being interpreted as part of the HTML markup. This mitigates the stored XSS vulnerability by preventing scripts from being stored and later executed in the user's browser.",
        "text": "defmodule SecureController do\n  use MyWeb, :controller\n  use Phoenix.HTML\n\n  def create(conn, %{\"message\" => message_params}) do\n    sanitized_params = %{\"content\" => h(message_params[\"content\"])}\n    %Message{} |> Message.changeset(sanitized_params) |> Repo.insert()\n    redirect(conn, to: message_path(conn, :index))\n  end\n\n  def index(conn, _params) do\n    messages = Repo.all(Message)\n    render(conn, \"index.html\", messages: messages)\n  end\nend"
      },
      "steps": [
        "Use the functions provided by the Phoenix.HTML package to sanitize user input before storing it in the database.",
        "Replace raw database data with the 'h' function from Phoenix.HTML when generating dynamic content."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "008",
    "title": "Reflected Cross-Site Scripting (XSS)",
    "context": [
      "Usage of Elixir 1.13.0 for building scalable and fault-tolerant applications",
      "Usage of Plug for request management",
      "Dynamic content generation"
    ],
    "need": "Prevent injection of malicious scripts into dynamically generated web content",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The '/search' endpoint uses user-provided input directly in the output content. If an attacker provides a script as part of the 'query' parameter, this script will be reflected back in the response and executed by the user's browser, resulting in a reflected XSS vulnerability.",
        "text": "defmodule VulnerableController do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/search\" do\n    results = Search.query(conn.params[\"query\"])\n    send_resp(conn, 200, \"Search results for: #{conn.params[\"query\"]}\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This solution introduces the use of the 'h' function from the Phoenix.HTML package to sanitize user-provided input. It ensures that any HTML special characters in the input are escaped, preventing them from being interpreted as part of the HTML markup. This prevents scripts from being executed in the user's browser, mitigating the reflected XSS vulnerability.",
        "text": "defmodule SecureController do\n  use Plug.Router\n  use Phoenix.HTML\n\n  plug :match\n  plug :dispatch\n\n  get \"/search\" do\n    results = Search.query(conn.params[\"query\"])\n    safe_query = Phoenix.HTML.raw(h(conn.params[\"query\"]))\n    send_resp(conn, 200, \"Search results for: #{safe_query}\")\n  end\nend"
      },
      "steps": [
        "Use the functions provided by the Phoenix.HTML package to sanitize user input before including it in dynamic content.",
        "Replace string interpolation with the 'h' function from Phoenix.HTML when generating dynamic content."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "007",
    "title": "Cross-Site Request Forgery",
    "context": [
      "Usage of Elixir 1.13.0 for functional programming and building scalable applications",
      "Usage of Plug for request management",
      "Usage of Plug.CSRFProtection for protecting against CSRF attacks",
      "Usage of cookie-based sessions for application authentication and state management"
    ],
    "need": "Prevent attackers from tricking authenticated users into executing actions without their consent.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The endpoint '/change_password' changes the password of a user based on the provided parameters. However, it does not validate the authenticity of the request, making it vulnerable to CSRF attacks. An attacker can create a malicious site that sends a POST request to this endpoint, changing the password without the user's knowledge or consent.",
        "text": "defmodule VulnerableController do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"/change_password\" do\n    # Change password logic here\n    User.change_password(conn.params[\"new_password\"])\n    send_resp(conn, 200, \"Password changed successfully\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This solution introduces CSRF protection by including Plug.CSRFProtection in the controller. This plug will automatically generate and validate CSRF tokens in the session. Any state-modifying operation will require a valid CSRF token, otherwise, a 'Invalid CSRF token.' message is returned to the client, thus preventing CSRF attacks.",
        "text": "defmodule SecureController do\n  use Plug.Router\n  use Plug.CSRFProtection\n\n  plug :match\n  plug :dispatch\n  plug :put_secure_browser_headers\n\n  post \"/change_password\" do\n    with :ok <- check_csrf_token(conn) do\n      User.change_password(conn.params[\"new_password\"])\n      send_resp(conn, 200, \"Password changed successfully\")\n    else\n      _ -> send_resp(conn, 403, \"Invalid CSRF token.\")\n    end\n  end\nend"
      },
      "steps": [
        "Import the Plug.CSRFProtection package in your controller.",
        "Add a plug to the controller to use CSRF protection.",
        "Ensure every form or action that modifies state on the server includes the CSRF token in the request."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "003",
    "title": "Symmetric Denial of Service",
    "context": [
      "Usage of Elixir 1.13.0 for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for request management",
      "Usage of a library for handling extensive data processing or resource-intensive tasks"
    ],
    "need": "Prevent a sequence of repeated requests from consuming excessive resources, leading to denial of service.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The endpoint '/long_running_task' executes a long running task which can consume significant system resources. An attacker can exploit this by making repeated requests, causing the system to become overwhelmed and potentially leading to denial of service.",
        "text": "defmodule VulnerableController do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"/long_running_task\" do\n    # Long running task here\n    intensive_data_processing(conn.params[\"data\"])\n    send_resp(conn, 200, \"Task completed\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This solution implements rate limiting using the plug_attack package and adds a timeout to the long running task. These changes help ensure that no sequence of repeated requests can consume too many resources, thus mitigating the denial of service risk. If the task doesn't finish within the specified time, a 'Server is busy. Please try again later.' message is sent to the client.",
        "text": "defmodule SecureController do\n  use Plug.Router\n  use PlugAttack\n\n  plug :match\n  plug :dispatch\n  plug PlugAttack.Blocker, otp_app: :my_app\n\n  plug PlugAttack.RateLimiter,\n    name: \"api/ip\",\n    interval: 60_000,\n    allow: 100\n\n  post \"/long_running_task\" do\n    with {:ok, _result} <- Task.await(long_running_task(conn.params[\"data\"]), 5000) do\n      send_resp(conn, 200, \"Task completed\")\n    else\n      _ -> send_resp(conn, 503, \"Server is busy. Please try again later.\")\n    end\n  end\nend"
      },
      "steps": [
        "Implement rate limiting using the plug_attack package to limit the number of requests a single client can make in a given period of time.",
        "Implement a timeout for long running tasks to prevent operations from consuming resources indefinitely.",
        "Handle potential errors or exceptions during the data processing to prevent crashes."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "002",
    "title": "Asymmetric Denial of Service",
    "context": [
      "Usage of Elixir 1.13.0 for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for request management",
      "Usage of a library for handling extensive data processing or resource-intensive tasks"
    ],
    "need": "Prevent single requests from overwhelming the application by using excessive resources, thus causing denial of service.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The endpoint '/intensive_task' performs intensive data processing which can consume significant system resources. An attacker can exploit this by making repeated or specially crafted requests, causing the system to become overwhelmed and potentially resulting in denial of service.",
        "text": "defmodule VulnerableController do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"/intensive_task\" do\n    # Some resource-intensive task here\n    intensive_data_processing(conn.params[\"data\"])\n    send_resp(conn, 200, \"Task completed\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This solution implements rate limiting using the plug_attack package and adds a timeout to the resource-intensive task. These changes help ensure that no single request or user can consume too many resources, thus mitigating the denial of service risk. If the task doesn't finish within the specified time, a 'Server is busy. Please try again later.' message is sent to the client.",
        "text": "defmodule SecureController do\n  use Plug.Router\n  use PlugAttack\n\n  plug :match\n  plug :dispatch\n  plug PlugAttack.Blocker, otp_app: :my_app\n\n  plug PlugAttack.RateLimiter,\n    name: \"api/ip\",\n    interval: 60_000,\n    allow: 100\n\n  post \"/intensive_task\" do\n    with {:ok, _result} <- Task.await(intensive_data_processing(conn.params[\"data\"]), 5000) do\n      send_resp(conn, 200, \"Task completed\")\n    else\n      _ -> send_resp(conn, 503, \"Server is busy. Please try again later.\")\n    end\n  end\nend"
      },
      "steps": [
        "Implement rate limiting using the plug_attack package to limit the number of requests a single client can make in a given period of time.",
        "Implement a timeout for intensive data processing task to prevent operations from consuming resources indefinitely.",
        "Handle potential errors or exceptions during the data processing to prevent crashes."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "119",
    "title": "Metadata with Sensitive Information",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Logger module for logging and debugging purposes"
    ],
    "need": "Prevent exposure of sensitive information through metadata.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code can be vulnerable as it logs the entire connection object, including potentially sensitive information such as headers or parameters. If these logs are accessible, it could lead to an information leak.",
        "text": "defmodule MyController do\n  use Plug.Logger\n\n  def handle_request(conn, _params) do\n    Logger.debug(fn -> inspect(conn) end)\n    send_resp(conn, 200, \"OK\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safer as it only logs a generic message, instead of the entire connection object. Thus, no sensitive information is logged.",
        "text": "defmodule MyController do\n  use Plug.Logger\n\n  def handle_request(conn, _params) do\n    Logger.debug(fn -> \"Processing request\" end)\n    send_resp(conn, 200, \"OK\")\n  end\nend"
      },
      "steps": [
        "Avoid logging sensitive information, such as keys, secrets or personally identifiable information.",
        "If sensitive data needs to be logged for debugging purposes, ensure it is appropriately masked or anonymized.",
        "Consider using a log management solution that provides access control, encryption and log retention capabilities."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "120",
    "title": "Improper Dependency Pinning",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and concurrent applications",
      "Usage of Mix for managing assets in Laravel"
    ],
    "need": "Prevent installation of unsupported or vulnerable dependencies.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code can be vulnerable as it specifies a minimum version for 'plug', which means any version higher than 1.0.0 could be installed, including potentially incompatible or vulnerable versions. The cowboy dependency uses a version range which could potentially install a version with known vulnerabilities.",
        "text": "defp deps do\n  [\n    {:plug, \">= 1.0.0\"},\n    {:cowboy, \"~> 2.1\"}\n  ]\nend"
      },
      "secure_code_example": {
        "description": "This code is safer as it specifies the exact versions of the dependencies to be used. This ensures that known, compatible versions are installed, reducing the risk of installing incompatible or vulnerable dependencies.",
        "text": "defp deps do\n  [\n    {:plug, \"1.12.1\"},\n    {:cowboy, \"2.8.0\"}\n  ]\nend"
      },
      "steps": [
        "Specify the exact versions of the dependencies.",
        "Regularly update the dependencies and thoroughly test the application after updates."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "122",
    "title": "Email Flooding",
    "context": [
      "Usage of Elixir (version 1.11 and above) for building scalable and fault-tolerant applications",
      "Usage of Bamboo library for sending emails"
    ],
    "need": "Prevent uncontrolled email sending that can lead to inbox saturation or spamming.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this example, the handle_request function sends an email to every user in a request without any rate limiting. This allows for potential email flooding if the users list is large or if requests are sent consecutively with little time in between.",
        "text": "def send_email(user, message) do\n  new_email(to: user.email, subject: \"Alert\", body: message)\n  |> Mailer.deliver_now()\nend\n\ndef handle_request(request) do\n  Enum.each(request.users, &send_email(&1, request.message))\nend"
      },
      "secure_code_example": {
        "description": "This code introduces rate limiting by using the deliver_later() function, which queues the emails for later delivery rather than sending them immediately. It also limits the number of users that can receive an email in a single request to 100.",
        "text": "def send_email(user, message) do\n  new_email(to: user.email, subject: \"Alert\", body: message)\n  |> Mailer.deliver_later()\nend\n\ndef handle_request(request) do\n  request.users\n  |> Enum.take(100)\n  |> Enum.each(&send_email(&1, request.message))\nend"
      },
      "steps": [
        "Introduce a delay between each email send.",
        "Limit the number of emails that can be sent in a given time period.",
        "Validate and sanitize user input to prevent abuse."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "125",
    "title": "Directory Listing",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Plug.Static library for serving static files in Elixir"
    ],
    "need": "Prevent unauthorized listing of directory contents that could reveal sensitive information or application structure.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This configuration in the endpoint.ex file serves static assets from the root directory and its subdirectories. If the server is incorrectly configured or if an index file is not present, it allows anyone to list all files in these directories.",
        "text": "plug Plug.Static, \n  at: \"/\",\n  from: :app,\n  gzip: false,\n  only: ~w(css fonts images js favicon.ico robots.txt)"
      },
      "secure_code_example": {
        "description": "The 'index' option is added to the configuration. This enforces the 'index.html' file to be served when a directory is accessed. Thus, the content of the directory is not listed and the vulnerability is mitigated.",
        "text": "plug Plug.Static, \n  at: \"/\",\n  from: :app,\n  gzip: false,\n  index: 'index.html',\n  only: ~w(css fonts images js favicon.ico robots.txt)"
      },
      "steps": [
        "Disable directory listing in the server settings.",
        "Enforce an index file to be served when a directory is accessed.",
        "Ensure that only necessary files are publicly accessible."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "136",
    "title": "Insecure or unset HTTP headers - Cache Control",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Plug for HTTP request and response handling"
    ],
    "need": "Prevent caching of sensitive data by client browsers and intermediate proxies",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this code, the application responds to every request with 'Hello, world!' but does not set any Cache-Control headers. This could lead to sensitive data being cached by the client browser or intermediate proxies.",
        "text": "defmodule MyApp do\n  use Plug.Builder\n  def start_link(_) do\n    Plug.Adapters.Cowboy.http __MODULE__, []\n  end\n  plug :index\n  def index(conn, _opts) do\n    conn\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Hello, world!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this revised code, the application sets a Cache-Control header with the value 'no-store, no-cache, must-revalidate' on all responses. This instructs the client browser and any intermediate proxies not to store the response, thereby preventing the caching of sensitive data.",
        "text": "defmodule MyApp do\n  use Plug.Builder\n  def start_link(_) do\n    Plug.Adapters.Cowboy.http __MODULE__, []\n  end\n  plug :index\n  def index(conn, _opts) do\n    conn\n    |> put_resp_header(\"cache-control\", \"no-store, no-cache, must-revalidate\")\n    |> put_resp_content_type(\"text/plain\")\n    |> send_resp(200, \"Hello, world!\")\n  end\nend"
      },
      "steps": [
        "Update the application to set appropriate Cache-Control headers on all responses. The specific value will depend on your application, but 'no-store, no-cache, must-revalidate' is a common secure value."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "142",
    "title": "Sensitive information in source code - API Key",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of HTTPoison for making HTTP requests in Elixir"
    ],
    "need": "Prevent exposure of sensitive data in the source code",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this code, the application has a secret API key hardcoded directly in the source code. This is dangerous because anyone with access to the source code can see and potentially misuse the API key. Even if the source code is not intended to be public, it can be accidentally exposed, or access could be obtained through a breach.",
        "text": "defmodule MyApp do\n  @api_key \"MySecretApiKey\"\n  def request_data do\n    HTTPoison.get!(\"https://example.com/data\", [], [params: [\"api_key\": @api_key]])\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this revised code, the application loads the API key from an environment variable. This is safer because the actual value of the API key is not included in the source code, and can be managed securely on the server. This prevents the API key from being exposed if the source code is accidentally made public or accessed through a breach.",
        "text": "defmodule MyApp do\n  def request_data do\n    api_key = System.get_env(\"API_KEY\")\n    HTTPoison.get!(\"https://example.com/data\", [], [params: [\"api_key\": api_key]])\n  end\nend"
      },
      "steps": [
        "Store the API key in an environment variable rather than hardcoding it in the source code.",
        "Load the API key from the environment variable in your Elixir code."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "145",
    "title": "Inappropriate coding practices - Cyclomatic complexity",
    "context": [
      "Usage of Elixir (v1.11+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications with Elixir"
    ],
    "need": "Enhance maintainability and security of the code",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this code, the function `complex_function` has a high cyclomatic complexity due to multiple nested if-else statements. High cyclomatic complexity makes the code difficult to read, maintain, and test. It could also increase the probability of bugs or vulnerabilities, as it's harder to understand all possible execution paths.",
        "text": "defmodule Unsafe do\n  def complex_function(a, b, c, d) do\n    if a do\n      if b do\n        if c do\n          if d do\n            IO.puts 'abcd'\n          else\n            IO.puts 'abc'\n          end\n        else\n          IO.puts 'ab'\n        end\n      else\n        IO.puts 'a'\n      end\n    else\n      IO.puts 'none'\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this revised code, the function `simple_function` is much easier to read and understand. It uses the `cond` statement to clearly show the different conditions and their outcomes. This reduces the cyclomatic complexity and makes the function easier to test and maintain.",
        "text": "defmodule Safe do\n  def simple_function(a, b, c, d) do\n    cond do\n      a && b && c && d -> IO.puts 'abcd'\n      a && b && c -> IO.puts 'abc'\n      a && b -> IO.puts 'ab'\n      a -> IO.puts 'a'\n      true -> IO.puts 'none'\n    end\n  end\nend"
      },
      "steps": [
        "Decompose the function into smaller, simpler functions",
        "Replace nested if-else statements with cleaner control structures, like pattern matching"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "146",
    "title": "SQL Injection",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of PostgreSQL database for data storage and retrieval",
      "Usage of Ecto for database handling"
    ],
    "need": "Prevent unauthorized extraction or manipulation of data in the database",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code above is vulnerable to SQL Injection because it directly concatenates a user-provided string (id) into a SQL query. An attacker could provide a malicious string that alters the SQL query to expose sensitive data or execute unauthorized SQL commands.",
        "text": "def get_user_data(conn, %{\"id\" => id}) do\n Repo.query(\"SELECT * FROM users WHERE id = \" <> id)\nend"
      },
      "secure_code_example": {
        "description": "The code above is secure because it uses Ecto's query API to construct the SQL query, which automatically escapes variables to prevent SQL Injection. It also converts the user input to an integer, providing an extra layer of security.",
        "text": "def get_user_data(conn, %{\"id\" => id}) do\n  id = String.to_integer(id)\n  query = from u in \"users\", where: u.id == ^id\n  Repo.one(query)\nend"
      },
      "steps": [
        "Utilize Ecto.Query API to create SQL queries instead of string concatenation.",
        "Always validate and sanitize user inputs before using them in SQL queries.",
        "Limit the permissions of the database user used by the application."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "149",
    "title": "Use of Insecure SMTP Channel",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Swoosh library for email sending"
    ],
    "need": "Ensure confidentiality and integrity of data during transmission",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code above is vulnerable because it sends an email using the Swoosh SMTP adapter without encryption (tls: :none). This means that all data sent in the email can be easily intercepted and read by any party that can listen on the network.",
        "text": "def send_email(email) do\n  {:ok, pid} = Swoosh.Adapters.SMTP.start_link(port: 25, tls: :none)\n  email |> MyApp.Mailer.deliver(pid)\nend"
      },
      "secure_code_example": {
        "description": "The secure code uses the SMTPS protocol which operates on port 465 and uses SSL/TLS to encrypt the communication channel. The 'ssl_opts' option is set to use TLS version 1.2 which is currently considered secure.",
        "text": "def send_email(email) do\n  {:ok, pid} = Swoosh.Adapters.SMTP.start_link(port: 465, tls: :always, ssl_opts: [{:versions, [:'tlsv1.2']}])\n  email |> MyApp.Mailer.deliver(pid)\nend"
      },
      "steps": [
        "Enable SSL/TLS in the SMTP settings.",
        "Ensure the use of valid and trusted certificates.",
        "Perform periodic reviews and updates of security configurations."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "155",
    "title": "SQL Injection via Headers",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug.Conn for handling requests",
      "Usage of Ecto for database operations"
    ],
    "need": "Ensure integrity and confidentiality of data and prevent unauthorized database operations",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code above is vulnerable as it uses the 'idClient' header value directly in a SQL query. This allows an attacker to inject arbitrary SQL code into the query through the 'idClient' header.",
        "text": "def handle_req(%Plug.Conn{headers: headers} = conn, _) do\n  id_client = List.keyfind(headers, \"idClient\", 0) |> elem(1)\n  MyApp.Repo.query(\"SELECT * FROM clients WHERE id = #{id_client}\")\nend"
      },
      "secure_code_example": {
        "description": "The secure code uses query binding to create the SQL query, which ensures the input from 'idClient' header is properly escaped and treated as a value, not a part of the SQL command. This prevents SQL Injection attacks.",
        "text": "def handle_req(%Plug.Conn{headers: headers} = conn, _) do\n  id_client = List.keyfind(headers, \"idClient\", 0) |> elem(1)\n  MyApp.Repo.query(\"SELECT * FROM clients WHERE id = ?\", [id_client])\nend"
      },
      "steps": [
        "Use query binding instead of string interpolation to create SQL queries.",
        "Ensure user input can't modify the intended SQL query structure.",
        "Regularly update your dependencies to include patches for security vulnerabilities."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "156",
    "title": "Uncontrolled External Site Redirect",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug.Conn for handling requests"
    ],
    "need": "Prevent unauthorized redirection to potentially malicious external sites",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code above is vulnerable as it takes a 'redirect_to' parameter from the request and uses it directly to redirect the user. An attacker can manipulate the 'redirect_to' parameter to redirect users to a malicious website.",
        "text": "def handle_req(%Plug.Conn{params: params} = conn, _) do\n  redirect_to = Map.get(params, \"redirect_to\")\n  conn |> redirect(external: redirect_to)\nend"
      },
      "secure_code_example": {
        "description": "The secure code checks the 'redirect_to' parameter against a list of allowed URLs before making the redirection. This ensures that the user can't be redirected to a malicious website even if they manipulate the 'redirect_to' parameter.",
        "text": "def handle_req(%Plug.Conn{params: params} = conn, _) do\n  redirect_to = Map.get(params, \"redirect_to\")\n  allowed_urls = [\"http://safe1.com\", \"http://safe2.com\"]\n  if redirect_to in allowed_urls, do: conn |> redirect(external: redirect_to)\nend"
      },
      "steps": [
        "Do not use user-provided inputs to set the 'external' option in the redirect function.",
        "If you have to redirect based on user inputs, maintain a whitelist of allowed URLs and check against it.",
        "Regularly update your dependencies to include patches for security vulnerabilities."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "027",
    "title": "Insecure File Upload",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug.Upload for file handling"
    ],
    "need": "Prevent upload of files with double extensions or unsafe extensions",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code above is vulnerable as it accepts any uploaded file without validating its extension or content. This can allow an attacker to upload a file with a double extension or an unsafe extension like .html, .php, .exe, or files containing malicious code.",
        "text": "def upload_file(conn, %{\"file\" => %Plug.Upload{} = upload}) do\n  {:ok, file_path} = File.cp(upload.path, \"/uploads/#{upload.filename}\")\n  send_resp(conn, 200, \"File Uploaded Successfully\")\nend"
      },
      "secure_code_example": {
        "description": "The secure code validates the uploaded file's extension and ensures it's in a list of allowed extensions. It also scans the file for any malicious content using an antivirus software API. This effectively mitigates the risk of uploading files with double extensions, unsafe extensions, or files containing malicious code.",
        "text": "def upload_file(conn, %{\"file\" => %Plug.Upload{} = upload}) do\n  allowed_extensions = ~w(.jpg .jpeg .png)\n  file_extension = Path.extname(upload.filename)\n  if file_extension in allowed_extensions and antivirus_scan(upload.path) do\n    {:ok, file_path} = File.cp(upload.path, \"/uploads/#{upload.filename}\")\n    send_resp(conn, 200, \"File Uploaded Successfully\")\n  else\n    send_resp(conn, 400, \"Invalid File\")\n  end\nend\n\ndefp antivirus_scan(file_path) do\n  # Call antivirus API\nend"
      },
      "steps": [
        "Add a validation function to check the file's extension and ensure it's in a list of safe extensions.",
        "Use an antivirus software API to scan the uploaded file for malicious content before saving it to the server.",
        "Ensure the 'Content-Type' of the file matches the file's extension."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "053",
    "title": "Lack of Protection Against Brute Force Attacks",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug for request handling",
      "Usage of Phoenix framework for building web applications"
    ],
    "need": "Prevent automated attacks designed to guess credentials",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it does not implement any control mechanism against brute force attacks. It simply checks if the credentials are valid and responds accordingly. This allows an attacker to try different combinations of usernames and passwords until they find a match.",
        "text": "def handle_post(%{params: %{\"username\" => username, \"password\" => password}} = conn, _opts) do\n  if Users.validate_credentials(username, password) do\n    conn |> send_resp(200, \"Logged in!\")\n  else\n    conn |> send_resp(401, \"Invalid credentials\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure code integrates a rate limiting mechanism using the RateLimiter module, which limits the number of login attempts for the same username. It also includes a CAPTCHA system using the Captcha module. If either the rate limit has been reached or the CAPTCHA verification fails, the user is not allowed to attempt to log in.",
        "text": "def handle_post(%{params: %{\"username\" => username, \"password\" => password}} = conn, _opts) do\n  if RateLimiter.allow_request(username) and Captcha.verify(conn.params[\"captcha\"]) and Users.validate_credentials(username, password) do\n    conn |> send_resp(200, \"Logged in!\")\n  else\n    conn |> send_resp(401, \"Invalid credentials or too many attempts\")\n  end\nend\n\ndefmodule RateLimiter do\n  def allow_request(username) do\n    # Rate limiting logic here\n  end\nend\n\ndefmodule Captcha do\n  def verify(captcha_response) do\n    # Captcha verification logic here\n  end\nend"
      },
      "steps": [
        "Integrate a rate limiting mechanism in your application to limit the number of login attempts from the same IP address or for the same username in a certain period.",
        "Use a CAPTCHA system to prevent automated scripts from making login attempts.",
        "Implement account lockout policy after a certain number of failed login attempts."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "091",
    "title": "Log Injection",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug for request handling",
      "Usage of Phoenix framework for building web applications",
      "Usage of Logger for standard logging"
    ],
    "need": "Prevent compromising log integrity or system safety by log injection",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it directly logs user-provided input without sanitizing it. An attacker could inject malicious content into the logs via this input, potentially compromising the integrity of the logs or even the system of the person viewing the logs.",
        "text": "def handle_post(%{params: %{\"user_input\" => input}} = conn, _opts) do\n  Logger.info(\"User input: #{input}\")\n  # further code\nend"
      },
      "secure_code_example": {
        "description": "The secure code example sanitizes the user input before logging it, helping prevent log injection attacks. The sanitize_input function would contain the appropriate logic for sanitizing the input, such as stripping control characters or escaping special characters.",
        "text": "def handle_post(%{params: %{\"user_input\" => input}} = conn, _opts) do\n  sanitized_input = sanitize_input(input)\n  Logger.info(\"User input: #{sanitized_input}\")\n  # further code\nend\n\ndef sanitize_input(input) do\n  # Sanitization logic, e.g., escaping special characters\nend"
      },
      "steps": [
        "Sanitize user inputs before storing them in the log. This can be achieved by encoding special characters or stripping control characters.",
        "Avoid using user-provided input directly in logs where possible.",
        "Consider the use of structured logging, which can make injection attacks harder."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "159",
    "title": "Excessive Privileges in Applications",
    "context": [
      "Usage of Elixir (version 1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug for request handling",
      "Usage of Phoenix framework for building web applications",
      "Usage of Coherence for user management and authentication"
    ],
    "need": "Prevent unauthorized privilege escalation",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it directly updates user information, including their privileges, based on the provided parameters without any checks. An attacker could exploit this to grant themselves excessive permissions.",
        "text": "def update_user(conn, %{\"user\" => user_params}) do\n  user = Repo.get(User, user_params[\"id\"])\n  changeset = User.changeset(user, user_params)\n  Repo.update!(changeset)\n  # further code\nend"
      },
      "secure_code_example": {
        "description": "The secure code example checks whether the current user is the same as the one being updated, and also checks that the 'role' parameter is not being changed. This helps to prevent privilege escalation attacks by not allowing users to modify their own privileges.",
        "text": "def update_user(conn, %{\"user\" => user_params}) do\n  user = Repo.get(User, user_params[\"id\"])\n  if conn.assigns.current_user.id == user.id and !user_params[\"role\"] do\n    changeset = User.changeset(user, user_params)\n    Repo.update!(changeset)\n  else\n    # return error\n  end\n  # further code\nend"
      },
      "steps": [
        "Implement strict access controls, only allowing users to update their own profiles and not to modify their privileges.",
        "Check the user role before executing any action and restrict updates to user roles.",
        "Apply the principle of least privilege, ensuring users only have the permissions necessary to perform their tasks."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "160",
    "title": "Excessive Privileges in Temporary Files in Applications",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug for request handling",
      "Usage of Phoenix framework for building web applications"
    ],
    "need": "Prevent unauthorized access to temporary files",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it creates a temporary file in the default '/tmp' directory and writes sensitive data into it. Any other user on the same system can read the file and potentially misuse the data.",
        "text": "File.mkdir(\"/tmp/my_temp_dir\")\nFile.write!({\"/tmp/my_temp_dir\", \"my_temp_file\"}, \"sensitive data\")"
      },
      "secure_code_example": {
        "description": "This secure code example creates a temporary directory in a way that respects the operating system’s conventions. It then sets the file permissions to 0600, making the file only readable and writable by the owner. Finally, it writes the sensitive data to the file.",
        "text": "File.mkdir_p!({:ok, path} = File.mktemp(System.tmp_dir(), \"my_temp_dir\"))\nFile.chmod!(path, 0o600)\nFile.write!({path, \"my_temp_file\"}, \"sensitive data\")"
      },
      "steps": [
        "Use a safer alternative like `Path.join(System.tmp_dir(), \"my_temp_dir\")` to get a path to a temporary directory which respects the operating system’s conventions.",
        "Make sure the directory is only readable and writable by the owner with a permission mask of 0600."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "148",
    "title": "Use of Insecure Channel - FTP in Applications",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug for request handling",
      "Usage of Phoenix framework for building scalable web applications",
      "Usage of ftp module for FTP communication"
    ],
    "need": "Secure transmission of customer information",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it uses the FTP protocol to transmit customer information which does not use encryption. This means that the data can be easily intercepted and read in plain text during transit, which could potentially lead to unauthorized access or data leakage.",
        "text": "{:ok, pid} = :ftp.open('ftp.example.com', [user: 'username', password: 'password'])\n:ftp.send_cmd(pid, 'RETR somefile.txt')"
      },
      "secure_code_example": {
        "description": "This secure code example uses the SFTP protocol for file transfer which uses encryption to secure the data in transit. This ensures that even if the data is intercepted, it cannot be read in plain text.",
        "text": "{:ok, conn} = :ssh.connect('sftp.example.com', 22, [user: 'username', password: 'password'])\n{:ok, channel} = :ssh_sftp.start_channel(conn)\n:ssh_sftp.download(channel, '/remote/path/to/somefile.txt', '/local/path/to/somefile.txt')"
      },
      "steps": [
        "Replace FTP (File Transfer Protocol) with SFTP (SSH File Transfer Protocol) for secure file transfer.",
        "Use the :ssh_sftp module in Elixir for SFTP communication.",
        "Make sure to include the necessary SSL certificate configurations for secure SFTP communication."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "183",
    "title": "Debugging Enabled in Production",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug.Debugger for debugging Elixir applications"
    ],
    "need": "Prevent sensitive information disclosure",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code, the application is using the Plug.Debugger middleware in a production environment (when Mix.env() == :prod). This means that in the event of a server error, detailed debugging information (like stack traces) will be displayed in the user's browser, which could expose sensitive information about the application's internals.",
        "text": "defmodule MyApp do\n  use Plug.Router\n\n  if Mix.env() == :prod do\n    use Plug.Debugger\n  end\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the updated code, the application only uses the Plug.Debugger middleware when the Mix.env() is :dev, which means during development. In a production environment, no debugging information will be displayed to the user.",
        "text": "defmodule MyApp do\n  use Plug.Router\n\n  if Mix.env() == :dev do\n    use Plug.Debugger\n  end\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\nend"
      },
      "steps": [
        "Ensure that the Plug.Debugger middleware is not used in a production environment.",
        "Regularly review and update application configurations to ensure they are secure."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "184",
    "title": "Lack of Data Validation",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix framework for building web applications"
    ],
    "need": "Prevent injection of malicious characters",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this Elixir code, the application takes user input directly from the request parameters and uses it to create a new User record. This is insecure because there's no validation on the user_params. An attacker could inject potentially malicious characters or pass in invalid data for certain fields.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{\"user\" => user_params}) do\n    %User{} |> User.changeset(user_params) |> Repo.insert!()\n    send_resp(conn, 200, \"User created\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this Elixir code, the application validates user input before using it to create a new User record. The changeset.valid? check ensures that the user_params data is valid before attempting to insert it into the database.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{\"user\" => user_params}) do\n    changeset = User.changeset(%User{}, user_params)\n\n    if changeset.valid? do\n      Repo.insert!(changeset)\n      send_resp(conn, 200, \"User created\")\n    else\n      send_resp(conn, 400, \"Invalid user data\")\n    end\n  end\nend"
      },
      "steps": [
        "Always validate user input on the server-side before using it.",
        "Use Ecto changesets or a similar mechanism for data validation."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "185",
    "title": "Lack of data validation - Header x-amzn-RequestId",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for request handling and server management"
    ],
    "need": "Prevent unauthorized or malicious data injection and Denial of Service (DoS) attacks through the x-amzn-RequestId Header",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code snippet represents a REST API endpoint written in Elixir. The code is vulnerable because it lacks input validation for the x-amzn-RequestId header. It directly takes the value from the header and logs it. An attacker can inject harmful strings or very long strings to cause injection attacks or service denial by exhausting system resources.",
        "text": "defmodule InsecureApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    x_amzn_request_id = get_req_header(conn, \"x-amzn-requestId\")\n    Logger.info \"Received request with ID: #{x_amzn_request_id}\"\n    send_resp(conn, 200, \"Hello, World!\")\n  end\n\n  run InsecureApp\nend"
      },
      "secure_code_example": {
        "description": "This secure code snippet represents a REST API endpoint written in Elixir with data validation for the x-amzn-RequestId header. The 'validate_header' function checks the length of the header value and uses 'String.replace' function to escape dangerous characters. This way, the possibility of injection attacks or service denial is significantly mitigated.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n  import Plug.Conn\n\n  plug :match\n  plug :dispatch\n\n  defp validate_header(header_value) do\n    if String.length(header_value) > 1000,\n      do: {:error, \"Header too long\"}\n    sanitized_value = String.replace(header_value, ~r/[<>\"';()&]/, \"\")\n    {:ok, sanitized_value}\n  end\n\n  get \"/\" do\n    case get_req_header(conn, \"x-amzn-requestId\") |> validate_header do\n      {:ok, valid_request_id} ->\n        Logger.info \"Received request with ID: #{valid_request_id}\"\n        send_resp(conn, 200, \"Hello, World!\")\n      {:error, _reason} ->\n        send_resp(conn, 400, \"Invalid header\")\n    end\n  end\n\n  run SecureApp\nend"
      },
      "steps": [
        "Import and use 'Plug.Conn' for better handling of the request context",
        "Create a new function to validate the x-amzn-RequestId header",
        "In the validation function, check the length of the header and sanitize it to escape any dangerous characters",
        "In the GET handler, call this validation function before using the header value"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "186",
    "title": "Lack of data validation - Web Service",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug and Cowboy for request handling and server management",
      "Usage of Ecto for data persistence"
    ],
    "need": "Prevent injection attacks, server resource exhaustion, and improve the overall security by applying server-side data validation",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code snippet represents a web service written in Elixir. The code is vulnerable because it lacks input validation for the data being sent to the server. It directly takes the user data from the request and inserts it into the database. An attacker can use special characters to inject harmful strings (like SQLi or XSS payloads) or large amounts of data to exhaust the server's resources.",
        "text": "defmodule InsecureApp do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  post \"/data\" do\n    user_data = conn.params[\"user_data\"]\n    Repo.insert(%Data{content: user_data})\n    send_resp(conn, 200, \"Data received\")\n  end\n\n  run InsecureApp\nend"
      },
      "secure_code_example": {
        "description": "This secure code snippet represents a web service written in Elixir with data validation. The 'validate_data' function checks the length of the user data and uses 'String.replace' function to escape dangerous characters. This way, the possibility of injection attacks or server resource exhaustion is significantly mitigated.",
        "text": "defmodule SecureApp do\n  use Plug.Router\n  import Plug.Conn\n\n  plug :match\n  plug :dispatch\n\n  defp validate_data(data) do\n    if String.length(data) > 1000,\n      do: {:error, \"Data too long\"}\n    sanitized_data = String.replace(data, ~r/[<>\"';()&]/, \"\")\n    {:ok, sanitized_data}\n  end\n\n  post \"/data\" do\n    case conn.params[\"user_data\"] |> validate_data do\n      {:ok, valid_data} ->\n        Repo.insert(%Data{content: valid_data})\n        send_resp(conn, 200, \"Data received\")\n      {:error, _reason} ->\n        send_resp(conn, 400, \"Invalid data\")\n    end\n  end\n\n  run SecureApp\nend"
      },
      "steps": [
        "Import and use 'Plug.Conn' for better handling of the request context",
        "Create a new function to validate the user data",
        "In the validation function, check the length of the data and sanitize it to escape any dangerous characters",
        "In the POST handler, call this validation function before using the user data"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "187",
    "title": "Lack of data validation - Source Code",
    "context": [
      "Usage of Elixir (1.10 and above) for building scalable and fault-tolerant applications",
      "Usage of custom-made text processing functionality"
    ],
    "need": "Prevent server crashes caused by the use of dangerous regular expressions",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code snippet in Elixir uses a complex and potentially dangerous regular expression to parse a string. In certain circumstances, an attacker might send a specially crafted string that, when evaluated by this regular expression, would cause a server crash due to the high computational requirement, also known as a ReDoS (Regular Expression Denial of Service) attack.",
        "text": "defmodule InsecureApp do\n  def process(text) do\n    regex = ~r/([a-z]+)*$/\n    Regex.match?(regex, text)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This secure code snippet in Elixir presents a fixed version of the regular expression. The regular expression has been simplified and avoids using quantifiers on groups, which reduces the risk of ReDoS attacks.",
        "text": "defmodule SecureApp do\n  def process(text) do\n    regex = ~r/[a-z]+$/\n    Regex.match?(regex, text)\n  end\nend"
      },
      "steps": [
        "Refactor the regular expression to prevent potential ReDoS attacks",
        "Avoid using quantifiers on groups or backreferences",
        "Test the regular expression with different string inputs to ensure it works as expected"
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "189",
    "title": "Lack of data validation - Content Spoofing",
    "context": [
      "Usage of Elixir (1.12 and above) for building scalable and concurrent applications",
      "Usage of Plug and Cowboy for HTTP request and response handling"
    ],
    "need": "Prevent unauthorized file replacement",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This controller allows a user to upload a file with any name to the 'uploads/' directory. If a file with the same name already exists, it will be overwritten without any checks or validations. This allows an attacker to upload arbitrary files, overwriting any existing files with the same name.",
        "text": "defmodule FileUploadController do\n  use MyApp.Web, :controller\n\n  def create(conn, %{'file' => file_params}) do\n    File.write!(Path.join(\"uploads/\", file_params[\"name\"]), file_params[\"content\"])\n    send_resp(conn, 200, \"File uploaded successfully\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, an additional check has been added to see if a file with the same name already exists before writing the file. If a file already exists with the same name, an error response is returned.",
        "text": "defmodule FileUploadController do\n  use MyApp.Web, :controller\n\n  def create(conn, %{'file' => file_params}) do\n    if File.exists?(Path.join(\"uploads/\", file_params[\"name\"])) do\n      send_resp(conn, 400, \"A file with the same name already exists.\")\n    else\n      File.write!(Path.join(\"uploads/\", file_params[\"name\"]), file_params[\"content\"])\n      send_resp(conn, 200, \"File uploaded successfully\")\n    end\n  end\nend"
      },
      "steps": [
        "Add an additional check before writing the file to see if a file with the same name already exists.",
        "If a file already exists with the same name, return an error response or ask for confirmation before overwriting."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "190",
    "title": "Lack of data validation - Session Cookie",
    "context": [
      "Usage of Elixir (1.12 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug for request handling",
      "Usage of Plug.Session for HTTP session management"
    ],
    "need": "Prevent unauthorized modification of session cookies",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this code, the session value is set based on whatever value is received from the user, without any validation. This allows an attacker to set an arbitrary value for the user_id in the session, potentially impersonating another user.",
        "text": "defmodule SessionController do\n  use MyApp.Web, :controller\n\n  def set_session(conn, %{'session' => session_params}) do\n    conn\n    |> put_session(:user_id, session_params[\"user_id\"])\n    |> send_resp(200, \"Session has been set\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the session parameters are validated before they are used to set the session. If the parameters are not valid, an error response is returned. This prevents an attacker from setting an arbitrary session value.",
        "text": "defmodule SessionController do\n  use MyApp.Web, :controller\n\n  def set_session(conn, %{'session' => session_params}) do\n    if valid_session_params?(session_params) do\n      conn\n      |> put_session(:user_id, session_params[\"user_id\"])\n      |> send_resp(200, \"Session has been set\")\n    else\n      send_resp(conn, 400, \"Invalid session parameters\")\n    end\n  end\n\n  defp valid_session_params?(session_params) do\n    # Implement validation logic here\n  end\nend"
      },
      "steps": [
        "Validate the session parameters before using them to set the session.",
        "If the session parameters are not valid, return an error response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "191",
    "title": "Lack of data validation - Responses",
    "context": [
      "Usage of Elixir (1.12 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug for request handling"
    ],
    "need": "Maintain data integrity by server-side validation of input data",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code fetches a user record and sends it in the response, then takes user data from a subsequent request and updates the user record without any validation. If the received data is invalid, it could lead to data integrity issues.",
        "text": "defmodule UserController do\n  use MyApp.Web, :controller\n\n  def show(conn, params) do\n    user = Repo.get(User, params[\"id\"])\n    render(conn, \"show.json\", user: user)\n  end\n\n  def update(conn, params) do\n    user = Repo.get(User, params[\"id\"])\n    user_changes = Map.from_struct(params[\"user\"])\n    changeset = User.changeset(user, user_changes)\n    case Repo.update(changeset) do\n      {:ok, user} ->\n        render(conn, \"show.json\", user: user)\n      {:error, changeset} ->\n        conn\n        |> put_status(:unprocessable_entity)\n        |> render(MyApp.ChangesetView, \"error.json\", changeset: changeset)\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the incoming user data is validated before it is used to update the user record. If the data is not valid, an error response is returned. This prevents an attacker from submitting invalid data.",
        "text": "defmodule UserController do\n  use MyApp.Web, :controller\n\n  def show(conn, params) do\n    user = Repo.get(User, params[\"id\"])\n    render(conn, \"show.json\", user: user)\n  end\n\n  def update(conn, params) do\n    user = Repo.get(User, params[\"id\"])\n    user_changes = Map.from_struct(params[\"user\"])\n    if valid_user_data?(user_changes) do\n      changeset = User.changeset(user, user_changes)\n      case Repo.update(changeset) do\n        {:ok, user} ->\n          render(conn, \"show.json\", user: user)\n        {:error, changeset} ->\n          conn\n          |> put_status(:unprocessable_entity)\n          |> render(MyApp.ChangesetView, \"error.json\", changeset: changeset)\n      end\n    else\n      send_resp(conn, 400, \"Invalid user data\")\n    end\n  end\n\n  defp valid_user_data?(data) do\n    # Implement validation logic here\n  end\nend"
      },
      "steps": [
        "Validate the incoming data before updating the record.",
        "If the data is not valid, return an error response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "192",
    "title": "Lack of Data Validation - Reflected Parameters",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix framework for request handling"
    ],
    "need": "Prevent XSS vulnerabilities due to unvalidated user input in server error responses",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it directly includes the 'msg' parameter from the user input in the server error response without any validation or sanitization. This can lead to a Cross-Site Scripting (XSS) attack if a user includes malicious script in the 'msg' parameter.",
        "text": "defmodule MyApp.ErrorHandlerController do\n  use MyAppWeb, :controller\n\n  def error(conn, %{'msg' => msg}) do\n    send_resp(conn, 500, msg)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it uses the 'html_escape/1' function from the 'Phoenix.HTML' module to sanitize the 'msg' parameter. This function escapes potentially unsafe characters, thereby preventing any scripts included in the 'msg' parameter from being executed.",
        "text": "defmodule MyApp.ErrorHandlerController do\n  use MyAppWeb, :controller\n\n  def error(conn, %{'msg' => msg}) do\n    sanitized_msg = Phoenix.HTML.html_escape(msg)\n    send_resp(conn, 500, sanitized_msg)\n  end\nend"
      },
      "steps": [
        "Install the 'phoenix_html' library if it's not already included in your project. This library provides functions to escape potentially unsafe characters.",
        "In the error function, use the 'Phoenix.HTML.html_escape/1' function to sanitize the 'msg' parameter before including it in the server response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "193",
    "title": "Lack of Data Validation - Host Header Injection",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug.Conn for request handling"
    ],
    "need": "Prevent unintended redirects due to manipulation of the host header",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it directly uses the 'host' header from the user request to construct the redirection URL without any validation. This can lead to Host Header Injection attacks if a user provides a malicious website as the 'host' header.",
        "text": "defmodule MyApp.HeaderController do\n  use MyAppWeb, :controller\n\n  def redirect(conn, _params) do\n    redirect_to = Map.get(conn.req_headers, \"host\")\n    redirect(conn, external: redirect_to)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it validates the 'host' header against a whitelist of trusted domains before using it to construct the redirection URL. If the 'host' header is not in the trusted domains, it simply returns the connection without redirecting.",
        "text": "defmodule MyApp.HeaderController do\n  use MyAppWeb, :controller\n\n  def redirect(conn, _params) do\n    redirect_to = Map.get(conn.req_headers, \"host\")\n    trusted_domains = Application.get_env(:my_app, :trusted_domains)\n    if redirect_to in trusted_domains do\n      redirect(conn, external: redirect_to)\n    else\n      conn\n    end\n  end\nend"
      },
      "steps": [
        "Define a whitelist of trusted domains in your application configuration.",
        "In the redirect function, validate the 'host' header against the whitelist before using it to construct the redirection URL."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "194",
    "title": "Lack of Data Validation - Input Length",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for request handling"
    ],
    "need": "Prevent overlong content in user input, which can lead to resource exhaustion or other vulnerabilities",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it doesn't validate the length of the 'body' parameter. An attacker can provide a very long input, potentially causing resource exhaustion or other vulnerabilities.",
        "text": "defmodule MyAppWeb.MyController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{\"body\" => body}) do\n    # No input length validation\n    MyApp.create_item(body)\n    send_resp(conn, 200, \"Item created\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it checks the length of the 'body' parameter before using it. If the length exceeds 1000, it returns an error response instead of passing the overlong input to 'MyApp.create_item'.",
        "text": "defmodule MyAppWeb.MyController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{\"body\" => body}) do\n    if String.length(body) > 1000 do\n      send_resp(conn, 400, \"Body is too long\")\n    else\n      MyApp.create_item(body)\n      send_resp(conn, 200, \"Item created\")\n    end\n  end\nend"
      },
      "steps": [
        "Use the 'String.length' function to validate the length of the user input.",
        "Before passing the 'body' parameter to 'MyApp.create_item', check whether the length of 'body' exceeds the acceptable limit. If it does, return an error response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "195",
    "title": "Lack of Data Validation - Headers",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for request handling"
    ],
    "need": "Prevent potential attacks via HTTP headers by validating the data received",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it doesn't validate the 'user-token' header. An attacker can inject potentially harmful content into this header to exploit potential vulnerabilities or achieve an XSS attack.",
        "text": "defmodule MyAppWeb.MyController do\n  use MyAppWeb, :controller\n\n  def show(conn, _params) do\n    # No header validation\n    user_token = get_req_header(conn, \"user-token\")\n    item = MyApp.get_item(user_token)\n    json(conn, item)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it validates the 'user-token' header before using it. If the header contains invalid data, it returns an error response instead of passing the harmful content to 'MyApp.get_item'.",
        "text": "defmodule MyAppWeb.MyController do\n  use MyAppWeb, :controller\n\n  def show(conn, _params) do\n    user_token = get_req_header(conn, \"user-token\")\n    if validate_token(user_token) do\n      item = MyApp.get_item(user_token)\n      json(conn, item)\n    else\n      send_resp(conn, 400, \"Invalid user-token header\")\n    end\n  end\n\n  defp validate_token(token) do\n    # Implement your validation logic here\n  end\nend"
      },
      "steps": [
        "Add a function to validate the 'user-token' header against a set of allowed patterns or values.",
        "Before passing the 'user-token' header to 'MyApp.get_item', call this validation function. If the validation fails, return an error response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "196",
    "title": "Lack of Data Validation - Dates",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for request handling"
    ],
    "need": "Prevent unauthorized changes to product data by validating permissions and data before processing requests",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it doesn't validate the permissions or the dates in 'params' before updating the product. An attacker can ignore frontend restrictions and send a request that the server processes as valid, potentially causing data integrity and availability issues.",
        "text": "defmodule MyAppWeb.ProductController do\n  use MyAppWeb, :controller\n\n  def update(conn, params) do\n    # No permissions or date validation\n    MyApp.update_product(params)\n    send_resp(conn, 200, \"Product updated\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it checks permissions and validates dates before updating the product. If the request fails these checks, it returns an error response instead of processing an invalid or unauthorized request.",
        "text": "defmodule MyAppWeb.ProductController do\n  use MyAppWeb, :controller\n\n  def update(conn, params) do\n    if MyApp.check_permissions(conn) && validate_dates(params) do\n      MyApp.update_product(params)\n      send_resp(conn, 200, \"Product updated\")\n    else\n      send_resp(conn, 403, \"Invalid request\")\n    end\n  end\n\n  defp validate_dates(params) do\n    # Implement your date validation logic here\n  end\nend"
      },
      "steps": [
        "Add a function to check if the current user has permission to modify the product.",
        "Add another function to validate the dates in 'params' before updating the product.",
        "Before calling 'MyApp.update_product', call these two functions. If either check fails, return an error response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "197",
    "title": "Lack of Data Validation - Numbers",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for request handling"
    ],
    "need": "Prevent transactions with invalid values to ensure business logic integrity",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it doesn't validate the transaction value in 'params' before creating the transaction. An attacker can send a request with a lower transaction value, negatively impacting the business.",
        "text": "defmodule MyAppWeb.TransactionController do\n  use MyAppWeb, :controller\n\n  def create(conn, params) do\n    # No transaction value validation\n    MyApp.create_transaction(params)\n    send_resp(conn, 200, \"Transaction created\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it validates the transaction value before creating the transaction. If the request contains an invalid transaction value, it returns an error response instead of creating a transaction with an incorrect value.",
        "text": "defmodule MyAppWeb.TransactionController do\n  use MyAppWeb, :controller\n\n  def create(conn, params) do\n    if validate_transaction_value(params) do\n      MyApp.create_transaction(params)\n      send_resp(conn, 200, \"Transaction created\")\n    else\n      send_resp(conn, 403, \"Invalid transaction value\")\n    end\n  end\n\n  defp validate_transaction_value(params) do\n    # Implement your transaction value validation logic here\n  end\nend"
      },
      "steps": [
        "Add a function to validate the transaction value in 'params' before creating the transaction.",
        "Before calling 'MyApp.create_transaction', call this validation function. If the validation fails, return an error response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "198",
    "title": "Lack of Data Validation - Out of Range",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Plug for request routing"
    ],
    "need": "Prevent unauthorized access to restricted functionalities",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it doesn't validate if the user is authorized to access the employee management panel based on their domain. An attacker can bypass the restrictions by using absolute paths to the employee management panel.",
        "text": "defmodule MyAppWeb.EmployeeController do\n  use MyAppWeb, :controller\n\n  def show(conn, params) do\n    # No domain restriction validation\n    employee = MyApp.get_employee(params[\"id\"])\n    render(conn, \"show.html\", employee: employee)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it validates if the user is authorized to access the employee management panel based on their domain. If the user is not authorized, it returns an 'Access Denied' response.",
        "text": "defmodule MyAppWeb.EmployeeController do\n  use MyAppWeb, :controller\n\n  def show(conn, params) do\n    if authorized_domain?(conn) do\n      employee = MyApp.get_employee(params[\"id\"])\n      render(conn, \"show.html\", employee: employee)\n    else\n      send_resp(conn, 403, \"Access Denied\")\n    end\n  end\n\n  defp authorized_domain?(conn) do\n    # Implement your domain validation logic here\n  end\nend"
      },
      "steps": [
        "Add a function to validate if the user is authorized to access the employee management panel based on their domain.",
        "Before calling 'MyApp.get_employee', call this validation function. If the validation fails, return an error response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "199",
    "title": "Lack of Data Validation - Emails",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Ecto for data validation and changesets"
    ],
    "need": "Prevent usage of disposable email addresses for user registration",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is vulnerable because it doesn't validate whether the provided email address belongs to a disposable email service. An attacker can register and potentially reset the password for users with disposable email addresses, thereby impersonating legitimate users.",
        "text": "defmodule MyApp.Accounts.UserChangeset do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  def changeset(user, attrs) do\n    user\n    |> cast(attrs, [:email])\n    |> validate_required([:email])\n    |> unique_constraint(:email)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it adds an additional validation step to check whether the provided email address belongs to a disposable email service. If it does, an error is added to the changeset, and the registration request is rejected.",
        "text": "defmodule MyApp.Accounts.UserChangeset do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  def changeset(user, attrs) do\n    user\n    |> cast(attrs, [:email])\n    |> validate_required([:email])\n    |> validate_email()\n    |> unique_constraint(:email)\n  end\n\n  defp validate_email(changeset) do\n    if changeset.valid? && disposable_email?(changeset.changes.email) do\n      add_error(changeset, :email, \"Disposable email addresses not allowed\")\n    else\n      changeset\n    end\n  end\n\n  defp disposable_email?(email) do\n    # Implement your disposable email check here\n  end\nend"
      },
      "steps": [
        "Create a function to validate whether an email address belongs to a disposable email service.",
        "Use this function in the changeset to add an additional validation step."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "200",
    "title": "Traceability Loss",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Logger library for logging"
    ],
    "need": "Traceability and monitoring of system events",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is vulnerable because it doesn't log any information about the outcome of the critical action. If a critical action fails or an error occurs, there is no record of this event, making it difficult to identify and analyze the issue.",
        "text": "defmodule MyApp.Service do\n  def critical_action(param1, param2) do\n    case MyApp.Repo.transaction(fun -> do_critical_action(param1, param2) end) do\n      {:ok, _result} -> :ok\n      {:error, _reason} -> :error\n    end\n  end\n\n  defp do_critical_action(param1, param2) do\n    # Implementation of critical action\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it uses the Logger module to log the beginning and outcome of a critical action. If a critical action fails or an error occurs, there is a record of this event, making it easier to identify and analyze the issue.",
        "text": "defmodule MyApp.Service do\n  require Logger\n\n  def critical_action(param1, param2) do\n    Logger.info(\"Starting critical action with #{param1}, #{param2}\")\n\n    case MyApp.Repo.transaction(fun -> do_critical_action(param1, param2) end) do\n      {:ok, result} ->\n        Logger.info(\"Critical action succeeded with result: #{result}\")\n        :ok\n      {:error, reason} ->\n        Logger.error(\"Critical action failed with reason: #{reason}\")\n        :error\n    end\n  end\n\n  defp do_critical_action(param1, param2) do\n    # Implementation of critical action\n  end\nend"
      },
      "steps": [
        "Use the Logger module to log information about system events.",
        "Add logging statements at critical points in your code, such as before and after a critical action, and when an error occurs."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "211",
    "title": "Asymmetric Denial of Service - ReDoS",
    "context": [
      "Usage of Elixir (v1.10+) for building scalable and fault-tolerant applications",
      "Usage of Regex module for regular expressions"
    ],
    "need": "Prevent server crashes by avoiding expensive regular expression operations",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it uses a regular expression that can be exploited in a ReDoS attack. An attacker can provide an email string that causes excessive backtracking, leading to an excessive consumption of CPU resources and potentially causing the server to crash.",
        "text": "defmodule MyApp.Service do\n  def check_email_format(email) do\n    Regex.match?(~r/([a-z0-9]+)*@([a-z0-9]+)*(.com)*/, email)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it uses a non-capturing regular expression to validate the email format, thus avoiding the risk of excessive backtracking and ReDoS attacks.",
        "text": "defmodule MyApp.Service do\n  def check_email_format(email) do\n    Regex.match?(~r/[a-z0-9]+@[a-z0-9]+\\.com/, email)\n  end\nend"
      },
      "steps": [
        "Avoid using quantifiers in your regular expressions that could lead to excessive backtracking.",
        "Use a simpler, non-capturing regular expression to validate the email format."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "213",
    "title": "Business Information Leak - JWT",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Guardian for authentication and authorization"
    ],
    "need": "Prevent leakage of sensitive business information through JWTs",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code generates JWTs with sensitive user information like the username and password. An attacker obtaining the JWT can decode it to access this sensitive information.",
        "text": "defmodule MyApp.Guardian do\n  use Guardian, otp_app: :my_app\n\n  def subject_for_token(user, _claims) do\n    {:ok, \"User:#{user.id}\"}\n  end\n\n  def resource_from_claims(claims) do\n    {:ok, %{username: claims[\"sub\"], password: claims[\"password\"]}}\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code generates JWTs with just the user ID, and not other sensitive information like the username and password. Thus, even if an attacker obtains the JWT, they can't access sensitive business information.",
        "text": "defmodule MyApp.Guardian do\n  use Guardian, otp_app: :my_app\n\n  def subject_for_token(user, _claims) do\n    {:ok, \"User:#{user.id}\"}\n  end\n\n  def resource_from_claims(claims) do\n    {:ok, %{user_id: claims[\"sub\"]}}\n  end\nend"
      },
      "steps": [
        "Remove sensitive information from the JWT.",
        "Handle sensitive information on the server side and not include it in JWTs."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "214",
    "title": "Business Information Leak - Credentials",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.11.0 and above) for building composable web applications in Elixir"
    ],
    "need": "Prevent leakage of sensitive credentials",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code hard-codes a sensitive API key, which exposes the key if the code is leaked. An attacker obtaining this key can misuse it to impersonate the application.",
        "text": "defmodule MyApp.Config do\n  @api_key \"hard-coded-api-key\"\n\n  def get_api_key do\n    @api_key\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code retrieves the API key from an environment variable instead of hard-coding it. Even if the code is leaked, the sensitive API key remains secure.",
        "text": "defmodule MyApp.Config do\n  def get_api_key do\n    System.get_env(\"API_KEY\")\n  end\nend"
      },
      "steps": [
        "Remove hard-coded sensitive credentials from the code.",
        "Store sensitive credentials securely, such as in environment variables, or in encrypted configuration files."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "217",
    "title": "Business Information Leak - Credit Cards",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications (version 1.5.0 and above)"
    ],
    "need": "Prevent credit card information from being exposed in responses",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is returning the user's credit card information in the response to the 'show' request. If an attacker can access the responses to these requests, they can obtain sensitive credit card information.",
        "text": "defmodule MyApp.UserController do\n  use MyApp, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n    render(conn, \"show.json\", user: user)\n  end\nend\n\ndefmodule MyApp.UserView do\n  use MyApp, :view\n\n  def render(\"show.json\", %{user: user}) do\n    %{id: user.id, name: user.name, credit_card: user.credit_card}\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure code does not include the user's credit card information in the response, thus protecting sensitive data.",
        "text": "defmodule MyApp.UserController do\n  use MyApp, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n    render(conn, \"show.json\", user: user)\n  end\nend\n\ndefmodule MyApp.UserView do\n  use MyApp, :view\n\n  def render(\"show.json\", %{user: user}) do\n    %{id: user.id, name: user.name}\n  end\nend"
      },
      "steps": [
        "Do not include sensitive information like credit card data in the response.",
        "Always sanitize data before sending it in a response."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "220",
    "title": "Business Information Leak - Token",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.12.1 and above) for building composable web applications in Elixir",
      "Usage of Guardian for authentication and authorization"
    ],
    "need": "Prevent user information from being exposed in session tokens",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is including the user's email and name in the session token. If an attacker can decode this token, they can obtain the user's email and name.",
        "text": "defmodule MyApp.GuardianSerializer do\n  @behaviour Guardian.Serializer\n\n  def for_token(user = %User{}), do: { :ok, \"User:#{user.id}:#{user.email}:#{user.name}\" }\n  def from_token(\"User:\" <> id <> \":\" <> email <> \":\" <> name), do: { :ok, %User{id: id, email: email, name: name} }\nend"
      },
      "secure_code_example": {
        "description": "The secure code does not include the user's email and name in the session token, thus protecting sensitive data.",
        "text": "defmodule MyApp.GuardianSerializer do\n  @behaviour Guardian.Serializer\n\n  def for_token(user = %User{}), do: { :ok, \"User:#{user.id}\" }\n  def from_token(\"User:\" <> id), do: { :ok, %User{id: id} }\nend"
      },
      "steps": [
        "Do not include sensitive information like email and name in the session token.",
        "Always sanitize data before including it in a token."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "221",
    "title": "Business Information Leak - Users",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.12.1 and above) for building composable web applications in Elixir",
      "Usage of Ecto for database query and manipulation (version 3.6.2 and above)"
    ],
    "need": "Prevent exposure of valid users' list",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code is exposing the list of all users without any checks or restrictions. This could allow attackers to obtain information about valid users in the system.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def index(conn, _params) do\n    users = Repo.all(User)\n    render(conn, \"index.json\", users: users)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure code only provides the list of users if the user is authorized. It ensures that only the right users can see the user list.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def index(conn, _params) do\n    if authorized?(conn) do\n      users = Repo.all(User)\n      render(conn, \"index.json\", users: users)\n    else\n      send_resp(conn, :unauthorized, \"\")\n    end\n  end\n\n  defp authorized?(conn) do\n    # Add authorization checks here\n  end\nend"
      },
      "steps": [
        "Restrict access to user lists and only expose it when necessary and to authorized users.",
        "Include server-side checks to ensure only authorized users can access the data."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "222",
    "title": "Business Information Leak - DB",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Ecto (3.6.2 and above) for database query and manipulation",
      "Usage of Postgrex for connecting to PostgreSQL databases (version 0.15.9 and above)"
    ],
    "need": "Prevent exposure of sensitive business information from the database",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code is exposing all details of a user, including sensitive information such as transactions, wallet IDs, operating system names, transaction codes, endpoints, credit cards, and available balance. An attacker who can access this endpoint could retrieve all this sensitive business information.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get(User, id)\n    render(conn, \"show.json\", user: user)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure code only provides necessary user details and only if the user is authorized. It ensures that only the right users can see the user details and sensitive business information is protected.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    if authorized?(conn) do\n      user = Repo.get(User, id) |> Repo.preload([:minimal_required_fields])\n      render(conn, \"show.json\", user: user)\n    else\n      send_resp(conn, :unauthorized, \"\")\n    end\n  end\n\n  defp authorized?(conn) do\n    # Add authorization checks here\n  end\nend"
      },
      "steps": [
        "Restrict the fields that are returned by the API. Only provide necessary information.",
        "Always use server-side checks to ensure that only authorized users can access the data."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "226",
    "title": "Business Information Leak - Personal Information",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.12.0 and above) for building composable web application modules"
    ],
    "need": "Avoid exposure of real user's personal information stored in the source code",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The insecure code directly uses real personal information (like ID numbers and phone numbers) within the source code. This could lead to a serious data breach, where personal information is leaked, and could be used for malicious purposes such as social engineering attacks.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = %{id: \"real_id\", phone: \"real_phone_number\"}\n    render(conn, \"show.json\", user: user)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure code uses environment variables instead of hard-coding the personal information. It ensures that personal information is not directly exposed in the source code, thereby preventing potential data breaches.",
        "text": "defmodule MyApp.UserController do\n  use MyApp.Web, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = %{id: System.get_env(\"USER_ID\"), phone: System.get_env(\"PHONE_NUMBER\")}\n    render(conn, \"show.json\", user: user)\n  end\nend"
      },
      "steps": [
        "Never hard-code real personal information within your source code.",
        "Use environment variables or secure configuration files to store sensitive data if necessary."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "228",
    "title": "Business Information Leak - Analytics",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.12.0 and above) for building composable web applications in Elixir"
    ],
    "need": "Prevent unauthorized access to business analytics through exposed API key",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code exposes an API key in a Swagger URL that could be used to access business analytics. This can lead to a serious information breach, where unauthorized users could gain access to valuable business insights.",
        "text": "defmodule MyApp.AnalyticsController do\n  use MyApp.Web, :controller\n\n  def show(conn, %{\"apiKey\" => apiKey}) do\n    if apiKey == \"exposed_api_key\" do\n      analytics = MyApp.Analytics.get()\n      render(conn, \"show.json\", analytics: analytics)\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "The secure code compares the provided API key with a securely stored key, and only provides analytics if the user is authorized. This ensures that the API key and business analytics are not exposed to unauthorized users.",
        "text": "defmodule MyApp.AnalyticsController do\n  use MyApp.Web, :controller\n\n  def show(conn, %{\"apiKey\" => apiKey}) do\n    if apiKey == System.get_env(\"API_KEY\") and authorized?(conn) do\n      analytics = MyApp.Analytics.get()\n      render(conn, \"show.json\", analytics: analytics)\n    else\n      send_resp(conn, :unauthorized, \"\")\n    end\n  end\n\n  defp authorized?(conn) do\n    # Add authorization checks here\n  end\nend"
      },
      "steps": [
        "API keys should never be exposed in the code or URLs.",
        "Use secure methods to store and access API keys, such as environment variables or secure configuration files.",
        "Implement access controls to ensure that only authorized personnel can access the analytics."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "231",
    "title": "Message Flooding",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.12.0 and above) for building composable web application modules",
      "Usage of Bamboo (1.7.0 and above) for Email handling"
    ],
    "need": "Prevent mass messages from being sent to a single user, causing resource saturation.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is insecure because it allows for repeated and rapid message sending to the same recipient without any form of rate limiting or restriction. This can lead to message flooding, causing the recipient's resources to be unnecessarily consumed and possibly causing important information to be lost in the flood.",
        "text": "defmodule MyApp.MessageController do\n  use MyApp.Web, :controller\n\n  def send_message(conn, %{\"recipient\" => recipient, \"message\" => message}) do\n    MyApp.Messaging.send_email(recipient, message)\n    MyApp.Messaging.send_sms(recipient, message)\n    send_resp(conn, :ok, \"Message sent\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it implements a rate limiting mechanism that restricts the number of messages that can be sent to a single recipient in a given time frame. It checks if a message can be sent before actually sending the message and records the sent message for future checks. This prevents message flooding and conserves the recipient's resources.",
        "text": "defmodule MyApp.MessageController do\n  use MyApp.Web, :controller\n\n  def send_message(conn, %{\"recipient\" => recipient, \"message\" => message}) do\n    if MyApp.Messaging.can_send_message?(recipient) do\n      MyApp.Messaging.send_email(recipient, message)\n      MyApp.Messaging.send_sms(recipient, message)\n      MyApp.Messaging.record_message_sent(recipient)\n      send_resp(conn, :ok, \"Message sent\")\n    else\n      send_resp(conn, :too_many_requests, \"Too many messages have been sent. Please wait before sending again.\")\n    end\n  end\nend"
      },
      "steps": [
        "Implement a rate limiting mechanism to restrict the number of messages that can be sent to a single recipient in a given time frame.",
        "Monitor message sending patterns to detect and block any attempts at message flooding.",
        "Require users to confirm their email or phone number before allowing messages to be sent to them."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "235",
    "title": "Technical Information Leak - Headers",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.12.0 and above) for building composable web applications in Elixir"
    ],
    "need": "Prevent exposing server details through HTTP response headers.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is insecure because it sets the 'Server' response header with information about the application and the server technology, potentially exposing the system to targeted attacks.",
        "text": "defmodule MyApp.Plug.RemoveSensitiveHeaders do\n  import Plug.Conn\n\n  def init(opts), do: opts\n\n  def call(conn, _opts) do\n    conn\n    |> put_resp_header(\"Server\", \"MyApp/1.0.0 (Elixir Plug/1.12.0)\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it doesn't reveal specific details about the application or the technology stack in the 'Server' header. Instead, it sets a generic value, reducing the risk of targeted attacks.",
        "text": "defmodule MyApp.Plug.RemoveSensitiveHeaders do\n  import Plug.Conn\n\n  def init(opts), do: opts\n\n  def call(conn, _opts) do\n    conn\n    |> put_resp_header(\"Server\", \"Secure Server\")\n  end\nend"
      },
      "steps": [
        "Avoid setting headers that reveal sensitive details about the server or the technology stack.",
        "Review your application's response headers to ensure that no sensitive information is being exposed.",
        "Use a security-oriented middleware or plug that removes or obfuscates these headers."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "238",
    "title": "Technical Information Leak - API",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Absinthe for building GraphQL APIs in Elixir"
    ],
    "need": "Prevent exposing GraphQL API Schema Structure to unauthorized users.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is insecure because it enables introspection queries, allowing anyone to retrieve the entire GraphQL API Schema Structure. This can lead to information leakage, helping an attacker to craft more targeted attacks.",
        "text": "defmodule MyAppWeb.Schema do\n  use Absinthe.Schema\n\n  query do\n    # Queries defined here\n  end\n\n  mutation do\n    # Mutations defined here\n  end\nend\n\n# Endpoint configuration\ndefmodule MyAppWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :my_app\n\n  socket \"/graphiql\", Absinthe.Plug.GraphiQL, schema: MyAppWeb.Schema\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it disables introspection queries in the production environment. The introspection queries are only available in non-production environments, reducing the risk of information leakage.",
        "text": "defmodule MyAppWeb.Schema do\n  use Absinthe.Schema\n\n  query do\n    # Queries defined here\n  end\n\n  mutation do\n    # Mutations defined here\n  end\nend\n\n# Endpoint configuration\ndefmodule MyAppWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :my_app\n\n  socket \"/graphiql\", Absinthe.Plug.GraphiQL, schema: MyAppWeb.Schema, interface: Mix.env() != :prod\nend"
      },
      "steps": [
        "Disable introspection queries in the production environment.",
        "Configure Absinthe to conditionally enable introspection queries based on the environment or other criteria.",
        "Review your GraphQL server's configuration to ensure that no sensitive schema information is exposed."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "239",
    "title": "Technical Information Leak - Errors",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications (version 1.6.0 and above)"
    ],
    "need": "Prevent exposing technical information through server error messages.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is insecure because it might reveal too much information in the error details when a server error (HTTP 500) occurs. Detailed error messages can potentially expose sensitive technical details about your system.",
        "text": "defmodule MyAppWeb.ErrorView do\n  use MyAppWeb, :view\n\n  def render(\"500.json\", _assigns) do\n    %{errors: %{detail: 'Internal server error'}}\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it uses a generic error message to indicate a server error, without revealing any technical details. The detailed error information is not exposed to the client, reducing the risk of information leaks.",
        "text": "defmodule MyAppWeb.ErrorView do\n  use MyAppWeb, :view\n\n  def render(\"500.json\", _assigns) do\n    %{errors: %{detail: 'An error occurred. We are working to fix it.'}}\n  end\nend"
      },
      "steps": [
        "Use generic error messages when responding to client requests, regardless of the type of error on the server.",
        "Handle exceptions at the application level and log the detailed error information server-side for debugging.",
        "Use a custom error handling plug to control what gets exposed in case of server errors."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "240",
    "title": "Authentication Mechanism Absence or Evasion - OTP",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications (version 1.6.0 and above)"
    ],
    "need": "Ensure that OTPs are validated properly during user registration.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is insecure because it only checks if the length of the OTP is 6, but it doesn't verify if the OTP matches the one generated by the server. This allows an attacker to bypass the OTP verification by entering any six-digit number.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def verify_otp(conn, %{'otp' => otp}) do\n    if String.length(otp) == 6 do\n      json(conn, %{status: 'success'})\n    else\n      json(conn, %{status: 'error'})\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is secure because it verifies the user's OTP against the one stored on the server, ensuring that only a correct OTP will pass the verification process.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def verify_otp(conn, %{'otp' => otp, 'user_id' => user_id}) do\n    stored_otp = get_stored_otp_for_user(user_id)\n    if otp == stored_otp do\n      json(conn, %{status: 'success'})\n    else\n      json(conn, %{status: 'error'})\n    end\n  end\nend"
      },
      "steps": [
        "Implement server-side OTP generation and storage (temporary, expires after a certain time or after it is used).",
        "Upon user OTP submission, verify it against the OTP stored on the server.",
        "Consider using OTP validation libraries to handle this more securely and efficiently."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "245",
    "title": "Non-encrypted Confidential Information - Credit Cards",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.12.0 and above) for building composable web applications in Elixir",
      "Usage of Plug.Crypto library (version 1.2.0 and above) for cryptographic operations"
    ],
    "need": "Ensure that credit card information is encrypted both during transport and at rest.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is insecure because it directly uses the credit card data without any form of encryption. This allows anyone who can intercept the data to have access to sensitive credit card information.",
        "text": "defmodule MyAppWeb.PaymentController do\n  use MyAppWeb, :controller\n\n  def process_payment(conn, %{'card_number' => card_number, 'expiry_date' => expiry_date, 'cvv' => cvv}) do\n    payment_successful = PaymentProcessor.process(card_number, expiry_date, cvv)\n    if payment_successful do\n      json(conn, %{status: 'success'})\n    else\n      json(conn, %{status: 'error'})\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code is secure because it decrypts the encrypted credit card data on the server side before processing the payment, which means the credit card information is encrypted during transport.",
        "text": "defmodule MyAppWeb.PaymentController do\n  use MyAppWeb, :controller\n  alias Plug.Crypto.KeyGenerator\n\n  def process_payment(conn, %{'card_number' => enc_card_number, 'expiry_date' => enc_expiry_date, 'cvv' => enc_cvv}) do\n    key = KeyGenerator.generate(conn.private.salt, conn.private.iteration)\n    card_number = KeyGenerator.stream_decrypt(key, enc_card_number)\n    expiry_date = KeyGenerator.stream_decrypt(key, enc_expiry_date)\n    cvv = KeyGenerator.stream_decrypt(key, enc_cvv)\n    payment_successful = PaymentProcessor.process(card_number, expiry_date, cvv)\n    if payment_successful do\n      json(conn, %{status: 'success'})\n    else\n      json(conn, %{status: 'error'})\n    end\n  end\nend"
      },
      "steps": [
        "Install Plug.Crypto library to handle encryption and decryption of sensitive data.",
        "Encrypt credit card data before sending it to the server.",
        "Decrypt the data server-side before processing the payment.",
        "Always use secure connections (HTTPS) to transport sensitive data."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "246",
    "title": "Non-encrypted Confidential Information - Database",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and concurrent applications",
      "Usage of Ecto (3.7.1 and above) for database query and manipulation",
      "Usage of Cloak (1.1.0 and above) for data encryption and protection"
    ],
    "need": "Ensure that user query information stored in the database is encrypted.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is insecure because it directly stores the user's queries into the database without any form of encryption. This allows anyone who has access to the database to view sensitive user query information.",
        "text": "defmodule MyApp.Repo.Migrations.CreateUser do\n  use Ecto.Migration\n\n  def change do\n    create table(:users) do\n      add :query, :string\n      timestamps()\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code is secure because it encrypts the user's queries before storing them in the database. The query data is decrypted when accessed, ensuring the stored data is unreadable without the decryption key.",
        "text": "defmodule MyApp.Repo.Migrations.CreateUser do\n  use Ecto.Migration\n\n  def change do\n    create table(:users) do\n      add :query, Cloak.Encrypted.Binary\n      timestamps()\n    end\n  end\nend"
      },
      "steps": [
        "Install the Cloak library to handle encryption and decryption of sensitive data.",
        "Encrypt user query data before storing it in the database.",
        "Decrypt the data when accessing it."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "248",
    "title": "Non-encrypted Confidential Information - LDAP",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Exldap (0.5.7 and above) for LDAP integration",
      "Usage of Cloak for data encryption and decryption"
    ],
    "need": "Ensure that LDAP service credentials are encrypted.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is insecure because it exposes LDAP service credentials in plain text. This allows anyone who has access to the code to obtain the credentials and access the LDAP service.",
        "text": "defmodule MyApp.Ldap do\n  def ldap_config() do\n    {:ok, 'ldap.myapp.com', 'admin', 'password'}\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code is secure because it encrypts the LDAP service credentials before storing them in the code. The credentials are decrypted when accessed, ensuring the stored credentials are unreadable without the decryption key.",
        "text": "defmodule MyApp.Ldap do\n  def ldap_config() do\n    encrypted_host = Cloak.Cipher.encrypt('ldap.myapp.com')\n    encrypted_username = Cloak.Cipher.encrypt('admin')\n    encrypted_password = Cloak.Cipher.encrypt('password')\n    {:ok, encrypted_host, encrypted_username, encrypted_password}\n  end\nend"
      },
      "steps": [
        "Install the Cloak library to handle encryption and decryption of sensitive data.",
        "Encrypt LDAP service credentials before storing them in the code.",
        "Decrypt the data when accessing it."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "249",
    "title": "Non-encrypted Confidential Information - Credentials",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Ecto (3.6.2 and above) for database query and manipulation",
      "Usage of Cloak for data encryption and protection (version 1.1.0 and above)"
    ],
    "need": "To ensure sensitive information such as API keys and passwords are not included in plain text in the source code.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because the database password is stored in plain text in the source code. Anyone with access to the source code can access the database, posing a serious security risk.",
        "text": "defmodule MyApp.Repo do\n  use Ecto.Repo,\n    otp_app: :my_app,\n    adapter: Ecto.Adapters.Postgres,\n    password: 'plaintextpassword',\n    username: 'admin'\nend"
      },
      "secure_code_example": {
        "description": "In the secure code, the database credentials are encrypted and stored as environment variables. The Cloak library is used to decrypt the credentials when they are accessed. This prevents them from being exposed in plain text in the source code.",
        "text": "defmodule MyApp.Repo do\n  use Ecto.Repo,\n    otp_app: :my_app,\n    adapter: Ecto.Adapters.Postgres,\n    password: System.get_env('DB_PASSWORD') |> Cloak.Cipher.decrypt(),\n    username: System.get_env('DB_USERNAME') |> Cloak.Cipher.decrypt()\nend"
      },
      "steps": [
        "Install the Cloak library to handle encryption and decryption of sensitive data.",
        "Encrypt credentials before storing them in the code.",
        "Decrypt the credentials when accessing them."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "254",
    "title": "Automatic Information Enumeration - Credit Cards",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Ecto (3.6.2 and above) for database query and manipulation",
      "Usage of Plug (1.11.1 and above) for building composable web applications in Elixir"
    ],
    "need": "To prevent the listing and exposure of credit card information by implementing proper validation.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because there's no validation of the expiration date and security code of the credit card. This lack of validation could allow an attacker to list credit card information.",
        "text": "defmodule MyApp.PaymentController do\n  use MyApp.Web, :controller\n\n  def create(conn, %{\"card\" => card_params}) do\n    {:ok, card} = MyApp.Card.create_card(card_params)\n    render(conn, \"card.json\", card: card)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, we've added a card validation step using the `validate_card` function. This function checks the expiration date and security code of the credit card before creating it.",
        "text": "defmodule MyApp.PaymentController do\n  use MyApp.Web, :controller\n\n  def create(conn, %{\"card\" => card_params}) do\n    with :ok <- MyApp.Card.validate_card(card_params),\n         {:ok, card} <- MyApp.Card.create_card(card_params) do\n      render(conn, \"card.json\", card: card)\n    else\n      _ -> send_resp(conn, :bad_request, \"Invalid card information.\")\n    end\n  end\nend"
      },
      "steps": [
        "Implement validation for the expiration date and security code in the card creation function.",
        "Install a credit card validation library if available."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "261",
    "title": "Insecure Encryption Algorithm - DSA",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.11.1 and above) for building composable web applications in Elixir",
      "Usage of Plug.Crypto for cryptographic operations (version 1.2.0 and above)"
    ],
    "need": "To secure the information transmitted between the client and the server using cryptographically secure algorithms.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it uses the DSA encryption algorithm which is considered insecure. It could allow an attacker to decrypt the information transmitted between the client and the server.",
        "text": "defmodule MyApp.Encryption do\n  def encrypt(data) do\n    {:ok, key} = Plug.Crypto.KeyGenerator.generate(:dsa, {1024, 160}, :sha)\n    {:ok, cipher} = :crypto.block_encrypt(:des, key, data)\n    {:ok, cipher}\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, we've replaced the DSA encryption algorithm with RSA, which is considered secure. We've also switched the symmetric encryption algorithm from DES to AES.",
        "text": "defmodule MyApp.Encryption do\n  def encrypt(data) do\n    {:ok, key} = Plug.Crypto.KeyGenerator.generate(:rsa, :sha256)\n    {:ok, cipher} = :crypto.block_encrypt(:aes, key, data)\n    {:ok, cipher}\n  end\nend"
      },
      "steps": [
        "Replace the insecure DSA algorithm with a secure one like RSA or ECC.",
        "Ensure to use the appropriate key length based on the encryption algorithm."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "262",
    "title": "Insecure Encryption Algorithm - SHA1",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug (1.11.1 and above) for building composable web applications in Elixir",
      "Usage of Plug.Crypto for cryptographic operations (version 1.2.0 and above)"
    ],
    "need": "To secure the information transmitted between the client and the server using cryptographically secure algorithms.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it uses the SHA1 encryption algorithm which is considered insecure. It could allow an attacker to reverse a summary function to find sensitive information.",
        "text": "defmodule MyApp.Encryption do\n  def generate_hash(data) do\n    :crypto.hash(:sha, data)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, we've replaced the SHA1 encryption algorithm with SHA256, which is considered secure. This will effectively mitigate the risks associated with SHA1.",
        "text": "defmodule MyApp.Encryption do\n  def generate_hash(data) do\n    :crypto.hash(:sha256, data)\n  end\nend"
      },
      "steps": [
        "Replace the insecure SHA1 algorithm with a secure one like SHA256 or SHA3.",
        "Ensure to use the appropriate hash function based on the encryption algorithm."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "263",
    "title": "Insecure Encryption Algorithm - MD5",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Ecto (3.6.2 and above) for database query and manipulation",
      "Usage of Comeonin for password hashing and encryption",
      "Usage of Bcrypt_elixir for secure password hashing and verification"
    ],
    "need": "To secure user passwords using cryptographically secure hashing algorithms.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it uses the MD5 hash function which is considered insecure. It could allow an attacker to easily crack captured credentials.",
        "text": "defmodule MyApp.User do\n  use Ecto.Schema\n\n  schema \"users\" do\n    field :password_hash, :string\n  end\n\n  def hash_password(password) do\n    :crypto.hash(:md5, password)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, we've replaced the MD5 hash function with Bcrypt, which is considered secure. This will effectively mitigate the risks associated with MD5.",
        "text": "defmodule MyApp.User do\n  use Ecto.Schema\n  import Comeonin.Bcrypt\n\n  schema \"users\" do\n    field :password_hash, :string\n  end\n\n  def hash_password(password) do\n    hashpwsalt(password)\n  end\nend"
      },
      "steps": [
        "Replace the insecure MD5 hash function with a secure one like PBKDF2 or Bcrypt.",
        "Use the Bcrypt library provided by 'Comeonin' and 'Bcrypt_elixir' to hash passwords."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "264",
    "title": "Insecure Encryption Algorithm - TripleDES",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of crypto module for encryption"
    ],
    "need": "To secure sensitive data using secure encryption algorithms.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is vulnerable because it uses TripleDES algorithm for encryption which is now considered insecure. The use of this algorithm can lead to exposure of sensitive data if the encrypted data is intercepted.",
        "text": "defmodule MyApp.Crypto do\n  def encrypt(data, key) do\n    :crypto.block_encrypt(:des_ede3, key, data)\n  end\n\n  def decrypt(ciphertext, key) do\n    :crypto.block_decrypt(:des_ede3, key, ciphertext)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, we've replaced the insecure TripleDES algorithm with AES, which is considered secure. This will effectively protect sensitive data from being exposed even if intercepted.",
        "text": "defmodule MyApp.Crypto do\n  def encrypt(data, key, iv) do\n    :crypto.block_encrypt(:aes_cbc128, {key, iv}, data)\n  end\n\n  def decrypt(ciphertext, key, iv) do\n    :crypto.block_decrypt(:aes_cbc128, {key, iv}, ciphertext)\n  end\nend"
      },
      "steps": [
        "Use a secure encryption algorithm such as AES.",
        "Replace the :des_ede3 atom with :aes_cbc128 or :aes_cbc256 in the :crypto.block_encrypt/3 and :crypto.block_decrypt/3 functions."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "265",
    "title": "Insecure Encryption Algorithm - AES",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of crypto module for encryption"
    ],
    "need": "Secure encryption of sensitive data.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code is vulnerable because it uses AES encryption in CBC mode, which is susceptible to padding oracle attacks. The encryption mode used does not ensure the authenticity of the data, which can lead to vulnerabilities.",
        "text": "defmodule MyApp.Crypto do\n  def encrypt(data, key, iv) do\n    :crypto.block_encrypt(:aes_cbc128, {key, iv}, data)\n  end\n\n  def decrypt(ciphertext, key, iv) do\n    :crypto.block_decrypt(:aes_cbc128, {key, iv}, ciphertext)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, AES encryption is used in GCM mode, which provides both data confidentiality and authenticity. This protects against padding oracle attacks and ensures that the encrypted data has not been tampered with.",
        "text": "defmodule MyApp.Crypto do\n  def encrypt(data, key, iv, aad) do\n    :crypto.block_encrypt(:aes_gcm, {key, iv}, aad, data)\n  end\n\n  def decrypt(ciphertext, key, iv, aad, tag) do\n    :crypto.block_decrypt(:aes_gcm, {key, iv}, aad, tag, ciphertext)\n  end\nend"
      },
      "steps": [
        "Use a secure encryption mode like GCM which also provides data authenticity.",
        "Replace the :aes_cbc128 atom with :aes_gcm in the :crypto.block_encrypt/3 and :crypto.block_decrypt/3 functions, and use an appropriate authentication tag."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "274",
    "title": "Restricted Fields Manipulation",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Ecto for data access and manipulation",
      "Usage of Phoenix framework for web request handling"
    ],
    "need": "Ensure data integrity and prevent unauthorized information updates.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir/Phoenix code does not check if the current user has the correct permissions to update the employee data. As a result, an attacker can initiate a request to update the data of any employee, changing critical information.",
        "text": "defmodule MyApp.EmployeeController do\n  use MyApp, :controller\n\n  def update(conn, %{\"employee\" => employee_params}) do\n    {:ok, employee} = MyApp.EmployeeContext.update_employee(employee_params)\n    render(conn, \"show.html\", employee: employee)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This secure Elixir/Phoenix code example includes a permissions check before updating the employee data. The can_update_employee? function checks if the current user has the necessary permissions to update the specified employee. This prevents an attacker from updating the data of any employee.",
        "text": "defmodule MyApp.EmployeeController do\n  use MyApp, :controller\n\n  def update(conn, %{\"employee\" => employee_params}) do\n    current_user = get_current_user(conn)\n    if MyApp.EmployeeContext.can_update_employee?(current_user, employee_params[\"id\"]) do\n      {:ok, employee} = MyApp.EmployeeContext.update_employee(employee_params)\n      render(conn, \"show.html\", employee: employee)\n    else\n      send_resp(conn, :forbidden, \"You are not allowed to update this employee.\")\n    end\n  end\nend"
      },
      "steps": [
        "Implement user authentication and permission checks.",
        "Before updating the employee data, ensure that the current user has the necessary permissions to do so."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "276",
    "title": "Sensitive Information Sent Via URL Parameters - Session",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix framework for web request handling",
      "Usage of Guardian for JWT session management"
    ],
    "need": "Prevent unauthorized access to user sessions.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir/Phoenix code does not handle JWT session tokens securely. It sends the JWT as a URL parameter which can be cached by the browser or logged in server logs. This exposes the token to potential theft.",
        "text": "defmodule MyApp.SessionController do\n  use MyApp, :controller\n\n  def create(conn, %{\"user\" => user_params}) do\n    jwt = MyApp.SessionContext.create_jwt(user_params)\n    redirect(conn, to: \"/welcome?jwt=#{jwt}\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "This secure Elixir/Phoenix code example sends the JWT as an HTTP header. This prevents it from being exposed in the URL or cached by the browser.",
        "text": "defmodule MyApp.SessionController do\n  use MyApp, :controller\n\n  def create(conn, %{\"user\" => user_params}) do\n    jwt = MyApp.SessionContext.create_jwt(user_params)\n    conn = put_resp_header(conn, \"authorization\", \"Bearer #{jwt}\")\n    redirect(conn, to: \"/welcome\")\n  end\nend"
      },
      "steps": [
        "Don't send sensitive information such as JWTs in the URL.",
        "Instead, use secure mechanisms such as HTTP headers or cookies."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "280",
    "title": "Session Fixation",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix framework for web request handling",
      "Usage of Plug.Session for session management"
    ],
    "need": "Prevent session hijacking by securing session cookies.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This Elixir/Phoenix code does not handle session cookies securely. The session cookie is not regenerated after login, which allows an attacker to fixate a session, and then hijack the user session once the victim logs in.",
        "text": "defmodule MyApp.SessionController do\n  use MyApp, :controller\n\n  def create(conn, %{\"user\" => user_params}) do\n    case MyApp.Authenticator.authenticate(user_params) do\n      {:ok, user} ->\n        conn\n        |> put_session(:user_id, user.id)\n        |> redirect(to: \"/welcome\")\n      {:error, reason} ->\n        render(conn, \"login.html\", error: reason)\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "This secure Elixir/Phoenix code example regenerates the session cookie after a successful login. The call to 'configure_session(renew: true)' ensures a new session is created, preventing session fixation.",
        "text": "defmodule MyApp.SessionController do\n  use MyApp, :controller\n\n  def create(conn, %{\"user\" => user_params}) do\n    case MyApp.Authenticator.authenticate(user_params) do\n      {:ok, user} ->\n        conn\n        |> configure_session(renew: true)\n        |> put_session(:user_id, user.id)\n        |> redirect(to: \"/welcome\")\n      {:error, reason} ->\n        render(conn, \"login.html\", error: reason)\n    end\n  end\nend"
      },
      "steps": [
        "Regenerate the session cookie after login to prevent session fixation.",
        "This can be done by deleting the old session and creating a new one."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "282",
    "title": "Insecure encryption algorithm - ECB",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of crypto module for encryption and decryption"
    ],
    "need": "Securely encrypt sensitive information.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code uses the Electronic Code Book (ECB) mode for AES encryption, which is not secure. In ECB mode, the same plaintext block will always produce the same ciphertext block, creating patterns that could be exploited.",
        "text": "defmodule MyApp.Crypto do\n  def encrypt(text, key) do\n    :crypto.block_encrypt(:aes_ecb, key, text)\n  end\n\n  def decrypt(ciphertext, key) do\n    :crypto.block_decrypt(:aes_ecb, key, ciphertext)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This secure Elixir code example uses the CBC mode for AES encryption, which is more secure than ECB mode. It also uses an Initialization Vector (IV) for encryption, which should be unique for each encryption operation.",
        "text": "defmodule MyApp.Crypto do\n  def encrypt(text, key, iv) do\n    :crypto.block_encrypt(:aes_cbc128, key, iv, text)\n  end\n\n  def decrypt(ciphertext, key, iv) do\n    :crypto.block_decrypt(:aes_cbc128, key, iv, ciphertext)\n  end\nend"
      },
      "steps": [
        "Use a more secure encryption mode, such as Cipher Block Chaining (CBC) or Galois/Counter Mode (GCM).",
        "Use an Initialization Vector (IV) for encryption, which should be unique for each encryption operation."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "283",
    "title": "Automatic information enumeration - Personal Information",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for web development",
      "Usage of Ecto for database interactions"
    ],
    "need": "To prevent unauthorized access to user's personal information.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it fetches and returns user information based solely on the user ID provided in the request, without any authentication or authorization checks. An attacker could potentially iterate over user IDs to retrieve personal information about all users.",
        "text": "defmodule MyApp.UserController do\n  use MyApp, :controller\n\n  def show(conn, %{'id' => id}) do\n    user = MyApp.Repo.get(MyApp.User, id)\n    render(conn, 'show.html', user: user)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This secure code example introduces authentication and authorization checks. Before accessing a user's information, the current user is fetched from the session, and the user can only access their own information. If an unauthenticated user or a user trying to access someone else's information attempts to use the 'show' action, they receive an 'unauthorized' response.",
        "text": "defmodule MyApp.UserController do\n  use MyApp, :controller\n\n  def show(conn, %{'id' => id}) do\n    current_user = get_authenticated_user(conn)\n    if current_user && current_user.id == id do\n      render(conn, 'show.html', user: current_user)\n    else\n      send_resp(conn, :unauthorized, '')\n    end\n  end\n\n  defp get_authenticated_user(conn) do\n    # Fetch the current user from the session\n  end\nend"
      },
      "steps": [
        "Authenticate the user before accessing the 'show' action.",
        "Authorize the user to only access their own user information."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "290",
    "title": "Technical information leak - IPs",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug for building modular web applications",
      "Usage of Cowboy as the HTTP server"
    ],
    "need": "To prevent exposure of internal technical information.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it sets a response header (`X-Server-IP`) with the internal IP address of the server (`192.168.0.1`). This exposes internal technical information that could be exploited by an attacker.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    conn\n    |> put_resp_header(\"X-Server-IP\", \"192.168.0.1\")\n    |> send_resp(200, \"Welcome to MyApp!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, the response header setting the `X-Server-IP` has been removed. The application no longer exposes the server's internal IP address in its responses.",
        "text": "defmodule MyApp.Router do\n  use Plug.Router\n\n  plug :match\n  plug :dispatch\n\n  get \"/\" do\n    send_resp(conn, 200, \"Welcome to MyApp!\")\n  end\nend"
      },
      "steps": [
        "Remove any code that sets response headers with sensitive technical information.",
        "Review your codebase and remove any other instances of sensitive information leaks.",
        "Ensure your team is aware of the risk of exposing technical information."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "291",
    "title": "Business information leak - Financial Information",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Ecto for data persistence"
    ],
    "need": "To prevent exposure of sensitive business information.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it retrieves a user from the database and exposes all of its associated information in the response, including potentially sensitive financial information. An attacker could exploit this by making requests to this endpoint and collecting the exposed data.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n    render(conn, \"show.html\", user: user)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, the `Map.take/2` function is used to only include the `id`, `name`, and `email` fields in the response. Any potentially sensitive financial information associated with the user is not included.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = Repo.get!(User, id)\n    safe_user = Map.take(user, [:id, :name, :email])\n    render(conn, \"show.html\", user: safe_user)\n  end\nend"
      },
      "steps": [
        "Ensure that sensitive information is not included in API responses or rendered views.",
        "Review your data models and remove or obfuscate sensitive fields as necessary.",
        "Implement proper access controls to prevent unauthorized access to sensitive data."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "296",
    "title": "Weak credential policy - Password Change Limit",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Ecto for data persistence"
    ],
    "need": "To prevent denial of service by repeatedly changing user's password.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it allows a user's password to be changed without any limit on the number of requests. If an attacker is able to authenticate as a user, they can lock the user out of their account by repeatedly changing the password.",
        "text": "defmodule MyAppWeb.AccountController do\n  use MyAppWeb, :controller\n\n  def change_password(conn, %{\"password\" => password, \"user_id\" => id}) do\n    user = Repo.get!(User, id)\n    changeset = User.changeset(user, %{password: password})\n    Repo.update!(changeset)\n    render(conn, \"password_changed.html\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, the `can_change_password?` function checks if the user has already changed their password within the rate limit period. If they have, the password change request is rejected and a different view is rendered.",
        "text": "defmodule MyAppWeb.AccountController do\n  use MyAppWeb, :controller\n\n  def change_password(conn, %{\"password\" => password, \"user_id\" => id}) do\n    user = Repo.get!(User, id)\n    if can_change_password?(user) do\n      changeset = User.changeset(user, %{password: password})\n      Repo.update!(changeset)\n      update_last_password_change(user)\n      render(conn, \"password_changed.html\")\n    else\n      render(conn, \"password_change_limit.html\")\n    end\n  end\n\n  defp can_change_password?(user) do\n    # check if user can change password\n  end\n\n  defp update_last_password_change(user) do\n    # update the time of last password change\n  end\nend"
      },
      "steps": [
        "Implement a rate limit on password change requests.",
        "Consider using a library or built-in framework feature to enforce rate limiting.",
        "Monitor account activity for suspicious behavior such as repeated password change requests."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "297",
    "title": "SQL Injection - Code",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Ecto for data persistence"
    ],
    "need": "To prevent unauthorized database access and manipulation via SQL Injection.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it's constructing a SQL query by directly appending user-supplied input (`id`) to the SQL statement. An attacker can manipulate the `id` input to execute arbitrary SQL queries against the database, leading to unauthorized access or data manipulation.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = MyApp.Repo.one(\"SELECT * FROM users WHERE id = \" <> id)\n    render(conn, \"show.html\", user: user)\n  end\nend"
      },
      "secure_code_example": {
        "description": "This code is safe because it's using Ecto's query API to create a SQL query. The `^` operator is used to safely interpolate values in a query, which prevents SQL Injection attacks.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def show(conn, %{\"id\" => id}) do\n    user = MyApp.Repo.one(from u in User, where: u.id == ^id)\n    render(conn, \"show.html\", user: user)\n  end\nend"
      },
      "steps": [
        "Avoid creating SQL queries by string concatenation with user-supplied input.",
        "Use Ecto's query API or parameterized queries to safely interact with the database.",
        "Always validate and sanitize user-supplied inputs."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "321",
    "title": "Lack of data validation - HTML code",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Plug for request handling"
    ],
    "need": "To sanitize and validate input data to prevent HTML injection attacks.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The above code is insecure as it directly uses the user-provided data in the 'data' parameter without any validation or sanitization. This allows an attacker to inject HTML code that will be rendered and potentially execute malicious scripts when viewed in a browser.",
        "text": "defmodule MyAppWeb.PageController do\n  use MyAppWeb, :controller\n\n  def show(conn, %{\"data\" => data}) do\n    render(conn, \"show.html\", data: data)\n  end\nend"
      },
      "secure_code_example": {
        "description": "The code is now secure as it uses the 'html_escape' function from the Phoenix.HTML module to sanitize the user-provided data before rendering it. This ensures that any HTML code provided by the user is escaped and rendered as plain text, preventing any potential HTML injection attacks.",
        "text": "defmodule MyAppWeb.PageController do\n  use MyAppWeb, :controller\n\n  def show(conn, %{\"data\" => data}) do\n    sanitized_data = Phoenix.HTML.html_escape(data)\n    render(conn, \"show.html\", data: sanitized_data)\n  end\nend"
      },
      "steps": [
        "Never trust user input and always sanitize it.",
        "Use server-side validation to ensure that user-provided data is safe to use.",
        "Consider using libraries that automatically escape HTML in text."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "330",
    "title": "Lack of protection against brute force attacks - Credentials",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and concurrent applications",
      "Usage of Phoenix Framework for building web applications"
    ],
    "need": "To protect the application against automated attacks aimed at guessing promotional codes.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code above is vulnerable because it directly accepts and verifies promo codes without any rate limiting or captcha protection. This can be exploited by an attacker to conduct brute force attacks, i.e., trying different codes until a valid one is found.",
        "text": "defmodule MyAppWeb.PromoController do\n  use MyAppWeb, :controller\n\n  def check_promo(conn, %{\"promo_code\" => promo_code}) do\n    if PromoCode.valid?(promo_code) do\n      render(conn, \"success.html\")\n    else\n      render(conn, \"failure.html\")\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "The updated code now includes a rate limiter which limits the number of requests that can be made to the 'check_promo' endpoint within a certain timeframe. This mitigates the risk of brute force attacks by making it infeasible to guess a valid promo code within a reasonable time.",
        "text": "defmodule MyAppWeb.PromoController do\n  use MyAppWeb, :controller\n\n  plug MyAppWeb.Plugs.RateLimiter when action in [:check_promo]\n\n  def check_promo(conn, %{\"promo_code\" => promo_code}) do\n    if PromoCode.valid?(promo_code) do\n      render(conn, \"success.html\")\n    else\n      render(conn, \"failure.html\")\n    end\n  end\nend"
      },
      "steps": [
        "Install a rate limiting package or use built-in features in your web framework.",
        "Implement rate limiting on the 'check_promo' endpoint to limit the number of requests from an IP address within a certain period.",
        "Consider adding a captcha to further prevent automated submissions."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "332",
    "title": "Use of insecure channel - Source code",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and concurrent applications",
      "Usage of Cowboy HTTP server for handling HTTP requests"
    ],
    "need": "To protect sensitive information during transmission over a network.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "The code above configures an HTTP server with no encryption. Any data sent between the server and clients is vulnerable to interception. This can be exploited by an attacker to capture sensitive information and credentials in plain text, or intercept communication and steal or forge requests and responses.",
        "text": "defmodule MyAppWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :my_app\n\n  socket \"/socket\", MyAppWeb.UserSocket,\n    websocket: true,\n    longpoll: false\n\n  plug Plug.Static,\n    at: \"/\",\n    from: :my_app,\n    gzip: false,\n    only: ~w(css fonts images js favicon.ico robots.txt)\n\n  plug Plug.RequestId\n  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]\n\n  plug Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Phoenix.json_library()\n\n  plug Plug.MethodOverride\n  plug Plug.Head\n\n  plug Plug.Session, store: :cookie\n\n  plug MyAppWeb.Router\nend"
      },
      "secure_code_example": {
        "description": "The updated code now includes the 'Plug.ForceSSL' plug, which redirects all non-HTTPS requests to HTTPS, ensuring that all data is transmitted over an encrypted channel. This mitigates the risk of data interception and forgery.",
        "text": "defmodule MyAppWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :my_app\n\n  socket \"/socket\", MyAppWeb.UserSocket,\n    websocket: true,\n    longpoll: false\n\n  plug Plug.Static,\n    at: \"/\",\n    from: :my_app,\n    gzip: false,\n    only: ~w(css fonts images js favicon.ico robots.txt)\n\n  plug Plug.RequestId\n  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]\n\n  plug Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Phoenix.json_library()\n\n  plug Plug.MethodOverride\n  plug Plug.Head\n\n  plug Plug.Session, store: :cookie\n\n  plug Plug.ForceSSL\n  plug MyAppWeb.Router\nend"
      },
      "steps": [
        "Acquire a valid TLS certificate for your domain.",
        "Configure your server to use HTTPS with the TLS certificate.",
        "Redirect all HTTP requests to HTTPS."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "284",
    "title": "Non-encrypted confidential information - Base 64",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for web development",
      "Usage of Ecto for database interactions"
    ],
    "need": "To secure sensitive information like service credentials.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This code is vulnerable because it stores service credentials as Base64 encoded strings in the source code. While Base64 encoding might obscure the credentials at first glance, it is a reversible operation that does not provide any real security. Anyone with access to the code can easily decode the credentials.",
        "text": "defmodule MyApp.Config do\n  @db_username \"c2VydmljZV91c2Vy\"\n  @db_password \"c2VydmljZV9wYXNzd29yZA==\"\n\n  def get_db_credentials do\n    username = Base.decode64!(@db_username)\n    password = Base.decode64!(@db_password)\n    {username, password}\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, environment variables are used to store the service credentials. This means that the credentials are no longer stored in the source code and can be managed securely outside the application, for example, through the settings of the hosting environment or using an encrypted key vault service.",
        "text": "defmodule MyApp.Config do\n\n  def get_db_credentials do\n    username = System.get_env(\"DB_USERNAME\")\n    password = System.get_env(\"DB_PASSWORD\")\n    {username, password}\n  end\nend"
      },
      "steps": [
        "Use environment variables to store service credentials.",
        "Use a secure and encrypted key vault service to store sensitive data.",
        "Purge sensitive data from version control history."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "340",
    "title": "Lack of data validation - Special Characters",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications"
    ],
    "need": "To prevent unexpected behavior and potential security risks from unvalidated user input.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this example, the user's name is accepted without validation. If a special character is included in the name, it can cause unexpected behavior or security vulnerabilities.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{\"user\" => %{\"name\" => name}}) do\n    {:ok, user} = MyApp.Accounts.create_user(name)\n    render(conn, \"show.html\", user: user)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code, the user's name is validated using a regular expression, ensuring that it contains only alphanumeric characters and underscores. If the validation fails, an error is returned and can be handled by the controller.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{\"user\" => %{\"name\" => name}}) do\n    case MyApp.Accounts.create_user(name) do\n      {:ok, user} ->\n        render(conn, \"show.html\", user: user)\n      {:error, changeset} ->\n        render(conn, \"new.html\", changeset: changeset)\n    end\n  end\nend\n\ndefmodule MyApp.Accounts.User do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"users\" do\n    field :name, :string\n  end\n\n  def changeset(user, attrs) do\n    user\n    |> cast(attrs, [:name])\n    |> validate_format(:name, ~r/^[a-zA-Z0-9_]*$/)\n  end\nend"
      },
      "steps": [
        "Implement data validation for all user inputs.",
        "Use regular expressions to restrict the characters that can be included in the user's name.",
        "Handle validation errors gracefully and inform the user of the requirements."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "341",
    "title": "Lack of data validation - OTP",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications"
    ],
    "need": "To prevent unauthorized actions by ensuring the OTP used is valid and used only once.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this example, the OTP is verified, but not invalidated after use. This means that the same OTP can be used multiple times, allowing for potential unauthorized access.",
        "text": "defmodule MyAppWeb.AuthController do\n  use MyAppWeb, :controller\n\n  def verify_otp(conn, %{\"otp\" => otp}) do\n    if MyApp.Auth.verify_otp(otp) do\n      render(conn, \"success.html\")\n    else\n      render(conn, \"error.html\")\n    end\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code, after the OTP is used, it is invalidated by the verify_and_invalidate_otp function in the Auth context. If an invalidated OTP is used again, it is treated as an invalid OTP.",
        "text": "defmodule MyAppWeb.AuthController do\n  use MyAppWeb, :controller\n\n  def verify_otp(conn, %{\"otp\" => otp}) do\n    case MyApp.Auth.verify_and_invalidate_otp(otp) do\n      :ok ->\n        render(conn, \"success.html\")\n      _ ->\n        render(conn, \"error.html\")\n    end\n  end\nend\n\ndefmodule MyApp.Auth do\n  def verify_and_invalidate_otp(otp) do\n    if is_valid_and_not_invalidated(otp) do\n      invalidate_otp(otp)\n      :ok\n    else\n      :error\n    end\n  end\nend"
      },
      "steps": [
        "Add an additional step to invalidate the OTP after it has been used.",
        "Update the verify_otp function in the Auth context to handle invalidating the OTP.",
        "Update the controller to handle cases where the OTP is already invalidated."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "353",
    "title": "Lack of data validation - Token",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of JOSE JWT library for JSON Web Token handling"
    ],
    "need": "To ensure the integrity and validity of JWT access tokens used for authentication.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code example, the JWT token is decoded, but its signature is not validated. This means that an attacker could modify the payload of the token, or even remove the signature entirely, and the server would still accept it as valid.",
        "text": "defmodule MyAppWeb.TokenController do\n  use MyAppWeb, :controller\n\n  def verify_token(conn, %{\"token\" => token}) do\n    {:ok, _} = JOSE.JWT.decode(token)\n    send_resp(conn, 200, \"Token is valid\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, the application correctly verifies the JWT token using the JOSE.JWT.verify_strict function with the appropriate algorithm and secret key. This prevents attackers from modifying the token payload or removing the signature.",
        "text": "defmodule MyAppWeb.TokenController do\n  use MyAppWeb, :controller\n\n  def verify_token(conn, %{\"token\" => token}) do\n    case JOSE.JWT.verify_strict(token, [\"HS256\"], \"secret\") do\n      {true, _, _} ->\n        send_resp(conn, 200, \"Token is valid\")\n      _ ->\n        send_resp(conn, 401, \"Invalid token\")\n    end\n  end\nend"
      },
      "steps": [
        "Modify the verify_token function to validate the signature of the JWT token using the JOSE.JWT.verify function.",
        "Ensure that the secret key used for verification is stored securely and is not exposed."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "354",
    "title": "Insecure file upload - Files Limit",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Phoenix Framework for building web applications",
      "Usage of Plug.Upload for handling file uploads in Elixir"
    ],
    "need": "To prevent system resources exhaustion by limiting the number of files uploaded and replacing old files with new ones.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code example, a new file is written to the server's storage every time the upload endpoint is hit. There is no limit to the number of files that can be uploaded, and old files are not replaced with new ones. This could potentially lead to resource exhaustion on the server.",
        "text": "defmodule MyAppWeb.UploadController do\n  use MyAppWeb, :controller\n\n  def upload(conn, %{\"file\" => file}) do\n    {:ok, _} = File.write(\"./uploads/\" <> file.filename, file.read)\n    send_resp(conn, 200, \"File uploaded\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, the server deletes old files before writing new ones. Additionally, a plug function limits the rate at which files can be uploaded, thus preventing resource exhaustion on the server.",
        "text": "defmodule MyAppWeb.UploadController do\n  use MyAppWeb, :controller\n\n  def upload(conn, %{\"file\" => file}) do\n    dir = \"./uploads/\"\n    old_files = File.ls!(dir)\n    Enum.each(old_files, &File.rm(dir <> &1))\n    {:ok, _} = File.write(dir <> file.filename, file.read)\n    send_resp(conn, 200, \"File uploaded\")\n  end\n\n  defp limit_rate(conn, _opts) do\n    :timer.sleep(1000)\n    conn\n  end\n\n  plug :limit_rate when action in [:upload]\nend"
      },
      "steps": [
        "Modify the upload function to delete old files before writing new ones.",
        "Apply request throttling to limit the rate at which files can be uploaded."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "355",
    "title": "Insufficient data authenticity validation - Checksum verification",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of HTTPoison for making HTTP requests"
    ],
    "need": "To validate the integrity of resources loaded from external sources.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "This insecure code example fetches a resource from an external server and sends it to the client without verifying its integrity. An attacker could potentially tamper with the resource on the external server or during transmission, and the client would receive a compromised resource.",
        "text": "defmodule MyAppWeb.ExternalResourceController do\n  use MyAppWeb, :controller\n\n  def get_resource(conn, _) do\n    {:ok, response} = HTTPoison.get(\"https://external-server/resource\")\n    send_resp(conn, 200, response.body)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code example, the server fetches both the resource and its checksum from the external server. It then generates a new checksum for the received resource and compares it with the original. If the checksums match, the server sends the resource to the client. If not, it rejects the resource.",
        "text": "defmodule MyAppWeb.ExternalResourceController do\n  use MyAppWeb, :controller\n\n  def get_resource(conn, _) do\n    {:ok, response} = HTTPoison.get(\"https://external-server/resource\")\n    {:ok, checksum} = HTTPoison.get(\"https://external-server/resource_checksum\")\n    if :crypto.hash(:sha256, response.body) == checksum.body do\n      send_resp(conn, 200, response.body)\n    else\n      send_resp(conn, 403, \"Resource integrity compromised\")\n    end\n  end\nend"
      },
      "steps": [
        "Use a cryptographic hash function to generate a checksum for the original resource.",
        "Include the checksum alongside the resource when transmitting it.",
        "On the receiving end, generate a new checksum for the received resource and compare it with the original. If they match, the resource's integrity is confirmed."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "362",
    "title": "Technical information leak - Content response",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug package for handling requests and responses"
    ],
    "need": "To prevent unauthorized disclosure of technical details which could be exploited for crafting new attack vectors.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code, the server includes a 'server' response header that reveals the version of the Plug package it's using. This information could be used by an attacker to find vulnerabilities in that specific version and exploit them.",
        "text": "defmodule MyAppWeb.MyController do\n  use MyAppWeb, :controller\n\n  def index(conn, _params) do\n    conn\n    |> put_resp_header(\"server\", \"Plug/1.12.0\")\n    |> send_resp(200, \"Hello, world!\")\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code, the server doesn't include any headers that reveal technical details about its configuration. This makes it harder for an attacker to find and exploit vulnerabilities.",
        "text": "defmodule MyAppWeb.MyController do\n  use MyAppWeb, :controller\n\n  def index(conn, _params) do\n    send_resp(conn, 200, \"Hello, world!\")\n  end\nend"
      },
      "steps": [
        "Remove the code that adds the 'server' header with the version information.",
        "Review the application to ensure it doesn't disclose any other technical details in its responses."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "363",
    "title": "Weak credential policy - Password strength",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Comeonin package for password hashing"
    ],
    "need": "To prevent unauthorized account access due to weak passwords, which can be easily compromised by brute force or dictionary attacks.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In the insecure code, the application accepts any password provided by the user, without any strength checks. This can lead to weak passwords that can be easily cracked by an attacker.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{\"password\" => password}) do\n    hashed_password = Comeonin.Bcrypt.hashpwsalt(password)\n    # ... rest of the code\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code, the application checks the strength of the password before accepting it. This prevents users from creating accounts with weak passwords.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def create(conn, %{\"password\" => password}) do\n    if strong_password?(password) do\n      hashed_password = Comeonin.Bcrypt.hashpwsalt(password)\n      # ... rest of the code\n    else\n      # Respond with an error\n    end\n  end\n\n  defp strong_password?(password) do\n    String.length(password) >= 12 && Regex.match?(~r/[A-Z]/, password) && Regex.match?(~r/[a-z]/, password) && Regex.match?(~r/[0-9]/, password) && Regex.match?(~r/[!@#\\$%\\^&]/, password)\n  end\nend"
      },
      "steps": [
        "Add a password strength check before hashing the password.",
        "The check should ensure the password is a certain length, contains a mix of uppercase and lowercase letters, numbers, and special characters."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "364",
    "title": "Weak credential policy - Temporary passwords",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Comeonin package for password hashing"
    ],
    "need": "To prevent unauthorized account access due to weak temporary passwords, which can be easily compromised.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code, the application assigns a static, weak temporary password for all users who request it. This can lead to an attacker easily guessing the temporary password.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def create_temporary_password(conn, %{\"username\" => username}) do\n    temporary_password = \"password123\"\n    hashed_password = Comeonin.Bcrypt.hashpwsalt(temporary_password)\n    # ... rest of the code\n  end\nend"
      },
      "secure_code_example": {
        "description": "In the secure code, the application generates a strong, random temporary password for each user request. This prevents an attacker from easily guessing the temporary password.",
        "text": "defmodule MyAppWeb.UserController do\n  use MyAppWeb, :controller\n\n  def create_temporary_password(conn, %{\"username\" => username}) do\n    temporary_password = :crypto.strong_rand_bytes(12) |> Base.encode64 |> binary_part(0, 12)\n    hashed_password = Comeonin.Bcrypt.hashpwsalt(temporary_password)\n    # ... rest of the code\n  end\nend"
      },
      "steps": [
        "Generate a strong, random temporary password for each user request.",
        "The temporary password should be a certain length, contain a mix of uppercase and lowercase letters, numbers, and special characters.",
        "The temporary password should be unique for each request."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "372",
    "title": "Use of an insecure channel - HTTP",
    "context": [
      "Usage of Elixir (1.12.0 and above) with Phoenix Framework (1.5.7) for building web applications",
      "Usage of Phoenix configuration file for configuring the Phoenix framework"
    ],
    "need": "To secure the transmission of sensitive data between client and server by using encryption.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code, the application is configured to communicate over HTTP (port 80) which is a non-encrypted, insecure communication protocol. This can expose sensitive data like user credentials to eavesdroppers.",
        "text": "# In config/prod.exs\nconfig :my_app, MyAppWeb.Endpoint,\n  http: [ip: {127, 0, 0, 1}, port: 80],\n  url: [scheme: \"http\", host: \"example.com\", port: 80]"
      },
      "secure_code_example": {
        "description": "In this secure code, the application is now configured to communicate over HTTPS (port 443) with the SSL certificate. This secures the transmission of sensitive data with encryption.",
        "text": "# In config/prod.exs\nconfig :my_app, MyAppWeb.Endpoint,\n  https: [ip: {127, 0, 0, 1}, port: 443, keyfile: \"priv/ssl/selfsigned.key\", certfile: \"priv/ssl/selfsigned.crt\"],\n  url: [scheme: \"https\", host: \"example.com\", port: 443]"
      },
      "steps": [
        "Switch from HTTP to HTTPS. This means you will have to get an SSL certificate for your domain.",
        "Update the server configuration in the Phoenix configuration file to use HTTPS instead of HTTP."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "378",
    "title": "Non-encrypted confidential information - Hexadecimal",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Elixir's built-in Base module for encoding and decoding data"
    ],
    "need": "To ensure the confidentiality and integrity of sensitive information by using secure encryption methods.",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code example, sensitive data is being encoded to hexadecimal using Base.encode16(). Although this does obfuscate the data, it does not provide any security because it can easily be decoded back into its original form.",
        "text": "defmodule MyApp do\n  def encode(data) do\n    {:ok, hex_data} = data |> to_string() |> Base.encode16()\n    hex_data\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, the AES encryption algorithm is used to encrypt the data. This provides both confidentiality and integrity for the data. It's important to manage the encryption keys securely, as the security of the encrypted data depends on the security of the key.",
        "text": "defmodule MyApp do\n  def encode(data) do\n    # Here is an example key, but for real-world applications, you should use a secure way to store and access keys\n    key = :crypto.strong_rand_bytes(32)\n    iv = :crypto.strong_rand_bytes(16)\n    {:ok, encrypted_data} = :crypto.block_encrypt(:aes_gcm, key, iv, to_string(data))\n    encrypted_data\n  end\nend"
      },
      "steps": [
        "Use a secure encryption method such as AES (Advanced Encryption Standard).",
        "Use secure random keys for each encryption process.",
        "Use a secure method to store and manage encryption keys."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "383",
    "title": "Insecurely generated token - OTP",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Plug for building web applications in Elixir"
    ],
    "need": "To securely generate OTP and protect it from interception by attackers",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code example, the OTP is generated on the client side, which means that it can be intercepted before it even reaches the server. If the OTP is intercepted, an attacker can continue the application flow without having access to the phone number.",
        "text": "defmodule MyApp.ClientSideOTP do\n  def generate_otp do\n    otp = :rand.uniform(100000..999999)\n    MyApp.Server.validate_otp(otp)\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, the OTP is generated and stored on the server side. When validating the OTP, it's compared directly with the OTP stored in the server-side session, which prevents interception and unauthorized application flow continuation.",
        "text": "defmodule MyApp.ServerSideOTP do\n  def generate_otp do\n    otp = :rand.uniform(100000..999999)\n    Plug.Conn.put_session(conn, :otp, otp)\n  end\n\n  def validate_otp(conn, input_otp) do\n    session_otp = Plug.Conn.get_session(conn, :otp)\n    input_otp == session_otp\n  end\nend"
      },
      "steps": [
        "Generate the OTP on the server side, not on the client side.",
        "Once generated, immediately store the OTP in a secure server-side session.",
        "Validate the OTP directly from this secure server-side session."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "397",
    "title": "Insecure authentication method - LDAP",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Elixir's LDAP library for LDAP integration"
    ],
    "need": "Secure communication with LDAP server",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code example, we're connecting to an LDAP server without any encryption. The password is sent in plaintext over the network. An attacker who can listen to the network traffic can intercept the password.",
        "text": "defmodule MyApp.Insecure do\n  @username 'username'\n  @password 'password'\n  def authenticate do\n    :eldap.open(['ldap://example.com'])\n    |> :eldap.simple_bind({@username, @password})\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, we're connecting to the LDAP server over SSL. The network traffic, including the password, is encrypted. This prevents attackers from intercepting the password.",
        "text": "defmodule MyApp.Secure do\n  @username 'username'\n  @password 'password'\n  def authenticate do\n    :eldap.open(['ldaps://example.com'])\n    |> :eldap.simple_bind({@username, @password})\n  end\nend"
      },
      "steps": [
        "Use LDAP over SSL (LDAPS) to encrypt the network traffic.",
        "Bind all blind authentication connections to a separate LDAP server.",
        "When allowing connections from the internet, only allow blind authentication."
      ]
    },
    "last_update_time": "09/18/2023"
  },
  {
    "vulnerability_id": "421",
    "title": "Insecure encryption algorithm - Insecure Elliptic Curve",
    "context": [
      "Usage of Elixir (1.12.0 and above) for building scalable and fault-tolerant applications",
      "Usage of Crypto package for cryptographic operations in Elixir"
    ],
    "need": "Secure encryption",
    "solution": {
      "language": "elixir",
      "insecure_code_example": {
        "description": "In this insecure code example, the :secp160r1 elliptic curve is used, which is considered weak and therefore insecure. The key generated using this curve is then used to encrypt the data using AES encryption. The weak key might make the encryption vulnerable to attacks.",
        "text": "defmodule MyApp.Insecure do\n  def encrypt_data(data) do\n    private_key = :crypto.generate_key(:ecdh, :secp160r1)\n    {:ok, cipher_text} = :crypto.private_encrypt(:ecdh, data, private_key, :aes_cbc128)\n    cipher_text\n  end\nend"
      },
      "secure_code_example": {
        "description": "In this secure code example, the :secp384r1 elliptic curve is used, which is considered secure. The key generated using this curve is then used to encrypt the data using AES encryption. The secure key enhances the security of the encryption.",
        "text": "defmodule MyApp.Secure do\n  def encrypt_data(data) do\n    private_key = :crypto.generate_key(:ecdh, :secp384r1)\n    {:ok, cipher_text} = :crypto.private_encrypt(:ecdh, data, private_key, :aes_cbc128)\n    cipher_text\n  end\nend"
      },
      "steps": [
        "Use a secure elliptic curve when generating the key, such as :secp384r1.",
        "Ensure that all the components of the encryption are secure, including the key, the algorithm, and the cipher mode."
      ]
    },
    "last_update_time": "09/18/2023"
  }
]